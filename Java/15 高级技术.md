# 10 Java高级技术

## 10.1 类加载器

* 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化 

    1. **加载** 
        - 就是指将class文件读入内存，并为之创建一个Class对象；任何类被使用时系统都会建立一个Class对象。
    2. **连接**
        - 验证 是否有正确的内部结构，并和其他类协调一致
        - 准备 负责为类的静态成员分配内存，并设置默认初始化值
        - 解析 将类的二进制数据中的符号引用替换为直接引用
    3. **初始化**
        - 就是我们以前讲过的初始化步骤

* **类初始化时机**

    * 创建类的实例
    * 访问类的静态变量，或者为静态变量赋值
    * 调用类的静态方法
    * 使用反射方式来强制创建某个类或接口对应的`java.lang.Class`对象
    * 初始化某个类的子类
    * 直接使用java.exe命令来运行某个主类

* **类加载器**（负责将**.class文件加载**到内存中，并为之**生成**对应的**Class对象**）

    * Bootstrap ClassLoader**根类加载器（引导类加载器）**

        负责**Java核心类的加载**比如System,String等。在JDK中JRE的lib目录下rt.jar文件中

    * Extension ClassLoader**扩展类加载器**

        负责**JRE的扩展目录中jar包**的加载。在JDK中JRE的lib目录下ext目录

    * System(Application) ClassLoader**系统类加载器**

        负责在**JVM启动时加载来自java命令的class文件**，以及`classpath`环境变量所指定的jar包和类路径

* **<span style="background-color:yellow">类加载器的方法</span>**

    * <span style="background-color:yellow">**获得类加载器：clazz.getClassLoader()**</span>

        * classLoader.<span style="background-color:yellow">**getResource(name)**</span>

            **获取classes(out/src)下的任何URL资源**：name是资源路径，不能以/开头

            ```java
            URL url = clazz.getResource("test.txt")；
            String path = url.getPath();
            ```

        * ==**getResourceAsStream**==就是上面的进行了封装简化后的版本

## 10.2 反射（java.lang.reflect）

> 反射是框架设计的灵魂。框架：半成品软件。可以在框架的基础上进行软件开发，简化编码

* JAVA反射机制是在**运行状态中**，对于任意一个**类**，都能够**知道**这个类的**所有属性和方法**；对于任意一个**对象**，都能够**调用**它的任意一个**属性和方法**；**能够分析类能力的程序称为反射** 

* ==**原理：**==

    1. **将java文件保存到本地硬盘**
    2. **编译java文件，生成class文件**
    3. **jvm通过类加载器将class文件加载到内存中，用Class类表示（java中万事万物皆对象）**
    4. **得到了这个类之后，就可以得到class文件里面的所有内容**

* 好处

    * 可以在**程序运行过程中，操作这些对象**。如IDE中代码提示
    * 可以**解耦，提高程序的可扩展性**

* ==**获取字节码文件Class类型对象**==

    1. `Calss c = Student.class`通过**类名**得到。多用于参数传递
    2. `Class c = stu.getClass()`通过**对象**得到，此方法在Object类中定义。多用于对象获取字节码
    3. `Class c = Class.forName(String name)`：包括包名的全类名。多用于配置文件
        - `String getName();`获取全类名
        - `String getPackageName();`获取包名

    **同一个字节码文件(*.class)在一次程序运行过程中只会被加载一次，以上方式获取的Class对象都是同一个。**

* ==**通过反射分析类的能力**==

    * 包括有1.**域(成员变量)**；2.**构造器**；3.**方法**；

        * **不带Declare**返回类提供的**public**域、方法和构造器的**数组**，包括**超类的公有成员**

        * **带Declare**返回类提供的**全部**域、方法和构造器，**包括私有和保护成员**，但不包括超类的成员
            * 操作私有成员时**`setAccessible(flag)`**中flag设置为true

        ```java
        //若类中没有域(成员变量)或者Class对象描述的是基本类型或数组类型，则返回一个长度为0的数组
        Field get(Declare)Field(String name)
        Field[] get(Declare)Fields()
        
        Method get(Declare)Method(String name, Class<?>... parameterTypes)
        Method[] get(Declare)Methods()
        
        Constructor<T> get(Declare)Construcotr(Class<?>... parameterTypes)//返回一个构造器
        Constructor[] get(Declare)Construcotrs()
        //可以通过Constructor对象的newInstance(可传递参数列表)来创建对象；不要直接使用Class对象来创建！
        
        setAccessible(boolean b)//为以上三种反射对象设置可访问标志，true为屏蔽java语言访问检查
        ```

        ```java
        // 单个构造,无参构造可不带.class;传递参数类型
        Constructor con = c.getConstructor(String.class, int.class, String.class);
        Object obj = con.newInstance("zhangsan", 33, "beijing");
        //Object o = c.newInstance();//若调用空参构造可以直接使用Class类的newInstance()方法。在Java9开始弃用
        String name = con.getName();//获取构造方法名称
         
        // 单个域、属性
        Field field = c.getDeclaredField("name");
        field.setAccessible(true);
        field.set(obj, "lisi");//set
        Object objField = field.get(obj);//get
        String name = field.getName();//获取域名即成员变量名
        System.out.println(objField);
        
        // 单个方法,不带参可不写.class;传递参数类型
        Method method = c.getDeclaredMethod("add", int.class, int.class);
        Object objMethod = method.invoke(obj, 10, 20);
        //操作静态方法时，第一个参数为null，不需要实例
        Object objMethod = method.invoke(null, 10, 20);
        //获取方法名
        String name = method.getName();
        System.out.println(objMethod);
        ```


### 10.2.1 通过配置文件运行类中方法

```java
public class Demo{
	//main
	public static void main(String[] args) throws Exception{
    	//之前的方法调用谁的方法创建谁的对象，属于硬编码
    	//通过Properties集合来加载class.txt配置文件
   	 	Properties properties = new Properties();
        ClassLoader classLoader = UserTest.class.getClassLoader();
        InputStream is = classLoader.getResourceAsStream("prop.properties");
        properties.load(is);

    	//获取键值对数据
        String className = properties.getProperty("className");
        String methodName = properties.getProperty("methodName");

        Class c = Class.forName(className);
        Constructor con = c.getConstructor();
        Object o = con.newInstance();
        Method show = c.getMethod(methodName, String.class);
        show.invoke(o,"牛逼");
	}
}
```

### 10.2.2 通过反射越过泛型检查

* ArrayList`<Integer>`对象，添加一个字符串数据 
* **泛型机制是给编译器看的，运行时没有**。通过看add底层代码发现传入的是`<E>`是Object型

```java
ArrayList<Integer> arrayList = new ArrayList<>();
arrayList.add(10);
		
Class c = arrayList.getClass();//获取对象所属类的字节码文件对象
Method method = c.getMethod("add", Object.class);
method.invoke(arrayList, "hello");
```

### 10.2.3 通过反射给任意的一个对象的任意的属性赋值为指定的值

```java
public void setProperty(Object obj, String propertyName, Object value) throws Exception{
	Class c= obj.getClass();
	Field field = c.getDeclaredField(propertyName);
	field.setAccessible(true);
	field.set(obj, value);
}

public static void main(String[] args) throws Exception {
	Tool t = new Tool();
	Student s = new Student();
	t.setProperty(s, "name", "张三");
	t.setProperty(s, "age", 10);
	s.show();
}
```

## 10.3 动态代理

* **代理**：本来应该自己做的事情，却请了别人来做。**代理对象和目标对象需实现同一接口(有同样的方法)**

* **代理模式**（两者区别在于代理对象的生成模式）

    1. 静态代理：字节码一上来就创建好，并完成加载。装饰者模式就是静态代理的一种体现。 

    2. ==**动态代理**==：**程序运行过程**，在**内存中**动态的为目标对象**创建**一个虚拟的代理对象。字节码随用随创建，随用随加载。 

        `java.lang.reflect`包下提供了一个`Proxy`类和一个`InvocationHandler`接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理要求**被代理类最少实现一个接口**。 

        - 实现步骤：

            1. 代理对象和真实对象实现相同接口
            2. `代理对象 = Proxy.newProxyInstance();`
            3. 使用代理对象调用方法
            4. 增强方法

        - **创建指定接口的代理类对象实例**（类加载器，Class对象数组，调用处理器）

            ```java
            static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHander hander)
            //其中loader是与目标对象相同的类加载器
            //interfaces是接口的字节码对象数组 new Class<?>[]{interface.class}
            ```

            其中第三个参数为**调用处理器**，是实现了`InvocationHandler`接口的类对象，重写`invoke`方法

            ```java
            public static void main(String[] args) {
                public final Target target = new Target();//被代理的目标对象
            
                //动态创建代理对象
                TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(
                    target.getClass().getClassLoader(), 
                    target.getClass().getInterfaces(), 
                    new InvocationHandler() {
                        @Override
                        //被执行几次?---看代理对象调用方法几次;代理对象调用接口相应方法 都是调用该invoke方法
                        /** proxy:是代理对象，一般不用
            			 * method:代理对象调用的方法被封装为Method对象
            			 * args:代理对象调用方法时传递的实际参数，封装为数组，即参数列表
            			 */
                        public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{
                            //反射知识点。使用目标对象调用目标方法并传递参数，返回目标方法的返回值
                            Object obj = method.invoke(target, args);
                            //retrun返回的值给代理对象
                            return invoke;
                        }
                    }
                );
            	//调用代理对象
                proxy.method1();//调用invoke---Method：目标对象的method1方法  args：null  返回值null
                String method2 = proxy.method2();//调用invoke---Method:目标对象的method2方法 
            }
            ```

        - 增强方式：（invoke方法中）

            1. 增强**返回值**：通过**对`return`返回值的修改**
            2. 增强**参数列**表：通过**`method.getName()`判断要增强的方法**，并对**参数`args[]`数组进行修改**
            3. 增强**方法体**执行逻辑：**反射方法`invoke()`执行前后修改**

------

* 基于子类的动态代理

    * 提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 `asm.jar`或`org.springframework.cglib.proxy`

    * 要求：被代理类不能用 final 修饰的类（最终类）。 

        ```java
        public static void  main(String[] args) {
            final Actor actor = new Actor();      
            Actor cglibActor = (Actor) Enhancer.create(actor.getClass(), new MethodInterceptor() {
                /** 
        		 * 执行被代理对象的任何方法，都会经过该方法。在此方法内部就可以对被代理对象的任何 方法进行增强。     
        		 * 参数：     
        		   *  前三个和基于接口的动态代理是一样的。     
        		   *  MethodProxy：当前执行方法的代理对象。     
        		   *  返回值：当前执行方法的返回值     
        		 */    
                @Override    
                public Object intercept(Object proxy, 
                                        Method method, 
                                        Object[] args, 
                                        MethodProxy methodProxy) throws Throwable {
                    String name = method.getName();
                    Float money = (Float) args[0];
                    Object rtValue = null;     
                    if("basicAct".equals(name)){ 
                        //基本演出      
                        if(money > 2000){       
                            rtValue = method.invoke(actor, money/2); 
                        }     
                    } 
                    if("dangerAct".equals(name)){ 
                        //危险演出      
                        if(money > 5000){ 
                            rtValue = method.invoke(actor, money/2);      
                        } 
                    }     
                    return rtValue;    
                } 
            });     
            cglibActor.basicAct(10000); 
            cglibActor.dangerAct(100000); 
        }
        ```




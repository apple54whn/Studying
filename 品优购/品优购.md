电商模式有：

- **B2B**（Business to Business）：阿里巴巴
- **C2C**（Customer【顾客】 或 Consumer【消费者】）：淘宝、瓜子、易趣
- **B2C**（Business-to-Customer）：唯品会、乐蜂网
- **C2B**（Consumer to Business）：装修等。先有消费者提出需求，后有生产企业按需求组织生产
- **O2O**（Online To Offline）：饿了么、美团。将线下的商务机会与互联网结合，让互联网成为线下交易的平台
- F2C（Factory to customer）
- **B2B2C**：天猫、京东(混合)。第一个B指的是商品或服务的供应商，第二个B指的是从事电子商务的企业，C则是表示消费者

电商行业技术特点：技术新、技术范围广；分布式；高并发（集群、负载均衡）、高可用；海量数据、业务复杂、系统安全



# 1 分布式框架 Dubbox



## 1.1 品优购需求分析与系统设计

**B2B2C**：品优购网上商城主要分为**网站前台**、**运营商后台**、**商家管理后台**三个子系统

系统架构：**SOA**（Service-Oriented Architecture），是一种支持**面向服务**的架构样式，更多应用于互联网项目开发



## 1.2 Dubbox

> Dubbox 是一个分布式服务框架，前身是阿里巴巴开源项目Dubbo，后阿里巴巴停止了该项目的维护。当当网便在Dubbo基础上进行优化、维护，重新命名Dubbox 以区分。后续还有SpringCloud。

### 1.2.1 Dubbox简介

Dubbox 致力于提供高性能和透明化的**RPC远程服务调用**方案，以及**SOA服务治理**方案，是远程服务调用的分布式框架

![1546066605296](images/1546066605296.png)

> Dubbox的jar包并没有部署到Maven的中央仓库中，需要手动安装dubbo-2.8.4.jar到本地仓库



### 1.2.2 注册中心Zookeeper

> 官方推荐，负责服务地址的注册与查找，注册中心不转发请求，压力较小。是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。

Linux中安装Zookeeper（文档提供的Linux用户名root、密码itcast）

> Linux需要修改子网IP中网段为25（FastDNS服务器要求）。

1. 安装 jdk
2. 把 zookeeper 的压缩包（资源\配套软件\dubbox\zookeeper-3.4.6.tar.gz）上传到 linux 系统
   - 可以使用SecureCRT连接远程服务器，Alt+P进入SFTP，输入`put d:\zookeeper-3.4.6.tar.gz`上传（SSH也行）
3. 解压：`tar zxvf zookeeper-3.4.6.tar.gz`
4. 进入 zookeeper-3.4.6 目录，创建 data 文件夹：`mkdir data`
5. 进入conf目录 ，把 zoo_sample.cfg 改名为 zoo.cfg：`mv zoo_sample.cfg zoo.cfg`
6. 打开zoo.cfg , 修改 data 属性：`dataDir=/root/zookeeper-3.4.6/data`
7. 进入bin运行/状态/停止等 Zookeeper：`./zkServer.sh start/status/stop等`
8. Zookeeper的端口号为**2181**



### 1.2.3 Demo

#### 1 服务提供者开发

1. 在pom.xml添加Dubbox依赖（需要安装dubbox到本地Maven仓库），打包方式为**war包**。独立的工程，完成后先运行。

   ```xml
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>dubbo</artifactId>
       <version>2.8.4</version>			
   </dependency>
   <dependency>
       <groupId>org.apache.zookeeper</groupId>
       <artifactId>zookeeper</artifactId>
       <version>3.4.6</version>
   </dependency>
   <dependency>
       <groupId>com.github.sgroschupf</groupId>
       <artifactId>zkclient</artifactId>
       <version>0.1</version>
   </dependency>
   <dependency>
       <groupId>javassist</groupId>
       <artifactId>javassist</artifactId>
       <version>3.11.0.GA</version>
   </dependency>
   ```

2. 在web.xml中添加`ContextLoaderListener`加载`applicationContext*`配置文件，IoC容器的配置文件如下：

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xmlns:p="http://www.springframework.org/schema/p"
          xmlns:context="http://www.springframework.org/schema/context"
          xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" 
          xmlns:mvc="http://www.springframework.org/schema/mvc"
          xsi:schemaLocation="http://www.springframework.org/schema/beans 
                              http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/mvc 
                              http://www.springframework.org/schema/mvc/spring-mvc.xsd
                              http://code.alibabatech.com/schema/dubbo 
                              http://code.alibabatech.com/schema/dubbo/dubbo.xsd
                              http://www.springframework.org/schema/context 
                              http://www.springframework.org/schema/context/spring-context.xsd">
   
       <dubbo:protocol name="dubbo" port="20881"></dubbo:protocol><!--每个服务都有的端口，不配置默认为20880-->
       <dubbo:application name="dubboxdemo-service"/>  <!--与工程名相同即可-->
       <dubbo:registry address="zookeeper://192.168.25.129:2181"/> <!--注册中心-->
       <dubbo:annotation package="cn.itcast.dubboxdemo.service" /> <!--使用Dubbox的包扫描@Service-->
   </beans>
   ```

3. 服务层（省略了dao的调用）：导入的**`@Service`注解是由dubbox提供**的

   ```java
   @Service //import com.alibaba.dubbo.config.annotation.Service;
   public class UserServiceImpl implements UserService {
       public String getName() {		
           return "itcast";
       }
   }
   ```



#### 2 服务消费者开发

1. 在pom.xml添加Dubbox依赖（需要安装dubbox到本地Maven仓库），打包方式为**war包**。独立的工程，完成后后运行。

2. 在web.xml中添加`DispatcherServlet`加载`springmvc`配置文件、编码过滤器，IoC容器的配置文件如下：

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xmlns:p="http://www.springframework.org/schema/p"
          xmlns:context="http://www.springframework.org/schema/context"
          xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" 
          xmlns:mvc="http://www.springframework.org/schema/mvc"
          xsi:schemaLocation="http://www.springframework.org/schema/beans 
                              http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/mvc 
                              http://www.springframework.org/schema/mvc/spring-mvc.xsd
                              http://code.alibabatech.com/schema/dubbo 
                              http://code.alibabatech.com/schema/dubbo/dubbo.xsd
                              http://www.springframework.org/schema/context 
                              http://www.springframework.org/schema/context/spring-context.xsd">
   
       <mvc:annotation-driven >
           <mvc:message-converters register-defaults="false">
               <bean class="org.springframework.http.converter.StringHttpMessageConverter">  
                   <constructor-arg value="UTF-8" />
               </bean>  
           </mvc:message-converters>	
       </mvc:annotation-driven>
       
       <!-- 引用dubbo 服务 -->
       <dubbo:application name="dubboxdemo-web" />
       <dubbo:registry address="zookeeper://192.168.25.129:2181"/>
       <dubbo:annotation package="cn.itcast.dubboxdemo.controller" />
   </beans>
   
   ```

3. Web层：

   1. **拷贝**服务层中的**service包即其接口**
   2. 自动装配的**`@Reference`（由dubbox提供）**替代`@Autowired`

   ```java
   @Controller
   @RequestMapping("/user")
   public class UserController {
   	@Reference
   	private UserService userService;	
       
   	@RequestMapping("/showName")
   	@ResponseBody
   	public String showName(){
   		return userService.getName();
   	}		
   }
   ```


#### 3 管理中心的部署

> 开发时，需要知道注册中心都注册了哪些服务，以便我们开发和测试。管理中心就是一个web应用，部署到tomcat即可

1. 编译源码`dubbox-master.zip`中的`dubbo-admin`，得到war包：`mvn package -Dmaven.skip.test=true`跳过测试

   若要监控则编译`dubbo-monitor`

2. 将`dubbo-admin.war`移到Tomcat的webapps目录下（`mv`），启动Tomcat即可自动解压（访问用户名和密码均为root）

   如果你部署在和zookeeper同一台主机并且端口是默认的2181，则无需配置；否则需要修改WEB-INF下的dubbo.properties

   ```properties
   dubbo.registry.address=zookeeper://127.0.0.1:2181
   ```

   访问`http://192.168.25.129:8080/dubbo-admin/`即可



## 1.3 品优购框架搭建

### 1.3.1 工程结构设计分析

![](images/工程框架.png)

### 1.3.2 数据库

看文档

### 1.3.3 搭建框架

> 利用Maven建立maven工程、maven模块

父工程中pom.xml中只锁定版本，不依赖。其他的看文档

### 1.3.4 实体类和数据访问层

逆向工程generatorSqlmapCustom实现实体类与数据访问层代码的自动生成，拷贝至目标，实现Serializable。具体看文档

注意：需要build path MySQL8.0的驱动包，修改正确的Driver、URL。

注意：在后续**开启服务后找不到提供者**，有可能是逆向工程生成文件的问题（多生成了几次，append），删除后重新生成并复制

### 1.3.5 品牌列表

interface中service接口的编写……最终返回JSON数据的品牌列表





# 2 商品管理-品牌管理 AngularJS

## 2.1 AngularJS

### 2.1.1 AngularJS四大特征

> 学习的版本为Angular 1.0 即AngularJS（查看前端相关），后续的版本去掉了JS后缀，最新为4.0……

- **MVC 模式**

  ![](images/AngularJS%E7%9A%84MVC%E6%A8%A1%E5%BC%8F.png)

- **双向绑定**

  ![1546246234248](images/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.png)

- **依赖注入**

  看最上面的图

- **模块化设计**

  高内聚低耦合法则：

  - 官方提供的模块：ng、ngRoute（路由，课程没用到）、ngAnimate（动画，课程没用到）
  - 用户自定义的模块：angular.module('模块名',[ ])



2.1.2 AngularJS指令

> 引入`<script src="angular.min.js"></script>`

- `{{表达式 }}`：表达式可以是变量或是运算式

- **`ng-app`**：定义了 AngularJS 应用程序的根元素，告诉子元素以下的指令是归AngularJS 的， 会自动识别，在网页加载完毕时会自动引导（**自动初始化**）应用程序。**一般放在`body`标签中**

  ```html
  <body ng-app>
      {{100+100}}
  </body>
  ```

- **`ng-model`：双向绑定**，如下变量都是myname，都会同时改变

  ```html
  <body ng-app>
      请输入你的姓名：<input ng-model="myname"><br>
      <input ng-model="myname"><br>
      {{myname}},你好
  </body>
  ```

- **`ng-init`：初始化指令**，也可以绑定方法

  ```html
  <body ng-app   ng-init="myname='tom'">
      请输入你的姓名：<input ng-model="myname"><br>
      {{myname}},你好
  </body>
  ```



### 2.1.3 AngularJS控制器

- **`ng-controller`：指定所使用的控制器**

- **`$scope`**服务与数据模型相关联，也是表达式执行的上下文。==是**存在控制器中**用于**视图和控制器之间交换数据**==

  ```html
  <html>
      <head>
          <title>控制器</title>
          <script src="angular.min.js"></script>
          <script>
              //定义了一个叫myApp的模块，第二个参数数组为引用的模块，没有则不写
              var app=angular.module('myApp',[]); 
              //定义控制器
              app.controller('myController',function($scope){
                  $scope.add=function(){
                      return parseInt($scope.x)+parseInt($scope.y);
                  }
              });
          </script>
      </head>
      <body ng-app="myApp" ng-controller="myController">
          x:<input ng-model="x" >
          y:<input ng-model="y" >
          运算结果：{{add()}}
      </body>
  </html>
  ```

### 2.1.4 AngularJS事件

- **`ng-click`**

  ```html
  <html>
      <head>
          <title>入门小Demo-5  事件指令</title>
          <script src="angular.min.js"></script>	
          <script>
              //定义了一个叫myApp的模块，第二个参数数组为引用的模块，没有则不写
              var app=angular.module('myApp',[]);
              //定义控制器
              app.controller('myController',function($scope){			
                  $scope.add=function(){
                      $scope.z= parseInt($scope.x)+parseInt($scope.y);
                  }			
              });	
          </script>
      </head>
      <body ng-app="myApp" ng-controller="myController">
          x:<input ng-model="x" >
          y:<input ng-model="y" >
          <button ng-click="add()">运算</button>
          结果：{{z}}
      </body>
  </html>
  ```

### 2.1.5 AngularJS遍历

- **`ng-repeat`**

  * `$index`：在`ng-repeat`中可以获取索引，从0开始

  ```html
  <html>
      <head>
          <title>循环数据</title>
          <script src="angular.min.js"></script>
          <script>
              //定义了一个叫myApp的模块，第二个参数数组为引用的模块，没有则不写
              var app=angular.module('myApp',[]);
              //定义控制器
              app.controller('myController',function($scope){
                  $scope.list1= [100,192,203,434 ];//定义数组
                  $scope.list2= [
                      {name:'张三',shuxue:100,yuwen:93},
                      {name:'李四',shuxue:88,yuwen:87},
                      {name:'王五',shuxue:77,yuwen:56}
                  ];//定义数组
              });
          </script>
      </head>
      <body ng-app="myApp" ng-controller="myController">
          <table>
              <tr ng-repeat="x in list">
                  <td>{{x}}</td>
              </tr>
          </table>
  	<!--===============================================================-->
          <table>
              <tr>
                  <td>姓名</td>
                  <td>数学</td>
                  <td>语文</td>
              </tr>
              <tr ng-repeat="entity in list">
                  <td>{{entity.name}}</td>
                  <td>{{entity.shuxue}}</td>
                  <td>{{entity.yuwen}}</td>
              </tr>
          </table>
      </body>
  </html>
  ```



### 2.1.6 内置服务$http

- 我们的数据一般都是从后端获取的，可以使用内置服务`$http`来实现。以下代码要在Web环境中运行（运行在Tomcat中）

  ```html
  <html>
      <head>
          <title>内置服务</title>
          <meta charset="utf-8" />
          <script src="angular.min.js"></script>
          <script>
              var app=angular.module('myApp',[]);
              app.controller('myController',function($scope,$http){
                  $scope.findAll=function(){
                      $http.get('data.json').success(
                          function(data){
                              $scope.list=data;
                          }
                      );
                  }
              });
          </script>
      </head>
      <body ng-app="myApp" ng-controller="myController" ng-init="findAll()">
          <table>
              <tr>
                  <td>姓名</td>
                  <td>数学</td>
                  <td>语文</td>
              </tr>
              <tr ng-repeat="entity in list">
                  <td>{{entity.name}}</td>
                  <td>{{entity.shuxue}}</td>
                  <td>{{entity.yuwen}}</td>
              </tr>
          </table>
      </body>
  </html>
  ```



## 2.2 品牌列表分页实现

后端：利用**Pagehelper**并**返回PageInfo**即可完成（其实只需**总记录数`total`、分页后的数据`list`**）

前端：

- 引入Angular的分页组件

  ```html
  <script src="../plugins/angularjs/pagination.js"></script>
  <link rel="stylesheet" href="../plugins/angularjs/pagination.css">
  ```

- 在表格后放入分页组件

  ```html
  <!--在body中引入如下模块和控制器-->
  <body ng-app="pinyougou" ng-controller="brandController">
      <tm-pagination conf="paginationConf"></tm-pagination> <!--分页组件-->
  </body>
  ```

- AngularJS控制器代码

  ```javascript
  //构建品优购app模块时引入pagination模块
  var app = angular.module("pinyougou", ['pagination']);
  app.controller("brandController", function ($scope, $http) { //引入$scope, $http服务
  
      //分页组件配置
      $scope.paginationConf = {
          currentPage: 1, //当前页码
          totalItems: 10, //总记录数
          itemsPerPage: 10, //每页显示记录数，有如下选项
          perPageOptions: [10, 20, 30, 40, 50],
          onChange: function () { //每次更改（更新）页面时触发事件
              $scope.reloadList();
          }
      };
  
      //重新加载封装，只为了简写
      $scope.reloadList = function () {
          $scope.findAll($scope.paginationConf.currentPage, $scope.paginationConf.itemsPerPage);
      };
  
      //调用后端查找分页数据
      $scope.findAll = function (pageNum, pageSize) {
          $http.get("../brand/findAll.do?pageNum=" + pageNum + "&pageSize=" + pageSize).success(
              function (data) {
                  $scope.list = data.list;//返回查找的数据
                  $scope.paginationConf.totalItems = data.total;//更新总记录数totalItems
              }
          );
      };
  });
  ```



## 2.3 增加品牌

后端：用**`@RequestBody`接收JSON**数据并封装到pojo类，**返回entity实体类**（属性有success、message）的JSON形式

​	注意：应该先查询这个品牌是否存在，存在则抛异常，不存在才可以添加。也可以让数据库中name列唯一

前端：

* `ng-click="entity={}"`新建按钮清空原先输入数据、**`ng-model`封装数据**、**`ng-click`保存按钮触发事件**

  ```html
  <tr>
      <td>品牌名称</td>
      <td><input placeholder="品牌名称" ng-model="entity.name"></td>
  </tr>
  <tr>
      <td>首字母</td>
      <td><input placeholder="首字母" ng-model="entity.firstChar"></td>
  </tr>
  
  <button ng-click="save()">保存</button><!--别写到a标签中了！！！-->
  ```

* 控制器中**save方法**

  ```javascript
  //添加、更新商品
  $scope.save = function () {
      var method = 'add'; 
      if ($scope.entity.id!=null){ //根据id有无来区分更新、添加
          method = 'update';
      }
      $http.post("../brand/"+method+".do",$scope.entity).success(
          function (data) {
              if (data.success){
                  alert("success")
                  $scope.reloadList();//成功后就更新列表
              } else {
                  alert(data.message);
              }
          }
      );
  };
  ```

2.4 修改品牌

后端：**`findOne`利用主键id查找并回显**，**`update`利用封装的实体（包括主键id）更新数据，返回entity实体类**的JSON形式

前端：

* 回显数据

  * **`ng-click`修改按钮绑定事件**

    ```html
    <button type="button"  ng-click="findOne(x.id)">修改</button>
    ```

  * 控制器中**findOne方法**，由于2.3和2.4中增加品牌和修改品牌用的同一代码，并且绑定了变量，利用双向绑定特性：

    ```javascript
    //调用后端回显数据
    $scope.findOne = function (id) {
        $http.get("../brand/findOne.do?id="+id).success(
            function (data) {
                $scope.entity = data;//利用双向绑定特性，直接可绑定所有
            }
        )
    }
    ```

* 保存修改的数据，由于2.3和2.4中增加品牌和修改品牌用的同一代码，所以保存按钮的方法需要改写为如下：

  ```javascript
  //添加、更新商品
  $scope.save = function () {
      var method = 'add';
      if ($scope.entity.id!=null){
          method = 'update';
      }
      $http.post("../brand/"+method+".do",$scope.entity).success(
          function (data) {
              if (data.success){
                  alert("success")
                  $scope.reloadList();//成功后就更新列表
              } else {
                  alert(data.message);
              }
          }
      );
  };
  ```


## 2.5 多选删除品牌

后端：根据前端传入的**ids数组删除数据**，**返回entity实体类**的JSON形式

前端：

* **复选框单击事件**

  ```javascript
  <input type="checkbox" ng-click="updateSelection($event,x.id)">
  ```

* **控制器**中根据传入的**`$event`源**，用**`target`属性获取该元素**，判断**checked**向ids数组添加、删除数据

  ```javascript
  //删除品牌
  $scope.selectIds = [];
  $scope.updateSelection  = function ($event,id) {
      if ($event.target.checked){
          $scope.selectIds.push(id);//添加id
      } else {
          let index = $scope.selectIds.indexOf(id);
          $scope.selectIds.splice(index,1);//删除id
      }
  }
  ```

* **删除按钮单击事件**

  ```html
  <button type="button" ng-click="dele()" title="删除">删除</button>
  ```

* **控制器中删除品牌逻辑代码**

  ```javascript
  //删除品牌
  $scope.dele = function () {
      if (confirm("确认删除？")) {
          $http.get("../brand/delete.do?ids=" + $scope.selectIds).success(
              function (data) {
                  if (data.success) {
                      $scope.reloadList();//刷新列表
                      $scope.selectIds=[];//清除多选框
                  } else {
                      alert(data.message);
                  }
              }
          );
      }
  };
  ```


## 2.6 品牌条件查询

> 使用这个就可以替代2.2章节，删除即可

后端：

* interface层不提，service中利用逆向工程（没学啊，等会再看看）

  ```java
  @Override
      public PageInfo findAll(TbBrand tbBrand, int pageNum, int pageSize) {
          PageHelper.startPage(pageNum, pageSize);
          //逆向工程中生成的。。。
          TbBrandExample example = new TbBrandExample();
          TbBrandExample.Criteria criteria = example.createCriteria();
          if (tbBrand != null) {
              if (tbBrand.getName() != null && tbBrand.getName().length() > 0) {
                  criteria.andNameLike("%" + tbBrand.getName()+"%");
              }
              if (tbBrand.getFirstChar() != null && tbBrand.getFirstChar().length() > 0) {
                  criteria.andFirstCharEqualTo(tbBrand.getFirstChar());
              }
          }
          List<TbBrand> tbBrands = brandMapper.selectByExample(example);
          return new PageInfo<>(tbBrands);
      }
  ```

* controller层需要使用`@RequestBody`封装**POST请求**的JSON数据，还有分页数据

  ```java
  @RequestMapping("/findAll")
  public PageInfo findAll(@RequestBody TbBrand tbBrand,int pageNum,int pageSize){
      return brandService.findAll(tbBrand,pageNum,pageSize);
  }
  ```

前端：

* `ng-model`绑定条件实体，`ng-click`调用`reloadList()`方法（只是为了简写）进而调用`findAll()`方法

  ```html
  品牌名称：<input ng-model="searchEntity.name"> 品牌首字母：<input ng-model="searchEntity.firstChar">
  <button class="btn btn-default" ng-click="reloadList()">查询</button>
  ```

* 控制器中（和2.2一致，都列举出来）

  ```javascript
  var app = angular.module("pinyougou", ['pagination']);//构建品优购app模块时引入pagination模块
  app.controller("brandController", function ($scope, $http) {
  
      //分页组件配置
      $scope.paginationConf = {
          currentPage: 1, //当前页码
          totalItems: 10, //总记录数
          itemsPerPage: 10, //每页显示记录数，有如下选项
          perPageOptions: [10, 20, 30, 40, 50],
          onChange: function () { //每次更改（更新）页面时触发事件
              $scope.reloadList();//更新列表
          }
      };
  
      //分页更新列表，为了简写
      $scope.reloadList = function () {
          $scope.findAll($scope.paginationConf.currentPage, $scope.paginationConf.itemsPerPage);
      };
  
      //条件查询并分页
      $scope.searchEntity = {};//需要先赋值，否则没有输入条件时为null前端会报错
      $scope.findAll = function (pageNum, pageSize) {
          $http.post("../brand/findAll.do?pageNum="+pageNum+"&pageSize="+pageSize, $scope.searchEntity).success(
              function (data) {
                  $scope.list = data.list;//返回查找的数据
                  $scope.paginationConf.totalItems = data.total;//更新总记录数totalItems
              }
          )
      };
      
      //增删改......
  }
  ```





## 2.7 前端分层开发及控制器继承

运用**MVC的设计模式**，将代码进行分离，提高程序的可维护性。AngularJS的分模块开发可以分为：

- **服务层**（service）：和后端交互
- **控制层**（controller）：和视图（页面）交互

在 AngularJS 中，==**服务是一个函数或对象**==，可在你的 AngularJS 应用中使用。

------

有些功能是每个页面都有可能用到的，比如分页，复选等等。可以通过**控制器继承**的方式来实现

是伪继承，利用`{$scope:$scope}`连通两个控制器的`$scope`

------

js/base.js

```javascript
var app = angular.module("pinyougou", []);//构建品优购app模块
```

js/base_pagination.js

```js
var app = angular.module("pinyougou", ['pagination']);//构建品优购app模块时引入pagination模块
```

js/service/brandService.js

```js
//品牌服务
app.service("brandService", function ($http) {
    //查询所有
    this.findAll = function () {
        return $http.get("../brand/findAll.do);
    };
    //带条件查询的分页请求
    this.findPage = function (pageNum, pageSize, searchEntity) {
        return $http.post("../brand/findPage.do?pageNum=" + pageNum + "&pageSize=" + pageSize, searchEntity);
    };
    //查询一个请求
    this.findOne = function (id) {
        return $http.get("../brand/findOne.do?id=" + id)
    };
    //增加请求
    this.add = function (entity) {
        return $http.post("../brand/add.do", entity);
    };
    //更新请求
    this.update = function (entity) {
        return $http.post("../brand/update.do", entity);
    };
    //删除请求
    this.delete = function (ids) {
        return $http.get("../brand/delete.do?ids=" + ids);
    };
});
```

js/controller/baseController.js

```js
app.controller("baseController",function ($scope) {
    //分页组件配置
    $scope.paginationConf = {
        currentPage: 1, //当前页码
        totalItems: 10, //总记录数
        itemsPerPage: 10, //每页显示记录数，有如下选项
        perPageOptions: [10, 20, 30, 40, 50],
        onChange: function () { //每次更改（更新）页面时触发事件
            $scope.reloadList();//更新列表
        }
    };
    //分页更新列表，为了简写
    $scope.reloadList = function () {
        $scope.findPage($scope.paginationConf.currentPage, $scope.paginationConf.itemsPerPage);
    };
    //复选框勾选的数组值
    $scope.ids = [];
    $scope.updateSelection = function ($event, id) {
        if ($event.target.checked) {
            $scope.ids.push(id);
        } else {
            let index = $scope.ids.indexOf(id);
            $scope.ids.splice(index, 1);
        }
    };
});
```

js/controller/brandController.js

```js
//品牌控制器
app.controller("brandController", function ($controller,$scope, brandService) {

    //继承baseController
    $controller("baseController",{$scope:$scope});

	//查询所有
    $scope.findAll=function(){
        brandService.findAll().success(
            function(response){
                $scope.list=data.list;//返回查找的数据
            }
        );
    }

    //条件查询并分页
    $scope.searchEntity = {};//需要先赋值，否则没有输入条件时为null前端会报错
    $scope.findPage = function (pageNum, pageSize) {
        brandService.findPage(pageNum, pageSize, $scope.searchEntity).success(
            function (data) {
                $scope.list = data.list;//返回查找的数据
                $scope.paginationConf.totalItems = data.total;//更新总记录数totalItems
                //$scope.paginationConf.itemsPerPage=response.total;//若想展示所有数据，可以更新每页显示记录数
                //但是若是需要查找所有还是自定义方法吧
            }
        )
    };
    //添加、更新商品
    $scope.save = function () {
        let obj = null;
        if ($scope.entity.id != null) {
            obj = brandService.update($scope.entity);
        } else {
            obj = brandService.add($scope.entity);
        }
        obj.success(
            function (data) {
                if (data.success) {
                    $scope.reloadList();//成功后就更新列表
                } else {
                    alert(data.message);
                }
            }
        );
    };
    //回显数据
    $scope.findOne = function (id) {
        brandService.findOne(id).success(
            function (data) {
                $scope.entity = data;//利用双向绑定特性，直接可绑定所有
            }
        )
    };
    //删除品牌
    $scope.delete = function () {
        if (confirm("确认删除？")) {
            brandService.delete($scope.ids).success(
                function (data) {
                    if (data.success) {
                        $scope.reloadList();//刷新列表
                        $scope.selectIds=[];//清除多选框
                    } else {
                        alert(data.message);
                    }
                }
            );
        }
    };
});
```

admin/brand.html中引入即可

```html
<script src="../js/base_pagination.js"></script>
<script src="../js/service/brandService.js"></script>
<script src="../js/controller/baseController.js"></script><!--必须先引入父controller-->
<script src="../js/controller/brandController.js"></script>
```








# 3 商品管理-规格及模板管理

黑马代码生成器使用注意：

* 连接不上MySQL8
* 只能连接3306端口，其他端口修改配置文件也不行（暂时修改MySQL5为3306端口，MySQL8为3308端口）

* 生成的代码service中，和数据库的类型不一致
* 修改为PageInfo的使用



## 3.1 规格管理

涉及的表有规格表（主）、规格选项表（从）



### 3.1.1 展示规格

同品牌管理一致，引入js；放置分页组件；在body元素指定模块名和控制器名；循环表格（注意数据库列名和实体类驼峰命名）



### 3.1.2 增加规格

#### 1、增加行

绑定click事件，`addTableRow()`方法

```html
<button type="button" ng-click="addTableRow()">新增规格选项</button>
```

两个对象变量的双向绑定，新建时重置entity变量的数据

```html
<button type="button"  ng-click="entity= {specification:{},specificationOptionList:[]}">新建</button>

<td><input placeholder="规格名称" ng-model="entity.specification.specName"></td>

<tr ng-repeat="x in entity.specificationOptionList">
    <td>
        <input class="form-control" placeholder="规格选项" ng-model="x.optionName">
    </td>
    <td>
        <input class="form-control" placeholder="排序" ng-model="x.orders">
    </td>
    <td>
        <button type="button" class="btn btn-default" title="删除">删除</button>
    </td>
</tr>
```

控制器中`addTableRow()`方法，增加表格行

```javascript
//省略specification定义也行，不会空指针（直接绑定）。但是更应该放在新建按钮按下后重置entity变量的数据
//$scope.entity= {"specification":{},"specificationOptionList":[]};//
$scope.addTableRow = function () {
    $scope.entity.specificationOptionList.push({});
};
```

#### 2、删除行

`ng-repet`中利用`$index`获取索引

```html
<button type="button" title="删除" ng-click="deleteTableRow($index)">删除</button>
```

控制器中`deleteTableRow()`方法调用`splice()`方法，删除表格行

```javascript
$scope.deleteTableRow = function (index) {
    $scope.entity.specificationOptionList.splice(index,1);
}
```

#### 3、提交保存

将规格和规格选项数据合并成一个对象来传递（需要一个**组合对象**保存这俩对象）。得到组合对象中的规格和规格选项列表，**插入规格并返回规格ID**，然后**循环插入规格选项**。TbSpecificationMapper.xml文件应添加`selectKey `

```java
public class Specification implements Serializable {
    private TbSpecification specification;//和前端名称一致
    private List<TbSpecificationOption> specificationOptionList;//和前端名称一致
    //getter.setter...
}
```

```xml
<selectKey keyProperty="id" resultType="java.lang.Long" order="AFTER" >
    SELECT LAST_INSERT_ID() AS id
</selectKey>
```

interface和service以及web层都需要修改传入的类型为组合对象Specification，service层如下

```java
@Override
public void add(Specification specification) {
    //利用组合实体类获取其中两个对象
    TbSpecification tbSpecification = specification.getSpecification();
    specificationMapper.insert(tbSpecification);

    List<TbSpecificationOption> specificationOptionList = specification.getSpecificationOption();
    for (TbSpecificationOption option : specificationOptionList) {
        option.setSpecId(tbSpecification.getId());//设置规格id
        specificationOptionMapper.insert(option);//新增规格
    }
}
```



### 3.1.3 修改规格

#### 1、获取规格数据回显

service中使用逆向工程查询数据并封装到组合对象Specification中。interface和web层只修改返回类型

由于前端修改和增加用的同一页面，所以不需要重新进行数据绑定

```java
@Override
public Specification findOne(Long id){
    Specification specification = new Specification();
    //获取规格
    specification.setSpecification(specificationMapper.selectByPrimaryKey(id));
    //获取规格选项集合（逆向工程）
    TbSpecificationOptionExample example = new TbSpecificationOptionExample();
    TbSpecificationOptionExample.Criteria criteria = example.createCriteria();
    criteria.andSpecIdEqualTo(id);
    specification.setSpecificationOptionList(specificationOptionMapper.selectByExample(example));

    return specification;
}
```



#### 2、保存修改结果

service中使用逆向工程查询数据并封装到组合对象Specification中。interface和web层只修改返回类型

由于前端修改和增加用的同一页面，所以不需要重新进行数据绑定

```java
@Override
public void update(Specification specification){
    TbSpecification tbSpecification = specification.getSpecification();

    //更新规格实体
    specificationMapper.updateByPrimaryKey(tbSpecification);

    //删除所有规格选项（由于不清楚是删除还是修改或添加规格选项），利用逆向工程
    TbSpecificationOptionExample example =  new TbSpecificationOptionExample();
    TbSpecificationOptionExample.Criteria criteria = example.createCriteria();
    criteria.andSpecIdEqualTo(tbSpecification.getId());//mapper中利用mysql函数获取id
    specificationOptionMapper.deleteByExample(example);

    //插入规格选项
    for (TbSpecificationOption tbSpecificationOption : specification.getSpecificationOptionList()) {
        tbSpecificationOption.setSpecId(tbSpecification.getId());
        specificationOptionMapper.insert(tbSpecificationOption);
    }
}
```



### 3.1.4 删除规格

删除规格时要把其所拥有的规格属性一同删除

```java
@Override
public void delete(Long[] ids) {
    for(Long id:ids){
        //删除规格
        specificationMapper.deleteByPrimaryKey(id);
        //删除规格选项（逆向工程）
        TbSpecificationOptionExample example = new TbSpecificationOptionExample();
        TbSpecificationOptionExample.Criteria criteria = example.createCriteria();
        criteria.andSpecIdEqualTo(id);
        specificationOptionMapper.deleteByExample(example);
    }		
}
```

前端和品牌管理一样：checkbox中`ng-click="updateSelection($event,x.id)`，删除按钮`ng-click="dele()"`







## 3.2 品牌和规格的模板管理

模板是为了关联品牌和规格，如手机模板关联的品牌有iPhone、华为等，关联的规格有网络制式等。扩展属性为模板特有的属性。以上三个都可以用JSON格式存储。

### 3.2.1 展示模板

同品牌管理一致，引入js；放置分页组件；在body元素指定模块名和控制器名；循环表格（注意数据库列名和实体类驼峰命名）

由于上三个属性使用的是JSON格式，展示时需要转换为字符串。并且这个功能好多地方都会用到，可以抽取到baseController

```js
//JSON转自定义字符串，key代表需要的json属性
$scope.json2String = function (jsonString,key) {
    let json = JSON.parse(jsonString);
    let value = [];
    for (let i=0;i<json.length;i++){
        value.push(json[i][key]);
    }
    return value.join("，");
}
```

```html
<tr ng-repeat="x in list"><!--html演示如下-->
    <td>{{x.id}}</td>
    <td>{{json2String(x.brandIds,'text')}}</td>
</tr>
```







### 3.2.2 品牌、规格下拉列表 select2

select2组件（查看前端相关），可以多选，可与AngularJS整合。此次选择是的多选下拉列表，需要的**数据类型**和**前端代码**如下：

```javascript
$scope.brandList={data:[{id:1,text:'联想'},{id:2,text:'华为'},{id:3,text:'小米'}]};
```

```html
<input select2  select2-model="entity.brandIds" config="brandList" multiple placeholder="选择品牌（可多选）" class="form-control" type="text"/>	
Config用于配置数据来源
select2-model用于指定用户选择后提交的变量，根据数据库的列名来决定名称。但是它会提交{id:1,text:'联想'}类型的，所以有时需要
ng-model替代
```

------

#### 1、后端封装数据到`List<Map>`中

由于select2需要数据格式不同。（interface、service、web（请求映射为`/brand/selectOptionList.do`）都需要添加）

```xml
<select id="selectOptionList" resultType="java.util.Map"><!--MyBatis可以推断出具体传入语句的参数，但是resultType不行-->
    select id,name text from tb_brand
</select>
```

#### 2、前端

引入JS，angular-select2.js必须放在base.js之后！（即定义的app之后）注意目录问题（可能要修改最后一个）

```html
<link rel="stylesheet" href="../plugins/select2/select2.css" />
<link rel="stylesheet" href="../plugins/select2/select2-bootstrap.css" />
<script src="../plugins/select2/select2.min.js" type="text/javascript"></script>
<script type="text/javascript" src="../js/angular-select2.js">  </script> <!--和AngularJS整合，上面都是原生的-->
```

brandService层

```js
//下拉列表请求
this.selectOptionList = function () {
    return $http.get("../brand/selectOptionList.do");
}
```

typeTemplateController层（需要先把brandService服务注入）

```js
//读取品牌列表
$scope.brandList = {data:[]};//先定义，否则报错（不影响结果）
$scope.findBrandList = function () {
    brandService.selectOptionList().success(
        function (data) {
            $scope.brandList = {data:data};//注意select2要求的数据格式
        }
    )
}
```

在type_template.html中需要引入brandService.js文件。在body中添加`ng-init="findBrandList()"`方法（多个方法用分号隔开）。select2下拉框：

```html
<input select2  select2-model="entity.brandIds" config="brandList" multiple placeholder="选择品牌（可多选）" class="form-control" type="text"/>	
根据数据库的列名来决定绑定的变量名称
```

> 规格下拉列表实现同品牌下拉列表实现一致





### 3.2.3 增加、删除扩展属性行

同增加规格中一致



### 3.2.4 新增模板

数据双向绑定

* 商品类型`ng-model="entity.name"`
* 关联品牌`select2-model="entity.brandIds"`，后端保存的就是JSON数据
* 关联规格`select2-model="entity.specIds"`，后端保存的就是JSON数据
* 扩展属性，遍历时绑定`ng-model="x.text"`

保存绑定`ng-click="save()"`



### 3.2.5 修改模板

findOne回显时由于传过来的是JSON**字符串**，前端若没有指定接收的类型为JSON对象，则需要使用`JSON.parse()`来转换（jQuery中指定返回类型为json则没有此问题，AngularJS中没设置成功。。。），保存修改的数据功能已经和新增一致

```js
//查询实体
$scope.findOne = function (id) {
    typeTemplateService.findOne(id).success(
        function (response) {
            $scope.entity = response;
            //转换字符串为JSON
            $scope.entity.brandIds = JSON.parse($scope.entity.brandIds);
            $scope.entity.specIds = JSON.parse($scope.entity.specIds);
            $scope.entity.customAttributeItems = JSON.parse($scope.entity.customAttributeItems);
        }
    );
}
```



### 3.2.6 删除模板

后端为代码生成器生成代码，不用修改即可使用

前端和品牌管理一样：checkbox中`ng-click="updateSelection($event,x.id)`，删除按钮`ng-click="dele()"`







# 4 商家入驻审核及 SpringSecurity

## 4.1 运营商系统

在pinyougou-manager-web添加依赖（不用指定版本，父工程已指定），自动导入spring-security-core/config/web三个依赖

```xml
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-config</artifactId>
</dependency>
```

### 4.1.1 登陆

常使用用户名：admin，密码：admin

* web.xml中**监听器**加载spring-security.xml，配置`springSecurityFilterChain`**过滤器**（详细看SSM笔记）
* login.html中name、action、method的编写。提交按钮或a标签的编写

### 4.1.2 显示登陆名

（详细看SSM笔记）

### 4.1.3 退出登陆

配置logout标签即可，注销按钮访问`/logout`（详细看SSM笔记）



## 4.2 商家入驻审核

准备工作：复制代码生成器生成的所需要的前后端代码到pinyougou-shop-web中

### 4.2.1 商家入驻-注册

> 注册并添加至数据库中即可。常使用用户名：xiaomi或qiandu，密码：123456

register.html中引入JS；body中指令；数据双向绑定；

```html
<script src="./plugins/angularjs/angular.min.js"></script>
<script src="./js/base.js"></script>
<script src="./js/service/sellerService.js"></script>
<script src="./js/controller/baseController.js"></script><!--必须先引入父controller-->
<script src="./js/controller/sellerController.js"></script>

<body ng-app="pinyougou" ng-controller="sellerController">
    <input type="text" ng-model="entity.sellerId" placeholder="登陆名">
	......
</body>
```

sellerController.js中添加`add`方法，并在html中申请入驻按钮绑定`ng-click="add()"`方法

```js
//新增
$scope.add=function(){
    sellerService.add( $scope.entity  ).success(
        function(response){
            if(response.success){
                location.href = "shoplogin.html";//若注册成功跳转登录页面（其实还需要审核）
            }else{
                alert(response.message);
            }
        }
    );
}
```

后端中，需要修改service层，在添加商家信息前，设置其状态信息（有0，1，2，3），创建时间信息

```java
@Override
public void add(TbSeller seller) {
    seller.setStatus("0");
    seller.setCreateTime(new Date());
    sellerMapper.insert(seller);		
}
```



### 4.2.2 商家审核-待审核列表

> 修改其状态值即可。0：未审核   1：已审核   2：审核未通过   3：关闭

只有状态值为0的才需要审核（seller_1.html），其他的都放在商家管理中（seller.html）

此时修改后端代码比较麻烦，可以给前台body添加初始化参数`ng-init="searchEntity={'status':'0'}"`，配合自动生成的controller中定义的如下代码即可理解

```js
//条件查询并分页
$scope.searchEntity = {};//需要先赋值，否则没有输入条件时为null前端会报错
$scope.findAll = function (pageNum, pageSize) {
    sellerService.findAll(pageNum, pageSize, $scope.searchEntity).success(
        function (data) {
            $scope.list = data.list;//返回查找的数据
            $scope.paginationConf.totalItems = data.total;//更新总记录数totalItems
        }
    )
};
```

```js
this.findAll=function(page,rows,searchEntity){
    return $http.post('../seller/search.do?page='+page+"&rows="+rows, searchEntity);
}  
```



### 4.2.3 商家审核-商家详情

findOne，绑定数据，回显数据。查看之前的代码



### 4.2.4 商家审核-修改状态

后端：仅仅是修改状态，所以需要在后端编写`updateStatus()`方法

```java
@RequestMapping("/updateStatus")
public Result updateStatus(String sellerId,String status){
    try {
        sellerService.updateStatus(sellerId,status);
        return new Result(true,"修改状态成功");
    } catch (Exception e) {
        e.printStackTrace();
        return new Result(false,"修改状态失败");
    }
}
```

```java
@Override
public void updateStatus(String sellerId, String status) {
    TbSeller tbSeller = sellerMapper.selectByPrimaryKey(sellerId);
    tbSeller.setStatus(status);
    sellerMapper.updateByPrimaryKey(tbSeller);
}
```

前端：sellerService.js和sellerController.js

```js
this.updateStatus = function (sellerId,status) {
    return $http.get('../seller/updateStatus.do?sellerId='+sellerId+'&status='+status);
}
```

```js
$scope.updateStatus = function (sellerId,status) {
    sellerService.updateStatus(sellerId,status).success(
        function (data) {
            if (data.success){
                $scope.reloadList();//成功重新加载
            } else {
                alert(data.message);
            }
        }
    )
}
```

```html
<button ng-click="updateStatus(entity.sellerId,'1')">审核通过</button><!--其他的传2，3-->
```





## 4.3 商家系统登陆与安全控制

> 商家的数据库表中id为username

==【注意】==由于pinyougou-shop-web**消费者**中UserDetailsServiceImpl是**普通类**，不能自动注入Dao接口。需要借助Dubbox的Service来间接调用，并且Service也不能直接注入，需要通过dubbox使用接口来注入Service实现类

```java
public class UserDetailsServiceImpl implements UserDetailsService {

    private SellerService sellerService;

    public void setSellerService(SellerService sellerService) {
        this.sellerService = sellerService;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        TbSeller seller = sellerService.findOne(username);//查找数据库中的User对象
        System.out.println(username+"==="+seller.getPassword()+"==="+seller.getStatus());
        if (seller != null) {
            boolean enabled = seller.getStatus().equals("1"); //账户是否可以使用
            //角色信息本应该和数据库中User对象一起查询出来，然后遍历并添加到如下authorities集合中
            List<GrantedAuthority> authorities = new ArrayList<>();
            authorities.add(new SimpleGrantedAuthority("ROLE_SELLER"));
            return new User(username, seller.getPassword(), enabled, true, true, true, authorities);
        } else {
            return null;
        }
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--采用如下约束配置可以在配置时不加security前缀，但在配置bean时需要加beans前缀。主要方便springsecurity配置
 采用此约束文件，没有前缀的都是springsecurity自身的配置-->
<beans:beans xmlns="http://www.springframework.org/schema/security"
             xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
             xsi:schemaLocation="http://www.springframework.org/schema/beans
                                 http://www.springframework.org/schema/beans/spring-beans.xsd
                                 http://www.springframework.org/schema/security
                                 http://www.springframework.org/schema/security/spring-security.xsd  http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd">

    <!-- 配置不拦截的资源（静态资源及登录相关），不登录也可以访问。否则可能会有重定向次数过多错误  -->
    <http pattern="/*.html" security="none"/> <!--webapp一级目录下的html文件（其实包括login.html，error.html等）-->
    <http pattern="/css/**" security="none"/>
    <http pattern="/js/**" security="none"/>
    <http pattern="/img/**" security="none"/>
    <http pattern="/plugins/**" security="none"/>
    <http pattern="/seller/add.do" security="none"/> <!--注册相关的也必须放行-->


    <!--http标签主要用于配置拦截的具体的规则
     auto-config="true"	不用自己编写登录的页面，框架提供默认登录页面，不配置默认为true
     use-expressions="true"	是否启用SPEL表达式，不配置默认为true（功能强大，可以限制ip等，没学习过）-->
    <http>
        <!-- 具体的拦截规则 pattern="表示拦截页面"，与web.xml中不同。此处为目录规则，/**代表目录及其子目录
                           access="访问系统的角色名称（以ROLE_开头），当前用户必须有ROLE_USER或...的角色" -->
        <intercept-url pattern="/**" access="hasAnyRole('ROLE_ADMIN','ROLE_SELLER')"/> <!--SPEL表达式-->
        <!-- 开启表单登陆功能，定义跳转的具体的页面 -->
        <form-login
                    login-page="/shoplogin.html"
                    default-target-url="/admin/index.html"
                    always-use-default-target="true"
                    authentication-failure-url="/shoplogin.html"
                    />
        <!-- 退出，invalidate-session 是否删除session logout-url：登出处理url logout-successurl：登出成功页面-->
        <logout/>
        <!-- 关闭csrf（Cross-site request forgery）跨站请求伪造 ,如果不加会出现403错误。也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。HTML不能使用，JSP可以带指定头信息使用-->
        <csrf disabled="true"/>

        <!--不拦截内置框架页-->
        <headers>
            <frame-options policy="SAMEORIGIN"/>
        </headers>
    </http>


    <!-- 引用dubbox 服务 -->
    <dubbo:application name="pinyougou-shop-web" />
    <dubbo:registry address="zookeeper://192.168.25.129:2181"/>
    <!--通过dubbox使用接口来注入实现类-->
    <dubbo:reference id="sellerService" interface="com.pinyougou.sellergoods.service.SellerService"/>

    <!--认证类-->
    <beans:bean id="userDetailsService" class="com.pinyougou.service.UserDetailsServiceImpl">
        <beans:property name="sellerService" ref="sellerService"/>
    </beans:bean>


    <!-- 认证管理器，指定了认证需要访问的service即认证类 。使用数据库中的用户名和密码。-->
    <authentication-manager>
        <authentication-provider user-service-ref="userDetailsService">
            <!-- 配置加密的方式。若配置此项，则需要指定密码加密方式，否则使用{noop}拼接上密码即可
            <security:password-encoder ref="passwordEncoder"/> -->
        </authentication-provider>
    </authentication-manager>
    <!-- 配置加密类 -->
    <beans:bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/>
</beans:beans>
```

Bcrypt加密（详细看SSM笔记）：只需配置好，然后注册时加密即可，解密会由框架自动进行对比





# 5 商品管理-商品录入-1

## 5.1 商品分类管理

### 5.1.1 商品分类展示及面包屑

> 利用tb_item_cat表的parent_id（为0是最顶级），从而实现**三级商品**分类列表查询功能，更新**面包屑导航**

后端：interface和service以及controller的`ItemCat*`添加根据parentId查找的方法，可以不用分页（一级商品类别比较少）

```java
@Override
public List<TbItemCat> findByParentId(Long parentId) {
    TbItemCatExample example = new TbItemCatExample();
    Criteria criteria = example.createCriteria();
    criteria.andParentIdEqualTo(parentId);
    return itemCatMapper.selectByExample(example);
}
```

```java
@RequestMapping("/findByParentId")
public List<TbItemCat> findByParentId(Long parentId){
    return itemCatService.findByParentId(parentId);
}
```

前端：（引入js）

```js
this.findByParentId=function(parentId){
    return $http.get('../itemCat/findByParentId.do?parentId='+parentId);
}
```

```js
//为区分面包屑等级设置的变量
$scope.grade = 1;
$scope.setGrade = function(number){
    $scope.grade = number;
}

//点击面包屑或查看下一级时触发的方法。由于面包屑要展示name所以封装在entity实体中
$scope.selectList = function (entity) {
    if ($scope.grade == 1){ //1级时2、3级entity都为null
        $scope.entity_2 = null;
        $scope.entity_3 = null;
    } else if ($scope.grade == 2){ //2级时2级entity有值，3级entity为null
        $scope.entity_2 = entity;
        $scope.entity_3 = null;
    } else if ($scope.grade == 3){ //3级时3级entity有值，其他不变
        $scope.entity_3 = entity;
    }
    $scope.findByParentId(entity.id); //查找数据list
}

$scope.findByParentId = function (parentId) {
    $scope.entity.parentId = parentId;//增加时需要
    itemCatService.findByParentId(parentId).success(
        function (data) {
            $scope.list = data;
        }
    )
}
```

```html
<body ng-app="pinyougou" ng-controller="itemCatController" ng-init="findByParentId(0)">
    <!--面包屑-->
    <a href="#" ng-click="setGrade(1); selectList({id:0})" >顶级分类列表</a> <!--传入实体可以这样写-->
    <a href="#" ng-click="setGrade(2); selectList(entity_2)">{{entity_2.name}}</a>
    <a href="#" ng-click="setGrade(3) ;selectList(entity_3)">{{entity_3.name}}</a>
    ......

    <tr ng-repeat="entity in list">
        <td><input  type="checkbox" ></td>			                              
        <td>{{entity.id}}</td>
        <td>{{entity.name}}</td>
        <td>{{entity.typeId}}</td>		
        <!--ng-if指令的使用-->
        <td><button ng-if="grade!=3" ng-click="setGrade(grade+1); selectList(entity)">查询下级</button></td>
    </tr>
</body>
```



### 5.1.2 新增商品分类

后端：由于有类型模板需要select2（格式需要），所以给interface、service、dao、controller增加方法，查找模板类型表。封装数据到`List<Map>`中，请求URL为`/itemCat/selectOptionList.do`

```java
List<Map> selectOptionList();
```

```xml
<select id="selectOptionList" resultType="java.util.Map">
    select id id,id text from tb_type_template
</select>
```

```java
@RequestMapping("selectOptionList")
public List<Map> selectOptionList(){
    List<Map> list = itemCatService.selectOptionList();
    for (Map map : list) {
        map.put("text",map.get("text").toString());//修改text属性值为字符串类型
    }
    return list;
}
```

前端：select2和前面的品牌下拉列表一致。但是若出现`a.toUpperCase is not a function`问题，是由于select2要求的text属性值是**字符串**，而从数据库中查询的值是bigint型，需要在后端修改下（如上面controller，前端也行）。

* 新增加时由于需要parentId，所以service、controller中修改后如下

  ```js
  //根据父id查找其子内容
  this.findByParentId=function(parentId){
      return $http.get('../itemCat/findByParentId.do?parentId='+parentId);
  }
  //下拉列表查询
  this.selectOptionList = function () {
      return $http.get('../itemCat/selectOptionList.do');
  }
  ```

  ```js
  $scope.entity = {};
  $scope.findByParentId = function (parentId) {
      $scope.entity.parentId = parentId; //增加时需要parentId，所以在每次点击面包屑、查看下一级都设置好parentId
      itemCatService.findByParentId(parentId).success(
          function (data) {
              $scope.list = data;
          }
      )
  }
  
  //下拉列表
  $scope.typeList = {data:[]};
  $scope.selectOptionList = function () {
      itemCatService.selectOptionList().success(
          function (date) {
              $scope.typeList = {data:date};
          }
      )
  }
  ```

* HTML中绑定数据：下拉列表绑定数据需要`ng-model`而不是它自带的，因为它会按它的格式提交

  ```html
  <tr>
      <td>上级商品分类</td>
      <td>{{entity_2.name}}<span ng-if="entity_2!=null && entity_3!=null"> >> </span>{{entity_3.name}}</td>
  </tr>
  <tr>
      <td>商品分类名称</td>
      <td><input ng-model="entity.name" class="form-control" placeholder="商品分类名称">  </td>
  </tr>			  
  <tr>
      <td>类型模板</td>
      <td><input select2 ng-model="entity.typeId" config="typeList"  placeholder="商品类型模板" class="form-control" type="text"/></td>		      		      		
  </tr>	
  <button class="btn btn-success" data-dismiss="modal" aria-hidden="true" ng-click="save()">保存</button>
  ```

  ```js
  $scope.findByParentId($scope.entity.parentId);//保存成功后不再是调用之前的方法刷新列表，而是调用这个方法
  ```

* 每次点击新增按钮应该把上次数据清空，新增按钮绑定`ng-click="entity={}"`即可



### 5.1.3 修改商品分类

所有代码都自动生成，修改的页面和新增页面公用，只需添加一句

```html
<button type="button" ng-click="findOne(entity.id)" >修改</button>
```



### 5.1.4 删除商品分类

前端和品牌管理一样：checkbox中`ng-click="updateSelection($event,entity.id)`，删除按钮`ng-click="dele()"`

`dele()`方法的更新列表语句改为：

```js
$scope.findByParentId($scope.entity.parentId);//删除成功后不再是调用之前的方法刷新列表，而是调用这个方法
```

后端：需要判断是否还有子级别，有则不能删除，否则可以删除。可以在service中判断

```java
@Override
public void delete(Long[] ids) {
    for (Long id : ids) {
        TbItemCatExample example = new TbItemCatExample();
        Criteria criteria = example.createCriteria();
        criteria.andParentIdEqualTo(id);
        List<TbItemCat> tbItemCats = itemCatMapper.selectByExample(example);
        if (tbItemCats.size()==0){ //没有子级别才可以删除
            itemCatMapper.deleteByPrimaryKey(id);
        }
    }
}
```





## 5.2 电商SPU与SKU-表结构分析

* **SPU = Standard Product Unit （标准产品单位）**

  SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。

  通俗点讲，属性值、特性相同的商品就可以称为一个SPU。如iPhone8就是一个SPU，与商家，与颜色、款式、套餐都无关

* **SKU=stock keeping unit（库存量单位）**

  SKU是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最普遍

  例如：纺织品中一个SKU通常表示：规格、颜色、款式

* 表结构分析

  tb_goods表（SPU）、tb_goods_desc表（前面表的详细信息）、tb_item表（SKU，从表）



## 5.3 商家后台-商品录入【基本功能】

> 商品录入所有功能设计三张表：、tb_goods、tb_goods_desc、tb_item

后端：

在商家后台实现商品录入功能。包括tb_goods：**商品名称**、**副标题**、**价格**；tb_goods_desc：**包装列表**、**售后服务**。由于tb_goods_desc表需要tb_goods的**id**，所以需要**修改mapper.xml**。并且这是两张表的数据，需要定义一个**组合实体类**。

```xml
<selectKey resultType="java.lang.Long" order="AFTER" keyProperty="id">
    SELECT LAST_INSERT_ID() AS id
</selectKey>
```

```java
public class Goods implements Serializable {

    private TbGoods goods; //商品SPU基本信息
    private TbGoodsDesc goodsDesc; //商品扩展信息
    private List<TbItem> itemList; //SKU列表，暂时不用
}
```

interface中add方法修改传入参数为Goods组合实体类，service中需要修改逻辑

```java
@Override
public void add(Goods goods) {
    goods.getGoods().setAuditStatus("0"); //新增加的商品状态为未审核
    goodsMapper.insert(goods.getGoods()); //插入商品基本信息

    goods.getGoodsDesc().setGoodsId(goods.getGoods().getId()); //将商品基本表的id给扩展表 
    goodsDescMapper.insert(goods.getGoodsDesc()); //插入商品扩展信息
}
```

**pinyougou-manager-web中其实没有商品录入功能**，删除生成的代码。修改**pinyougou-shop-web中controller的add方法**

需要录入商品**同时录入商家的id**，利用SpringSecurity的方法

```java
@RequestMapping("/add")
public Result add(@RequestBody Goods goods){
    //获取商家id并设置
    String sellerId = SecurityContextHolder.getContext().getAuthentication().getName();
    goods.getGoods().setSellerId(sellerId);
    try {
        goodsService.add(goods);
        return new Result(true, "增加成功");
    } catch (Exception e) {
        e.printStackTrace();
        return new Result(false, "增加失败");
    }
}
```



前端：

service使用生成的代码，controller中由于不需要修改，可以修改为

```js
//增加商品
$scope.add=function(){
    goodsService.add( $scope.entity  ).success(
        function(response){
            if(response.success){
                alert("新增商品成功");
                $scope.entity = {};//清空上次数据的数据即可，不用刷新列表，因为这就是一个新增页面
            }else{
                alert(response.message);
            }
        }		
    );				
}
```

HTML中引入JS、绑定ng-app和ng-controller、绑定数据（注意实体类中属性与前端变量名的一致性）、绑定保存按钮

```html
<input type="text" ng-model="entity.goods.goodsName"   placeholder="商品名称" value="">
<input type="text" ng-model="entity.goods.caption"   placeholder="副标题" value="">
<input type="text" ng-model="entity.goods.price"   placeholder="价格" value="">
<textarea rows="4" ng-model="entity.goodsDesc.packageList"   placeholder="包装列表"></textarea>
<textarea rows="4" ng-model="entity.goodsDesc.saleService"   placeholder="售后服务"></textarea>

<button class="btn btn-primary" ng-click="add()"><i class="fa fa-save" ></i>保存</button>
```



## 5.4 商家后台-商品录入【商品介绍】

> 富文本编辑器，Rich Text Editor, 简称 RTE, 它提供类似于 Microsoft Word 的编辑功能

[KindEditor](http://kindeditor.net/)（国内。此次使用。查看前端相关，其实是HTML代码）、[UEditor](http://ueditor.baidu.com/website/)（百度）、[CKEditor](http://ckeditor.com/)（国外）

引入JS

```html
<link rel="stylesheet" href="../plugins/kindeditor/themes/default/default.css" />
<script charset="utf-8" src="../plugins/kindeditor/kindeditor-min.js"></script>
<script charset="utf-8" src="../plugins/kindeditor/lang/zh_CN.js"></script>
```

渲染textarea（查看文档怎么写即可）

```js
var editor;
KindEditor.ready(function(K) {
    editor = K.create('textarea[name="content"]', {
        allowFileManager : true
    });
});
```

html中textarea：`name="content"`必须是这个值

```html
<textarea name="content" style="width:800px;height:400px;visibility:hidden;" ></textarea>
```

它的数据绑定必须使用JS代码完成。在controller中add中增加数据绑定、清空的代码：

```js
//增加商品
$scope.add=function(){
    $scope.entity.goodsDesc.introduction = editor.html();//绑定富文本编辑器的数据
    goodsService.add( $scope.entity  ).success(
        function(response){
            if(response.success){
                alert("新增商品成功");
                $scope.entity = {};//清空上次填写的基本数据即可，不用刷新列表，因为这就是一个新增页面
                editor.html("");//清空富文本编辑器的数据
            }else{
                alert(response.message);
            }
        }		
    );				
};
```



## 5.5 分布式文件服务器FastDFS

> c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。

![](images/FastDFS架构.png)

FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过Tracker server 调度最终由 Storage server 完成文件上传和下载。

* Tracker：管理集群，Tracker也可以实现集群。每个 Tracker节点地位平等。收集 Storage 集群的状态。
* Storage：实际保存文件。Storage分为多个组（卷），每个组（卷）之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。·

文件上传流程：

![](images/文件上传流程.png)

客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。如下：

![1547316493727](images/1547316493727.png)

组名：文件上传后所在的 storage 组名称，在文件上传成功后有 storage 服务器返回，需要客户端自行保存

虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项 store_path*对应。如果配置了store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推

数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件

文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息



文件下载流程：

![](images/文件下载流程.png)

最简单的 FastDFS 架构：6个服务器，其中2个Tracker、2个卷，每个卷中有2个Storager

FastDFS 安装步骤非常繁琐，直接使用安装好的镜像！

由于FastDFS客户端jar包并没有在中央仓库中，需要自己安装到本地仓库

```shell
mvn install:install-file -DgroupId=org.csource.fastdfs -DartifactId=fastdfs  -Dversion=1.2 -Dpackaging=jar -Dfile=d:\setup\fastdfs_client_v1.20.jar
```

`pom.xml`中引入依赖

```xml
<dependency>
    <groupId>org.csource.fastdfs</groupId>
    <artifactId>fastdfs</artifactId>
    <version>1.2</version>
</dependency>
```

添加配置文件`fdfs_client.conf`，以后只需修改服务器地址如`tracker_server=192.168.25.133:22122`

```java
public class Test {

    public static void main(String[] args) throws Exception {
        //1.加载配置文件
        ClientGlobal.init("D:\\Code-Workspace\\IDEA\\fastFDSdemo\\src\\main\\resources\\fdfs_client.conf");
        //2.创建一个TrackerClient对象
        TrackerClient trackerClient = new TrackerClient();
        //3.使用TrackerClient对象创建连接，获得一个TrackerServer对象
        TrackerServer trackerServer = trackerClient.getConnection();
        //4.创建一个StorageServer的引用，值为null
        StorageServer storageServer = null;
        //5.创建一个StorageClient对象，需要两个参数TrackerServer对象、StorageServer的引用
        StorageClient storageClient = new StorageClient(trackerServer,storageServer);
        //6.使用 StorageClient 对象上传图片。扩展名不带“.”。最后一个参数为文件的详细信息
        String[] fileId = storageClient.upload_file("F:\\_H\\other\\dog.jpg", "jpg", null);
        //7.返回数组。包含组名和图片的路径
        for (String s : fileId) {
            System.out.println(s);
        }
        //访问http://192.168.25.133/group1/M00/00/00/wKgZhVw6OJKAf89UAAGgU0NHZ6E797.jpg
    }
}
```



## 5.6 商家后台-商品录入【商品图片上传】

后端：

由于这个功能与业务无关，是通用的。所以在pinyougou-common中的``pom.xml`中引入依赖。将工具类也放入其中。

```xml
<!-- 文件上传组件 -->
<dependency>
    <groupId>org.csource.fastdfs</groupId>
    <artifactId>fastdfs</artifactId>
</dependency>
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
</dependency>
```

在pinyougou-shop-web引入pinyougou-common

将`fdfs_client.conf`拷贝到pinyougou-shop-web工程config文件夹

pinyougou-shop-web工程`application.properties`添加配置：`FILE_SERVER_URL=http://192.168.25.133/`

pinyougou-shop-web工程`springmvc.xml`添加配置：

```xml
<!-- 配置多媒体解析器 -->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <property name="defaultEncoding" value="UTF-8"></property>
    <!-- 设定文件上传的最大值5MB，5*1024*1024 -->
    <property name="maxUploadSize" value="5242880"></property>
</bean>
```

Controller层代码的编写（不需要service、dao）

```java
@RestController
public class UploadController {

    @Value("${FILE_SERVER_URL}")
    private String file_server_url;

    @RequestMapping("/upload")
    public Result upload(MultipartFile file){
        String originalFilename = file.getOriginalFilename(); //获取文件名
        String extName = originalFilename.substring(originalFilename.lastIndexOf(".") + 1);//获取扩展名
        try {
            FastDFSClient fastDFSClient = new FastDFSClient("classpath:config/fdfs_client.conf");
            String fileId = fastDFSClient.uploadFile(file.getBytes(), extName);
            String url = file_server_url+fileId;//图片的完整url
            return new Result(true,url);
        } catch (Exception e) {
            e.printStackTrace();
            return new Result(false,"上传失败");
        }
    }
}
```



前端：

`uploadService.js`

```js
app.service("uploadService", function ($http) {
    //上传文件
    this.uploadFile = function () {
        var formData = new FormData();//HTML5新增的类，对文件的封装，用于文件上传
        formData.append('file', file.files[0]);//第二个参数中file：文件上传框的id或name的值
        return $http({
            url: '../upload.do',
            method: 'post',
            data: formData,
            //anjularjs对于post和get请求默认的Content-Type header 是application/json。这样设置后浏览器会帮我们把Content-Type 设置为 multipart/form-data
            headers: {'Content-Type': undefined}, 
            //anjularjs transformRequest function 将序列化我们的formdata object
            transformRequest: angular.identity
        })
    }
});
```

将uploadService服务注入到goodsController中

```js
$scope.uploadFile = function () {
    uploadService.uploadFile().success(function (data) {
        if (data.success) {
            $scope.image_entity.url = data.message; //绑定url，用于保存时提及
        } else {
            alert(data.message);
        }
    }).error(function () {
        alert("上传发生错误");
    })
}
```

在html中引入`uploadService.js`，绑定数据。在新建按钮时绑定`ng-click="image_entity={}"`清空上次数据

```html
<input ng-model="image_entity.color" class="form-control" placeholder="颜色" >

<input type="file" id="file" />
<button class="btn btn-primary" type="button" ng-click="uploadFile()">上传</button>	
<img  src="{{image_entity.url}}" width="200px" height="200px"><!--上传后直接显示-->

```

此时只是在弹出的上传图片对话框中，上传了图片到FastDFS服务器，并显示出。但并没有将数据保存到数据库



**图片列表**：上传图片对话框中点击保存后，显示图片记录。只是展示了上传的图片列表，并没有将数据保存到数据库

```html
<button class="btn btn-success"  data-dismiss="modal" aria-hidden="true" ng-click="add_image_entity()">保存</button>
```

```js
$scope.entity = {goods: {}, goodsDesc: {itemImages: []}}; //封装所有要上传的数据（暂时设计两张表）

//上传图片对话框点击保存后--图片展示列表
$scope.add_image_entity = function () {
    $scope.entity.goodsDesc.itemImages.push($scope.image_entity);
};
//图片展示列表中删除图片时
$scope.remove_image_entity = function (index) {
    $scope.entity.goodsDesc.itemImages.splice(index,1);
}
```

```html
<tr ng-repeat="x in entity.goodsDesc.itemImages">
    <td>{{x.color}}</td>
    <td><img alt="" src="{{x.url}}" width="100px" height="100px"></td>
    <td> <button type="button"  ng-click="remove_image_entity($index)" title="删除" >删除</button></td>
</tr>
```



**点击最下面的保存按钮即可保存所有数据到数据库**

但是这个系统不能删除FastDFS服务器中图片，只能删除数据库中存储的url。（可以在其他时间统一检查垃圾文件并删除）





# 6 商品管理-商品录入-2

## 6.1 商家后台-商品录入【选择商品分类】

在pinyougou-shop-web工程中创建itemCatService.js，在goodsController.js中引入itemCatService并在goods_edit.html添加引用。后端代码直接使用已存在的ItemCatController/Service即可。这次使用AngularJS自带select（select2也可以实现）

`goodsController.js`

```js
//itemCatService.findByParentId()查找的是tb_item_cat表，返回id、parentId、name、typeId
//查询一级商品分类列表
$scope.selectItemCat1List = function () {
    itemCatService.findByParentId(0).success(function (data) {
        $scope.itemCat1List = data; //一级商品分类列表
    })
};

//查询二级商品分类列表
//利用AngularJS的变量监控方法（不同于JS、jQuery的事件驱动）。newValue为改变后的值，oldValue为改变前的值
$scope.$watch("entity.goods.category1Id", function (newValue, oldValue) {
    itemCatService.findByParentId(newValue).success(function (data) {
        $scope.itemCat2List = data; //二级商品分类列表
    })

});

//查询三级商品分类列表。同上
$scope.$watch("entity.goods.category2Id", function (newValue, oldValue) {
    itemCatService.findByParentId(newValue).success(function (data) {
        $scope.itemCat3List = data; //三级商品分类列表
    })
});

//查询模板ID。同上
$scope.$watch("entity.goods.category3Id", function (newValue, oldValue) {
    itemCatService.findOne(newValue).success(function (data) {
        $scope.entity.goods.typeTemplateId = data.typeId;

    })
});
```

HTML中调用`ng-init="selectItemCat1List()"`，数据绑定及select级联列表

```html
<td>
    <select ng-model="entity.goods.category1Id" ng-options="item.id as item.name for item in itemCat1List">	
    </select>
</td>
<td>
    <select ng-model="entity.goods.category2Id" ng-options="item.id as item.name for item in itemCat2List">	
    </select>
</td>
<td>
    <select ng-model="entity.goods.category3Id" ng-options="item.id as item.name for item in itemCat3List">
    </select>
</td>

<td><span ng-if="entity.goods.typeTemplateId!=null">模板ID：{{entity.goods.typeTemplateId}}</span></td>
```



## 6.2 商家后台-商品录入【品牌下拉列表】

需要从tb_type_template查询到JSON字符串数据，转为JSON对象后展示为下拉列表

需要TypeTemplateController，typeTemplateService.js并在goodsController.js中引入该服务，HTML中也需引入js文件

`goodsController.js`

```js
//查询商品下拉列表；扩展属性；规格列表。监控模板ID。从tb_type_template表中查询
$scope.$watch("entity.goods.typeTemplateId", function (newValue, oldValue) {
    typeTemplateService.findOne(newValue).success(function (data) {
        $scope.entity.goods.brandIds = JSON.parse(data.brandIds);//品牌列表类型转换

        $scope.entity.goodsDesc.customAttributeItems = JSON.parse(data.customAttributeItems);//扩展属性
    })
    //规格及选项
    typeTemplateService.findSpecList(id).success(function (data) {
        $scope.specList = data;
    })
});
```

HTML中数据绑定，下拉列表及扩展属性

```html
<select ng-model="entity.goods.brandId" ng-options="item.id as item.text for item in entity.goods.brandId"></select>
```

```html
<div ng-repeat="x in entity.goodsDesc.customAttributeItems">
    <div>{{x.text}}</div>
    <div><input class="form-control" placeholder="{{x.text}}" ng-model="x.value"></div>
</div>
```





## 6.3 商家后台-商品录入【扩展属性】

> 表中表可以用JSON存储

从tb_type_template表获取扩展属性展示，保存到tb_goods_desc表的custom_attribute_items中

修改6.2的代码即可使用，查看上面代码。



## 6.4 商家后台-商品录入【规格选择】

后端：

由于`tb_type_template`表中查找出来的数据只有规格，没有规格选项，所以需要改后端代码，给原有内容添加规格选项。

`TypeTemplateServiceImpl`

```java
@Override
public List<Map> findSpecList(Long id) {
    //从tb_type_template表中查spec_ids字段的JSON内容
    TbTypeTemplate typeTemplate = typeTemplateMapper.selectByPrimaryKey(id);
    //将[{"id":27,"text":"网络"},{"id":32,"text":"机身内存"}]字符串转为集合
    List<Map> list = JSON.parseArray(typeTemplate.getSpecIds(), Map.class);
    for (Map map : list) {
        //从tb_specification_option表中根据spec_id字段查找List集合，封装到Map中options
        TbSpecificationOptionExample example = new TbSpecificationOptionExample();
        TbSpecificationOptionExample.Criteria criteria = example.createCriteria();
        criteria.andSpecIdEqualTo(new Long((Integer) map.get("id")));//包装类型间转换需要new对象
        List<TbSpecificationOption> specificationOptions = specificationOptionMapper.selectByExample(example);
        map.put("options",specificationOptions);
    }
    //返回的是这个类型数据[{"id":27,"text":"网络",options:[{},{}]},{"id":32,"text":"机身内存"},options:[{},{}]]
    return list;
}
```

`TypeTemplateController`

```java
@RequestMapping("/findSpecList")
public List<Map> findSpecList(Long id){
    return typeTemplateService.findSpecList(id);
}
```



前端：

`typeTemplateService.js`

```js
this.findSpecList = function (id) {
    return $http.get('../typeTemplate/findSpecList.do?id='+id);
}
```

规格选项是在商品分类选择完成，所以还是放在监控模板id变换的方法内

```js
//查询商品下拉列表；扩展属性；规格列表。监控模板ID。从tb_type_template表中查询
$scope.$watch("entity.goods.typeTemplateId", function (newValue, oldValue) {

    typeTemplateService.findOne(newValue).success(function (data) {
        
        $scope.entity.goods.brandIds = JSON.parse(data.brandIds);//品牌列表类型转换

        $scope.entity.goodsDesc.customAttributeItems = JSON.parse(data.customAttributeItems);//扩展属性
    });
    
    //规格及选项
    typeTemplateService.findSpecList(newValue).success(function (data) {
        $scope.specList = data;
    });
});
```

HTML中遍历数据

```html
<div ng-repeat="x in specList">
    <div class="col-md-2 title">{{x.text}}</div>
    <div class="col-md-10 data">
        <span ng-repeat="y in x.options">
            <input ng-click="updateSpecAttribute($event,x.text,y.optionName)" type="checkbox" >{{y.optionName}}
        </span>
    </div>
</div>
```



**保存规格**

封装数据格式为：`[{"attributeName":"网络制式","attributeValue":["移动3G","移动4G"]}]`

当点击CheckBox时有两种情况：1、该attributeName不存在，直接添加；2、该attributeName存在，返回该对象。由于这个方法比较通用，所以封装在`baseController.js`中

`baseController.js`

```js
//例如[{"attributeName":"网络制式","attributeValue":["移动3G","移动4G"]}]
//array集合，key为每个对象中的属性，value为所需要的属性值
$scope.searchObjectByKey = function (array,key,value) {
    for (let i=0;i<array.length;i++){
        if ( array[i][key] == value ){
            return array[i]; //返回该对象
        }
    }
    return null;
}
```

`goodsController.js`

```js
//定义变量，否则不能使用.调用，空指针异常
$scope.entity = {goods: {}, goodsDesc: {itemImages: [], specificationItems: []}}; //封装所有要上传的数据

//例如[{"attributeName":"网络制式","attributeValue":["移动3G","移动4G"]}]
$scope.updateSpecAttribute = function ($event,name,value) {
    //判断是否已存在该属性
    var object = $scope.searchObjectByKey($scope.entity.goodsDesc.specificationItems,'attributeName',name)
    //不存在，直接添加属性名、属性值
    if (object == null){
        $scope.entity.goodsDesc.specificationItems.push({"attributeName":name,"attributeValue":[value]})
    } else {
        //存在并且勾选，则添加
        if ($event.target.checked){
            object.attributeValue.push(value);
        } else {
            //存在但取消勾选，则删除该记录
            object.attributeValue.splice(object.attributeValue.indexOf(value),1);
            //若该属性值为空，则删除该属性（这句话可以不加）
            if (object.attributeValue.length==0){
                $scope.entity.goodsDesc.specificationItems.splice($scope.entity.goodsDesc.specificationItems.indexOf(object),1);
            }
        }
    }
}
```

HTML数据绑定看上面的！



## 6.5 商家后台-商品录入【SKU商品信息】

规格选择后，类似笛卡尔积。提交数据到`tb_item`表中

前端的克隆：

* 浅克隆：类似引用
* 深克隆：类似双胞胎。利用JSON中方法`var b = JSON.parse(JSON.stringify(a))`，即转为JSON转字符串再转JSON

`goodsController.js`

![1547832054339](images/1547832054339.png)

```js
$scope.createItemList = function () {
    //后端pojo中Goods组合实体类中第三个属性itemList
    $scope.entity.itemList = [{spec:{},price:0,num:99999,status:'0',isDefault:'0'}];//列表初始化

    //例如[{"attributeName":"网络制式","attributeValue":["移动3G","移动4G"]}]
    var items = $scope.entity.goodsDesc.specificationItems;//用户选择的规格集合
    for (let i = 0; i < items.length; i++) {
        $scope.entity.itemList = addColumn($scope.entity.itemList,items[i].attributeName,items[i].attributeValue);
    }
};

//在外部定义方法，可以不添加$scope，但不在页面调用
addColumn = function (list, columnName, columnValues) {
    var newList = [];
    for (let i = 0; i < list.length; i++) { //循环传入的list
        var oldRow = list[i];

        for (let j = 0; j < columnValues.length; j++) { //循环columnValues
            var newRow = JSON.parse(JSON.stringify(oldRow)); //深克隆
            newRow.spec[columnName] = columnValues[j];
            newList.push(newRow);//每个SKU中spec类似：{"网络":"移动2G","机身内存":"32G"}
        }
    }
    return newList;
}
```

在规格选择CheckBox添加方法调用

```js
<input ng-click="updateSpecAttribute($event,x.text,y.optionName);createItemList()" type="checkbox" >{{y.optionName}}
```

HTML数据绑定

```html
<tr>
    <th  ng-repeat="x in entity.goodsDesc.specificationItems" class="sorting">{{x.attributeName}}</th>
    <th class="sorting">价格</th>
    <th class="sorting">库存</th>
    <th class="sorting">是否启用</th>
    <th class="sorting">是否默认</th>
</tr>

<tr ng-repeat="x in entity.itemList">
    <td ng-repeat="y in entity.goodsDesc.specificationItems">{{x.spec[y.attributeName]}}</td>
    <td><input ng-model="x.price" class="form-control"  placeholder="价格"></td>
    <td><input ng-model="x.num" class="form-control" placeholder="库存数量"></td>
    <td><input ng-model="x.status" ng-true-value="1" ng-false-value="0" type="checkbox" ></td>
    <td><input ng-model="x.isDefault" ng-true-value="1" ng-false-value="0" type="checkbox" ></td>
</tr>
```



后端：

`GoodsServiceImpl`，查看下面的





**是否启用规格**

`goods_edit.html`数据绑定，及显示、隐藏下面的选项

```html
<input type="checkbox" ng-model="entity.goods.isEnableSpec" ng-true-value="1" ng-false-value="0">
<!--显示、隐藏-->
<div ng-if="entity.goods.isEnableSpec==1"></div>
```

`GoodsServiceImpl`

```java
@Override
public void add(Goods goods) {
    //对象前端的数据进行封装，并设置需要的其他属性
    goods.getGoods().setAuditStatus("0"); //新增加的商品状态为未审核
    goodsMapper.insert(goods.getGoods()); //插入商品基本信息

    goods.getGoodsDesc().setGoodsId(goods.getGoods().getId()); //将商品基本表的id给扩展表
    goodsDescMapper.insert(goods.getGoodsDesc()); //插入商品扩展信息

    saveItemList(goods);//插入SKU列表数据（需要判断）
}

private void saveItemList(Goods goods){
    if ("1".equals(goods.getGoods().getIsEnableSpec())) { //启用规格

        for (TbItem item : goods.getItemList()) {
            //构建标题：SPU名称+规格选项值
            String title = goods.getGoods().getGoodsName();
            Map<String, Object> map = JSON.parseObject(item.getSpec());
            Set<Map.Entry<String, Object>> entries = map.entrySet();
            for (Map.Entry<String, Object> entry : entries) {
                title += " " + entry.getKey();
            }
            item.setTitle(title);
            setItemValues(item, goods); //设置其他属性

            itemMapper.insert(item);
        }
    } else { //没有启用规格
        TbItem item = new TbItem();
        item.setTitle(goods.getGoods().getGoodsName());//标题
        item.setPrice(goods.getGoods().getPrice());//价格
        item.setNum(99999);//库存
        item.setStatus("1");//状态
        item.setIsDefault("1");//是否为默认
        setItemValues(item, goods);//设置其他属性
        item.setSpec("{}");//设置规格为{}，以便数据库中显示不是null
        itemMapper.insert(item);
    }
}

private void setItemValues(TbItem item, Goods goods) {
    item.setCategoryid(goods.getGoods().getCategory3Id());//商品的分类（三级）
    item.setCreateTime(new Date());//创建日期
    item.setUpdateTime(new Date());//更改日期
    item.setGoodsId(goods.getGoods().getId());//商品id
    item.setSellerId(goods.getGoods().getSellerId());//商家id

    TbItemCat tbItemCat = itemCatMapper.selectByPrimaryKey(goods.getGoods().getCategory3Id());
    item.setCategory(tbItemCat.getName());//分类名称（为搜索）

    TbBrand tbBrand = brandMapper.selectByPrimaryKey(goods.getGoods().getBrandId());
    item.setBrand(tbBrand.getName());//品牌名称（为搜索）

    TbSeller tbSeller = sellerMapper.selectByPrimaryKey(goods.getGoods().getSellerId());
    item.setSeller(tbSeller.getName());//商家店铺名称（为搜索）

    List<Map> imageList = JSON.parseArray(goods.getGoodsDesc().getItemImages(), Map.class);
    if (imageList.size() > 0) {
        item.setImage((String) imageList.get(0).get("url"));//第一个图片URl
    }
}
```





# 7 商品修改与审核

## 7.1 商家后台-商品管理【商品列表】

后端：

`GoodsController`：前端需要**显示的是登陆商家的商品**，所以需要使用SpringSecurity获取并设置其商家id

```java
@RequestMapping("/search")
public PageInfo search(@RequestBody TbGoods goods, int page, int rows  ){
    //前端需要显示的是登陆商家的商品，所以需要使用SpringSecurity获取并设置其商家id
    String sellerId = SecurityContextHolder.getContext().getAuthentication().getName();
    goods.setSellerId(sellerId);

    return goodsService.findPage(goods, page, rows);		
}
```

`GoodsServiceImpl`中生成代码需要精确查找，修改为`criteria.andSellerIdEqualTo(goods.getSellerId());`



前端：

引入JS、分页控件、绑定`ng-app`等。baseController中分页逻辑会自动调用查找分页方法

HTML中遍历list数据并展示

==**状态显示**==：不能直接展示0、1、2、3，可以在goodsController中定义变量

```js
$scope.status = ['未审核','已审核','审核未通过','已关闭'];
```

```html
<tr ng-repeat="entity in list">
    <td><input  type="checkbox"></td>			                              
    <td>{{entity.id}}</td>
    <td>{{entity.goodsName}}</td>
    <td>{{entity.price}}</td>
    <td>{{itemCatName[entity.category1Id]}}</td>
    <td>{{itemCatName[entity.category2Id]}}</td>
    <td>{{itemCatName[entity.category3Id]}}</td>
    <td>{{status[entity.auditStatus]}}</td>		                                  
    <td class="text-center">                                          
        <a class="btn bg-olive btn-xs" href="goods_edit.html#?id={{entity.id}}">修改</a>               
    </td>
</tr>
```

==**分类名称显示**==：不需要关联查询（效率低），只需页面加载时查询单表并封装到数据。HTML同上，还需在body标签中绑定方法

```js
//查询商品分类名称
$scope.itemCatName = [];
$scope.findItemCatList = function () {
    itemCatService.findAll().success(function (data) {
        for (let i = 0; i < data.length; i++) {
            $scope.itemCatName[data[i].id] = data[i].name;
        }
    })
}
```

==**条件查询**==：数据绑定、reloadList()方法自动调用分页条件查询

```html
状态：<select ng-model="searchEntity.auditStatus">
    <option value="">全部</option>      
    <option value="0">未审核</option>
    <option value="1">已审核</option>
    <option value="2">审核未通过</option>
    <option value="3">已关闭</option>                                     
</select>
商品名称：<input ng-model="searchEntity.goodsName">
<button class="btn btn-default" ng-click="reloadList()">查询</button>
```





## 7.2 商家后台-商品管理【商品修改】

和商品录入页面公用一个HTML页面（之前都是弹出窗口，由于数据少）。需要读取`tb_goods`、`tb_goods_desc`、`tb_item`

### 7.2.1 基本信息读取

商品分类、商品名称、品牌，副标题，价格等信息

interface、service、controller修改返回值为组合实体类Goods，以下是**所有后端代码**，具体实现如下：

```java
@Override
public Goods findOne(Long id) {
    //商品基本表
    TbGoods tbGoods = goodsMapper.selectByPrimaryKey(id);
    //商品扩展表
    TbGoodsDesc tbGoodsDesc = goodsDescMapper.selectByPrimaryKey(id);
    //读取SKU列表
    TbItemExample example = new TbItemExample();
    TbItemExample.Criteria criteria = example.createCriteria();
    criteria.andGoodsIdEqualTo(id);
    List<TbItem> tbItems = itemMapper.selectByExample(example);

    Goods goods = new Goods(tbGoods,tbGoodsDesc,tbItems);
    return goods;
}
```

==**静态页面之间传参**==需要引入**`$location`**服务，利用其**`search()`**方法返回所有参数的数组，并且URL中`?`前需添加`#`

数据绑定在商品录入阶段以及完成，不需要再编写

```js
//查询实体
$scope.findOne = function () {
    let id = $location.search()['id'];
    if (id==null)
        return;
    goodsService.findOne(id).success(
        function (response) {
            $scope.entity = response; //基本信息
            editor.html($scope.entity.goodsDesc.introduction);//富文本编辑器内容
            $scope.entity.goodsDesc.itemImages = JSON.parse($scope.entity.goodsDesc.itemImages);//图片列表
            $scope.entity.goodsDesc.customAttributeItems = JSON.parse($scope.entity.goodsDesc.customAttributeItems)//扩展属性（需要修改监控模板id变化时执行的findOne方法）
            

        }
    );
}
```



### 7.2.2 富文本商品介绍读取

看上面代码



### 7.2.3 显示商品图片列表

由于**JSON字符串未转化为JSON对象**，看上面代码



### 7.2.4 读取商品扩展属性

由于**JSON字符串未转化为JSON对象**，看上面代码

由于在监控模板id变化时有句代码

```js
$scope.entity.goodsDesc.customAttributeItems = JSON.parse(data.customAttributeItems);//扩展属性
```

需要将其修改为

```js
if ($location.search()['id']==null) 
    $scope.entity.goodsDesc.customAttributeItems = JSON.parse(data.customAttributeItems);//扩展属性
```



### 7.2.5 读取商品规格属性

需要使用**AngularJS的指令`ng-checked`**，根据返回值true/false来决定CheckBox的勾选与否

HTML绑定

```html
<input ng-checked="checkAttributeValue()" 
       ng-click="updateSpecAttribute($event,x.text,y.optionName);createItemList()" 
       type="checkbox" >{{y.optionName}}
```

`goodsController.js`中需要根据规格名称、规格选项来和从后端得到的规格列表中的值对比。利用封装的`searchObjectByKey`

```js
//判断规格与规格选项是否应该被勾选
$scope.checkAttributeValue = function (specName, optionName) {
    let items = $scope.entity.goodsDesc.specificationItems;
    let object = $scope.searchObjectByKey(items, 'attributeName', specName);
    if (object != null) {
        if (object.attributeValue.indexOf(optionName) >= 0) { //能查到规格选项
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}
```



### 7.2.6 读取SKU数据

由于**JSON字符串未转化为JSON对象**，由于itemList是数组（其中有spec属性），看上面代码



### 7.2.7 保存数据

修改后端update方法，传入的对象应为包装类Goods。利用==**先删除、后插入**==的方法来实现。

还需要==**判断传入的这个商品是不是登陆商家的、判断数据库中该商品是否是登陆商家的**==

`GoodsServiceImpl`

```java
@Override
public void update(Goods goods) {

    goodsMapper.updateByPrimaryKey(goods.getGoods());//更新基本表数据
    goodsDescMapper.updateByPrimaryKey(goods.getGoodsDesc());//更新扩展表数据

    //删除原有SKU列表数据
    TbItemExample example = new TbItemExample();
    TbItemExample.Criteria criteria = example.createCriteria();
    criteria.andGoodsIdEqualTo(goods.getGoods().getId());
    itemMapper.deleteByExample(example);
    //插入新SKU列表数据（利用添加SKU商品信息时封装的代码）
    saveItemList(goods);
}
```

`GoodsController`

```java
@RequestMapping("/update")
public Result update(@RequestBody Goods goods) {
    String sellerId = SecurityContextHolder.getContext().getAuthentication().getName();
    Goods goods1 = goodsService.findOne(goods.getGoods().getId());
    //判断传入的这个商品是不是登陆商家的、判断数据库中该商品是否是登陆商家的。我认为只需要数据库中的
    if (goods.getGoods().getSellerId().equals(sellerId) && goods1.getGoods().getSellerId().equals(sellerId)) {
        try {
            goodsService.update(goods);
            return new Result(true, "修改成功");
        } catch (Exception e) {
            e.printStackTrace();
            return new Result(false, "修改失败");
        }
    } else {
        return new Result(false, "非法操作");
    }
}
```



前端：

整合add方法到save方法中

```js
//增加商品
$scope.save = function () {
    $scope.entity.goodsDesc.introduction = editor.html();//绑定富文本编辑器的数据
    let serviceObject;
    if ($scope.entity.goods.id!=null){ //有id
        serviceObject=goodsService.update($scope.entity);
    } else { //没有id
        serviceObject=goodsService.add($scope.entity);
    }
    serviceObject.success(
        function (response) {
            if (response.success) {
                location.href = 'goods.html'; //下面的不需要
                //alert("保存成功");
                //$scope.entity = {};//清空上次填写的基本数据即可，不用刷新列表，因为这就是一个新增页面
                //editor.html("");//清空富文本编辑器的数据
            } else {
                alert(response.message);
            }
        }
    );
};
```



### 7.2.8 页面跳转

点击修改按钮，跳转至修改页面。修改生成的HTML页面的button为a标签，href属性设置即可。查看7.1中代码。

返回列表也可以修改为a标签。

新建按钮也可以跳转至`goods_edit.html`





## 7.3 运营商后台-商品管理【商品审核】

### 7.3.1 待审核商品列表

需要商家后台中前端的状态展示、分类名称展示的controller代码，引入服务、js等等。参照上面的代码

只需要未审核的，在body的`ng-init`添加`searchEntity={auditStatus:'0'}`即可



### 7.3.2 待审核商品详情展示

查看商家后台代码



### 7.3.3 商品审核与驳回

修改状态



## 7.4 运营商后台-商品管理【商品删除】

> 我们为商品管理提供商品删除功能，用户选中部分商品，点击删除按钮即可实现商品删除。注意，这里的删除并非是物理删除，而是修改tb_goods表的is_delete字段为1 ，我们可以称之为“==**逻辑删除**==”

后端

```java
@Override
public void delete(Long[] ids) {
    for (Long id : ids) {
        TbGoods tbGoods = goodsMapper.selectByPrimaryKey(id);
        tbGoods.setIsDelete("1");
        goodsMapper.updateByPrimaryKey(tbGoods);
    }
}
```

还需在后端过滤“被删除的资源”，即在**==查询时过滤掉==**

```java
criteria.andIsDeleteIsNull();//指定条件为未删除，删除的都变为1了
```



前端：绑定`ng-click=dele()`即可



## 7.5 商家后台-【商品上下架】

> 不同于审核状态。审核状态的控制权在运营商手中，而上下架的控制权在商户手中。商户可以随时将一个已审核状态的商品上架或下架。上架表示正常销售，而下架则表示暂停销售。

tb_goods表的is_marketable字段。1表示上架（增加商品默认值）、0表示下架。和商品逻辑删除类似，但不用查询时过滤





## 7.6 注解式事务配置

导入配置文件到service，**`@Transactional`**即可





# 8 广告管理与缓存 SpringDataRedis

> 广告管理涉及的表有：tb_content_category 广告分类表、tb_content 广告表
>
> 代码生成器生成代码，拷贝所需要的配置文件及代码（前端代码根据bash.js进行相应修改），修改dubbox端口、服务端口
>
> 构建工程
>
> - 新建pinyougou-content-interface模块
> - 新建pinyougou-content-service模块
> - pinyougou-manager-web 工程引入依赖 pinyougou-content-interface



## 8.1 运营商后台-广告类型及广告管理

> 广告类型管理：简单的CRUD，略

广告管理（增加具体的广告）：涉及内容类目ID、内容标题、链接、图片路径、状态、排序

* 广告图片上传：查看图片上传代码，略

* 广告类目选择：下拉列表查询数据（不能分页，需findAll。使用原生下拉列表）

* 广告状态：CheckBox中`ng-true-value`和`ng-false-value`的使用

* 展示时图片应该显示而不是显示图片路径

* 状态显示文字而不是0、1

* 其他RUD代码都自动生成了，略

  

## 8.2 网站首页-广告展示

> 创建war模块`pinyougou-portal-web` ，此工程为网站前台的入口。参照其它war模块配置文件，不需要添加SpringSecurity框架。修改端口，引入`pinyougou-content-interface`依赖。前端代码导入。

修改首页，当其**轮播广告图**根据8.1中后台设置的广告列表动态产生

后端

修改interface、service、controller代码

```java
@Override
public List<TbContent> findByCategoryId(Long categoryId) {
    TbContentExample example = new TbContentExample();
    Criteria criteria = example.createCriteria();
    criteria.andCategoryIdEqualTo(categoryId);//分类id
    criteria.andStatusEqualTo("1");//只查询状态为1的
    example.setOrderByClause("sort_order");//排序
    List<TbContent> tbContents = contentMapper.selectByExample(example);
    return tbContents;
}
```



前端（和之前的一样。引入JS）

```js
app.service("contentService",function ($http) {

    this.findByCategoryId = function (categoryId) {
        return $http.get("content/findByCategoryId.do?categoryId="+categoryId);
    }
})
```

```js
app.controller("contentController",function ($scope,contentService) {
    
    $scope.contentList = [];//所有广告列表（首页、猜你喜欢等等）
    $scope.findByCategoryId = function (categoryId) {
        contentService.findByCategoryId(categoryId).success(function (data) {
            $scope.contentList[categoryId] = data;
        })
    }
})
```

```html
<body ng-app="pinyougou" ng-controller="contentController" ng-init="findByCategoryId(1)">

    ......
    <!--轮播图，注意$index使用；active的添加（不添加会先展示空白，下一个轮播才展示图片）-->
    <li ng-repeat="item in contentList[1]" data-target="#myCarousel" data-slide-to="{{$index}}"
        class="{{$index==0?'active':''}}"></li>
    ......
    <div ng-repeat="item in contentList[1]" class="item {{$index==0?'active':''}}">
        <a href="{{item.url}}">
            <img src="{{item.pic}}"/>
        </a>
    </div>
</body>
```



## 8.3 网站首页-缓存广告数据

> 因为缓存对于我们整个的系统来说是通用功能。广告需要用，其它数据可能也会用到，所以我们将配置放在公共组件层（pinyougou-common）中较为合理

导入Maven依赖（jedis 和 spring-data-redis）；`redis-config.properties`和`applicationContext-redis.xml`配置文件

在`pinyougou-content-service`中导入`pinyougou-common`依赖

* 在`pinyougou-content-service`中修改**获取**广告服务的方法。在**增删改**广告时需要**清除缓存**数据

  ```java
  @Service
  public class ContentServiceImpl implements ContentService {
  
  
      @Override
      public void add(TbContent content) {
          contentMapper.insert(content);
          redisTemplate.boundHashOps("content").delete(content.getCategoryId());//清除缓存
      }
  
      @Override
      public void delete(Long[] ids) {
          for (Long id : ids) {
              Long categoryId = contentMapper.selectByPrimaryKey(id).getCategoryId();//先根据id查找categoryId
              redisTemplate.boundHashOps("content").delete(categoryId);//清除缓存
              contentMapper.deleteByPrimaryKey(id);
          }
      }
  
      @Override
      public void update(TbContent content) {
          //若是修改了CategoryId分组id，则修改前后的都要清除缓存
          Long oldCategoryId = contentMapper.selectByPrimaryKey(content.getId()).getCategoryId();//旧分组id
          if (oldCategoryId.longValue()!=content.getCategoryId().longValue()) { //若新旧分组id不一致，清除旧分组缓存
              redisTemplate.boundHashOps("content").delete(oldCategoryId);
          }
          redisTemplate.boundHashOps("content").delete(content.getCategoryId());//清除（新）分组的缓存
          contentMapper.updateByPrimaryKey(content);
      }
  
      @Override
      public List<TbContent> findByCategoryId(Long categoryId) {
          //content中存储所有类型广告，根据categoryId来对广告类型分类
          List<TbContent> list = (List<TbContent>) redisTemplate.boundHashOps("content").get(categoryId);
  
          if (list == null) {
              TbContentExample example = new TbContentExample();
              Criteria criteria = example.createCriteria();
              criteria.andCategoryIdEqualTo(categoryId);//分类id
              criteria.andStatusEqualTo("1");//只查询状态为1的
              example.setOrderByClause("sort_order");//排序
              list = contentMapper.selectByExample(example);
              //存入缓存
              redisTemplate.boundHashOps("content").put(categoryId, list);
  
          }
          return list;
      }
  }
  ```





# 9 搜索 Solr-1

## 9.1 环境搭建

- Maven依赖

  ```xml
  <dependency>
      <groupId>org.springframework.data</groupId>
      <artifactId>spring-data-solr</artifactId>
      <version>1.5.5.RELEASE</version>
  </dependency>
  <!--Demo中还会用到JUnit和Spring与JUnit整合-->
  ```

- resources下创建`applicationContext-solr.xml`

  ```xml
  <!-- solr服务器地址，其实就是配置了一个bean -->
  <solr:solr-server id="solrServer" url="http://127.0.0.1:8080/solr" />
  
  <!-- solr模板，使用solr模板可对索引库进行CRUD的操作 -->
  <bean id="solrTemplate" class="org.springframework.data.solr.core.SolrTemplate">
      <constructor-arg ref="solrServer" />
  </bean>
  ```

## 9.2 `@Field` 、`@Dynamic`注解

> `@Field`是Solr官方的SolrJ提供的注解，`@Dynamic`是SpringDataSolr的注解

创建 cn.itcast.pojo 包，将品优购的TbItem实体类拷入本工程，属性（即Field域）使用`@Field`注解标识。如果属性与配置文件定义的域名称不一致，需要在注解中指定域名称。（上面Solr中基本域配置和这个对应，复制域不需要，动态域后面讲）

```java
public class TbItem implements Serializable{
    
    @Dynamic
    @Field("item_spec_*")
    private Map<String,String> specMap;//动态域，在数据导入时需利用fastJSON转换JSON为map

    @Field
    private Long id;

    @Field("item_title")
    private String title;

    @Field("item_price")
    private BigDecimal price;

    @Field("item_image")
    private String image;

    @Field("item_goodsid")//注意大小写对应solr中配置的基本域
    private Long goodsId;

    @Field("item_category")
    private String category;

    @Field("item_brand")
    private String brand;

    @Field("item_seller")
    private String seller;
    .......
}
```



## 9.3 批量数据导入

> 可以使用Solr自带插件来导入，但不灵活，推荐查询增加的方式，根据条件筛选数据并导入Solr中

```java
//审核通过才导入
TbItemExample example = new TbItemExample();
TbItemExample.Criteria criteria = example.createCriteria();
criteria.andStatusEqualTo("1");

List<TbItem> items = itemMapper.selectByExample(example);
for (TbItem item : items) {
    Map specMap = JSON.parseObject(item.getSpec(), Map.class);//fastJSON将数据库中json数据转为Map
    item.setSpecMap(specMap);
}
solrTemplate.saveBeans(items);//saveBeans()
solrTemplate.commit();
```



## 9.4 关键字搜索（复制域）

`ItemSearchServiceImpl`

```java
@Service(timeout = 5000)//推荐写在服务提供方。当两方同时写，以消费方为准
public class ItemSearchServiceImpl implements ItemSearchService {
    @Autowired
    private SolrTemplate solrTemplate;
    
    //前端传入的数据有多好多类型，如关键字、类型多选框之类的，前端封装为map类似对象
    //后端不仅仅返回列表数据，还要返回根据关键字搜索后的分类信息，选择框等等，所以封装为map
    @Override
    public Map search(Map searchMap) {
        Map map = new HashMap();
        Query query = new SimpleQuery("*:*");
        Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords"));//is匹配（利用分词实现）
        query.addCriteria(criteria);
        ScoredPage<TbItem> tbItems = solrTemplate.queryForPage(query, TbItem.class);

        map.put("list",tbItems.getContent());
        return map;
    }
}
```

`ItemSearchController`

```java
@RestController
@RequestMapping("/itemSearch")
public class ItemSearchController {
    @Reference(timeout = 5000)//默认为1秒
    private ItemSearchService itemSearchService;

    @RequestMapping("/search")
    public Map search(@RequestBody Map searchMap){ //@RequestBody接收前端json数据
        return itemSearchService.search(searchMap);
    }
}
```

`ItemSearchService.js`

```js
app.service("itemSearchService",function ($http) {
    this.search = function (searchMap) {
        return $http.post("/itemsearch/search.do",searchMap);
    }
})
```

`ItemSearchController.js`

```js
app.controller("itemSearchController",function ($scope,itemSearchService) {
    $scope.search = function () {
        itemSearchService.search($scope.searchMap).success(function (data) {
            $scope.resultMap = data;
        })
    }
})
```



## 9.5 高亮显示关键字搜索（复制域）

> 高亮显示标题title中的字符

需要修改关键字搜索中的service方法，其他不变

```java
@Override
public Map search(Map searchMap) {
    Map<String,Map> map = new HashMap<>();
    //1.查询列表数据
    map.putAll(searchList(searchMap));
    //2.分组查询商品分类列表
    List<String> categoryList = searchCategoryList(searchMap);
    map.put("categoryList", categoryList);
    //3.根据分类名称查询品牌和规格列表
    String category = (String) searchMap.get("category");
    if ("".equals(category)){ //若没选择分类，按第一个分类查询
        if (categoryList.size()>0) {
            map.putAll(searchBrandAndSpecList(categoryList.get(0)));
        }
    } else { //若选择了分类，按选择的分类名称查询
        map.putAll(searchBrandAndSpecList(category));
    }

    return map;
}

private Map searchList(Map searchMap) {
    Map map = new HashMap();
    //关键字的条件查询（利用复制域），相当于where
    Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords"));
    HighlightQuery query = new SimpleHighlightQuery(criteria);
    //高亮选项
    HighlightOptions highlightOptions = new HighlightOptions()
        .addField("item_title")//高亮Filed域
        .setSimplePrefix("<span style='color: red;'>")//HTML前缀
        .setSimplePostfix("</span>");//HTML后缀
    query.setHighlightOptions(highlightOptions);//设置高亮设置
    HighlightPage<TbItem> items = solrTemplate.queryForHighlightPage(query, TbItem.class);

    //设置高亮
    List<HighlightEntry<TbItem>> highlighted = items.getHighlighted();//高亮entry集合（每条记录）
    for (HighlightEntry<TbItem> entry : highlighted) {
        //高亮列表（高亮Filed域个数可能多个）。并且每个Filed域可能存储多值（此处没有）
        TbItem item = entry.getEntity();//获取源实体类
        List<HighlightEntry.Highlight> highlights = entry.getHighlights();
        if (highlights.size() >= 0 && highlights.get(0).getSnipplets().size() >= 0) {
            item.setTitle(highlights.get(0).getSnipplets().get(0));
        }
    }

    map.put("list", items.getContent());
    return map;
}
```

但是此时HTML中显示的是HTML代码，不是解析后的页面。这是AngularJS为了防止html攻击采取的安全机制。此时需要用到AngularJS的`$sce`服务中的`trustAsHtml`方法。由于该方法具有通用性，定义在`filter`过滤器中（放入base.js）

```js
app.filter("trustHtml",['$sce',function ($sce) {
    return function (data) {
        return $sce.trustAsHtml(data);
    }
}])
```

HTML中就不能使用`{{}}`来绑定了，需要使用`ng-bing-html`

```html
<div class="attr" ng-bind-html="item.title | trustHtml"></div>
```







# 10 搜索 Solr-2

> 在关键字搜索的基础上添加面板搜索功能，面板上有商品分类、品牌、各种规格和价格区间等条件
>

![1548253012786](images/1548253012786.png)

（1）搜索面板的**商品分类**需要使用Spring Data Solr的**分组查询**来实现

（2）为了能够提高查询速度，我们需要把查询面板的品牌、规格数据提前放入**redis**

（3）查询条件的构建、面板的隐藏需要使用angularJS来实现

（4）后端的分类、品牌、规格、价格区间查询需要使用**过滤查询**来实现



## 10.1 显示商品分类分组查询

service中添加私有方法并调用

```java
/**
 * 分组查询商品分类列表
 */
private List searchCategoryList(Map searchMap){
    List<String> list = new ArrayList<>();
    //关键字的条件查询（利用复制域），相当于where
    Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords"));
    Query query = new SimpleQuery(criteria);
    //设置分组选项，相当于group by。可能有多个分组（继续addGroupByField即可）
    GroupOptions groupOptions = new GroupOptions().addGroupByField("item_category");
    query.setGroupOptions(groupOptions);
    //分组页
    GroupPage<TbItem> items = solrTemplate.queryForGroupPage(query, TbItem.class);
    //分组结果
    GroupResult<TbItem> item_category = items.getGroupResult("item_category");
    //分组entry页
    Page<GroupEntry<TbItem>> groupEntries = item_category.getGroupEntries();
    //分组entryj集合，便利获取值
    List<GroupEntry<TbItem>> content = groupEntries.getContent();
    for (GroupEntry<TbItem> tbItemGroupEntry : content) {
        list.add(tbItemGroupEntry.getGroupValue());
    }
    return list;
}
```

HTML中遍历

```html
<div ng-if="resultMap.categoryList!=null" >
    <a ng-repeat="category in resultMap.categoryList" href="#{{$index}}">{{category}} </a>
</div>
```



## 10.2 缓存品牌、规格数据

> 将商品分类数据、品牌数据、和规格数据都放入Redis存储

（1）当用户进入运营商后台的商品分类页面时，将**商品分类数据**放入缓存（Hash）。以**分类名称作为key** ，以**模板ID作为值**

（2）当用户进入运营商后台的模板管理页面时，分别将**品牌**数据和**规格**数据放入缓存（Hash）。以模板ID作为key，以品牌列表和规格列表作为值

------

1. `ItemCatServiceImpl`缓存模板ID，放在`findByParentId`方法中，每次增删改都会调用该方法来显示页面

   ```java
   @Autowired
   private RedisTemplate redisTemplate;
   
   private void saveToRedis() {
       //模板分类页面会先调用这个方法，执行增删改也会执行这个方法，所以放这里好！
       //将模板id存入缓存
       List<TbItemCat> list = findAll();
       for (TbItemCat itemCat : list) {
           redisTemplate.boundHashOps("itemCat").put(itemCat.getName(),itemCat.getTypeId());
       }
   }
   ```

2. `TypeTemplateServiceImpl`缓存品牌和规格

   ```java
   @Autowired
   private RedisTemplate redisTemplate;
   
   private void saveToRedis() {
       List<TbTypeTemplate> typeTemplateList = findAll();
       for (TbTypeTemplate typeTemplate : typeTemplateList) {
           List<Map> brandList = JSON.parseArray(typeTemplate.getBrandIds(), Map.class);//品牌列表转换json字符串
           redisTemplate.boundHashOps("brandList").put(typeTemplate.getId(),brandList);//缓存品牌列表
   
           List<Map> specList = findSpecList(typeTemplate.getId());//规格列表整合规格选项（之前封装好的方法）
           redisTemplate.boundHashOps("specList").put(typeTemplate.getId(),specList);
       }
       System.out.println("缓存品牌列表");
   }
   ```

   

## 10.3 显示品牌和规格数据

> 在搜索面板区域显示**第一个分类**的**品牌和规格**列表

```java
/**
 * 查询品牌和规格列表
 */
private Map searchBrandAndSpecList(String categoryName) {
    Map map = new HashMap();
    //1.根据商品分类名称得到模板id
    Long categoryId = (Long) redisTemplate.boundHashOps("itemCat").get(categoryName);
    if (categoryId != null) {
        //2.根据模板id获取品牌列表
        List brandList = (List) redisTemplate.boundHashOps("brandList").get(categoryId);
        map.put("brandList", brandList);
        //3.根据模板id获取规格列表
        List specdList = (List) redisTemplate.boundHashOps("specList").get(categoryId);
        map.put("specdList", specdList);
    }
    return map;
}
```

前端还是只需修改HTML



## 10.4 过滤条件构建（所有前端代码）

点击搜索面板上的分类、品牌、规格和价格，实现查询条件的构建。查询条件以面包屑的形式显示。

当面包屑显示分类、品牌、规格和价格时，要同时隐藏搜索面板对应的区域。

用户可以点击面包屑上的X撤销查询条件。撤销后显示搜索面包相应的区域。

分页。

**增加/撤销查询条件**

`ItemSearchController.js`

```js
app.controller("itemSearchController", function ($scope, itemSearchService,$location) {

    $scope.searchMap = {
        'keywords': '',
        'category': '',
        'brand': '',
        'spec': {},
        'price': '',
        'pageNum': 1,
        'pageSize': 40,
        'sort': '',
        'sortField': ''
    };
    $scope.search = function () {

        itemSearchService.search($scope.searchMap).success(function (data) {
            $scope.resultMap = data;
            buildPageLabel();
        })
    };

    //构建分页栏
    buildPageLabel = function () {
        $scope.pageLabel = [];//分页要遍历的变量

        //若是总页数小于等于5，直接使用下面的值
        let startPage = 1;
        let endPage = $scope.resultMap.pages;
        //$scope.startPoint = false;//前面的三个点。注释掉了，但是代码可用
        //$scope.endPoint = false;//后面的三个点

        //若是总页数大于5，重新指定值
        if ($scope.resultMap.pages > 5) {
            if ($scope.searchMap.pageNum - 2 <= 1) { //显示前5页
                endPage = 5;
                //$scope.endPoint = true;//后面的三个点
            } else if ($scope.searchMap.pageNum + 2 >= endPage) {//显示后5页
                startPage = endPage - 4;
                //$scope.startPoint = true;//前面的三个点
            } else {
                startPage = $scope.searchMap.pageNum - 2;
                endPage = $scope.searchMap.pageNum + 2;
                //$scope.startPoint = true;//前面的三个点
                //$scope.endPoint = true;//后面的三个点
            }
        }
        //构建分页要遍历的变量
        for (let i = startPage; i <= endPage; i++) {
            $scope.pageLabel.push(i);
        }

    };

    //翻页
    $scope.queryByPage = function (pageNum) {
        pageNum = parseInt(pageNum);//HTML中绑定文本框传入的数据是字符串，需转换
        if (pageNum <= 0 || pageNum > $scope.resultMap.pages) {//对页码校验
            return;
        }
        $scope.searchMap.pageNum = pageNum;
        $scope.search();
    }

    //添加搜索项
    $scope.addSearchItem = function (key, value) {
        if ('category' == key || 'brand' == key || 'price' == key) { //分类或品牌或价格
            $scope.searchMap[key] = value;
        } else { //规格
            $scope.searchMap.spec[key] = value;
        }
        $scope.search();//每次更改查询
    };

    //撤销搜索项
    $scope.removeSearchItem = function (key) {
        if ('category' == key || 'brand' == key || 'price' == key) { //分类或品牌或价格
            $scope.searchMap[key] = '';
        } else { //规格
            delete $scope.searchMap.spec[key];
        }
        $scope.search();//每次更改查询
    };

    //排序
    $scope.sortSearch = function (sort, sortField) {
        $scope.searchMap.sort = sort;
        $scope.searchMap.sortField = sortField;
        $scope.search();
    };

    //隐藏品牌列表（当关键字包含品牌时）
    $scope.keywordsIsBrand = function () {
        for (let i = 0; i < $scope.resultMap.brandList.length; i++) {
            if ($scope.searchMap.keywords.indexOf($scope.resultMap.brandList[i].text)!=-1) {
                return true;
            }
        }
        return false;
    }
    
    //首页传参（静态页面传参），在body中调用即可
    $scope.loadKeywords = function () {
        $scope.searchMap.keywords = $location.search()['keywords'];
        $scope.search();
    }
});
```

HTML中**面包屑**和**隐藏/显示查询面板**

```html
<!--面包屑。遍历时key value使用-->
<li class="tag" ng-if="searchMap.category!=''" ng-click="removeSearchItem('category')">{{searchMap.category}}</li>
<li class="tag" ng-if="searchMap.brand!=''" ng-click="removeSearchItem('brand')">{{searchMap.brand}}</li>
<li class="tag" ng-repeat="(key,value) in searchMap.spec" ng-click="removeSearchItem(key)">{{key}}:{{value}}</li>
<li class="tag" ng-if="searchMap.price!=''" ng-click="removeSearchItem('price')">{{searchMap.price}}</li>

<!--查询条件，其他类似-->
<div class="type-wrap" ng-if="resultMap.categoryList!=null && searchMap.category==''">
    <a ng-repeat="category in resultMap.categoryList" ng-click="addSearchItem('category',category)"
       href="#">{{category}} </a>
</div>
......

<div class="type-wrap" ng-repeat="spec in resultMap.specList" ng-if="searchMap.spec[spec.text]==null">
    <div class="fl key">{{spec.text}}</div>
    ...
    <li ng-repeat="option in spec.options">
        <a ng-click="addSearchItem(spec.text,option.optionName)" href="#">{{option.optionName}}</a>
    </li>
</div>
......
```

HTML中分页（要记得每次点击搜索按钮时置当前页pageNum为1，否则会出错）

```html
<!--分页栏-->
<li class="prev {{searchMap.pageNum-1<=0?'disabled':''}}">
    <a ng-click="queryByPage(searchMap.pageNum-1)">«</a>
</li>
<li class="dotted"><span ng-if="startPoint==true">...</span></li>
<li ng-repeat="x in pageLabel">
    <a href="#" ng-click="queryByPage(x)">{{x}}</a>
</li>
<li class="dotted"><span ng-if="endPoint==true">...</span></li>
<li class="next {{searchMap.pageNum+1>resultMap.pages?'disabled':''}}">
    <a ng-click="queryByPage(searchMap.pageNum+1)">»</a>
</li>
<div><span>共{{resultMap.pages}}页&nbsp;</span><span>
<!--跳转页-->
到第<input type="text" class="page-num" ng-model="searchMap.pageNum">页 
    <button class="page-confirm" ng-click="queryByPage(searchMap.pageNum)">确定</button></span></div>
```



## 10.5 过滤查询（所有后端代码）

> 还需修改根据分类查询品牌规格列表（之前的代码没考虑选择后品牌和规格的变化）。这里价格区间有些硬编码。

```java
@Service(timeout = 5000)//推荐写在服务提供方。所两方同时写，以消费方为准
public class ItemSearchServiceImpl implements ItemSearchService {

    @Autowired
    private SolrTemplate solrTemplate;

    /**
     * 搜索
     */
    @Override
    public Map search(Map searchMap) {
        //去掉搜索关键字中的空格
        String  keywords = (String) searchMap.get("keywords");
        searchMap.put("keywords",keywords.replace(" ",""));
        
        Map map = new HashMap<>();
        //1.查询列表数据
        map.putAll(searchList(searchMap));
        //2.分组查询商品分类列表
        List<String> categoryList = searchCategoryList(searchMap);
        map.put("categoryList", categoryList);
        //3.根据分类名称查询品牌和规格列表
        String category = (String) searchMap.get("category");
        if ("".equals(category)) { //若没选择分类，按第一个分类查询
            if (categoryList.size() > 0) {
                map.putAll(searchBrandAndSpecList(categoryList.get(0)));
            }
        } else { //若选择了分类，按选择的分类名称查询
            map.putAll(searchBrandAndSpecList(category));
        }
        return map;
    }

    /**
     * 列表查询（过滤查询等等）
     */
    private Map searchList(Map searchMap) {
        Map map = new HashMap();

        //1.1关键字查询（利用复制域）
        Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords"));
        HighlightQuery query = new SimpleHighlightQuery(criteria);
        //高亮选项设置
        HighlightOptions highlightOptions = new HighlightOptions()
            .addField("item_title")//高亮Filed域
            .setSimplePrefix("<span style='color: red;'>")//HTML前缀
            .setSimplePostfix("</span>");//HTML后缀
        query.setHighlightOptions(highlightOptions);//设置高亮设置

        //1.2按照商品分类过滤
        if (!"".equals(searchMap.get("category"))) { //若用户选择了分类
            Criteria filterCriteria = new Criteria("item_category").is(searchMap.get("category"));
            FilterQuery filterQuery = new SimpleFilterQuery(filterCriteria);
            query.addFilterQuery(filterQuery);
        }

        //1.3按照品牌过滤
        if (!"".equals(searchMap.get("brand"))) { //若用户选择了品牌
            Criteria filterCriteria = new Criteria("item_brand").is(searchMap.get("brand"));
            FilterQuery filterQuery = new SimpleFilterQuery(filterCriteria);
            query.addFilterQuery(filterQuery);
        }

        //1.4按照规格过滤
        if (searchMap.get("spec") != null) { //若用户选择了规格

            Map<String, String> specMap = (Map<String, String>) searchMap.get("spec");
            Set<Map.Entry<String, String>> entries = specMap.entrySet();
            for (Map.Entry<String, String> entry : entries) {
                System.out.println(entry.getKey() + "====" + entry.getValue());
                Criteria filterCriteria = new Criteria("item_spec_" + entry.getKey()).is(entry.getValue());
                FilterQuery filterQuery = new SimpleFilterQuery(filterCriteria);
                query.addFilterQuery(filterQuery);
            }
        }
        
        //1.5按照价格过滤
        if (!"".equals(searchMap.get("price"))){
            String price = (String) searchMap.get("price");
            String[] split = price.split("-");

            Criteria filterCriteria = new Criteria("item_price");
            if (!split[0].equals("0")){ //起始条件
                filterCriteria.greaterThanEqual(split[0]);//大于等于
            }
            if (!split[1].equals("*")){ //终止条件
                filterCriteria.lessThanEqual(split[1]); //小于等于
            }
            FilterQuery filterQuery = new SimpleFilterQuery(filterCriteria);
            query.addFilterQuery(filterQuery);
        }
        
        //1.6分页
        Integer pageNum = (Integer) searchMap.get("pageNum");//当前页
        if (pageNum==null){
            pageNum = 1;
        }
        Integer pageSize = (Integer) searchMap.get("pageSize");//每页记录数
        if (pageSize==null){
            pageSize = 20;
        }
        query.setOffset((pageNum-1)*pageSize);//起始索引（不是页码）
        query.setRows(pageSize);//每页记录数
        //在最后返回getContent()后还需传递pages、total；

        //1.7排序（根据传入的Field字段）
        String  sortValue = (String) searchMap.get("sort");//升序或降序
        String sortField = (String) searchMap.get("sortField");//排序的Field字段
        if (sortValue!=null && !sortValue.equals("")){
            if (sortValue.equals("ASC")){
                Sort sort = new Sort(Sort.Direction.ASC,"item_"+sortField);
                query.addSort(sort);
            } else if (sortValue.equals("DESC")){
                Sort sort = new Sort(Sort.Direction.DESC,"item_"+sortField);
                query.addSort(sort);
            }
        }
        
        //高亮页对象
        HighlightPage<TbItem> items = solrTemplate.queryForHighlightPage(query, TbItem.class);

        //遍历并设置高亮
        List<HighlightEntry<TbItem>> highlighted = items.getHighlighted();//高亮entry集合（每条记录）
        for (HighlightEntry<TbItem> entry : highlighted) {
            //高亮列表（高亮Filed域个数可能多个）。并且每个Filed域可能存储多值（此处没有）
            TbItem item = entry.getEntity();//获取源实体类
            List<HighlightEntry.Highlight> highlights = entry.getHighlights();
            if (highlights.size() > 0 && highlights.get(0).getSnipplets().size() > 0) {
                item.setTitle(highlights.get(0).getSnipplets().get(0));
            }
        }

        map.put("list", items.getContent());//当前页所有数据
        map.put("pages",items.getTotalPages());//总页数
        map.put("total",items.getTotalElements());//总记录数
        return map;
    }

    /**
     * 分组查询商品分类列表
     */
    private List searchCategoryList(Map searchMap) {
        List<String> list = new ArrayList<>();
        //关键字的条件查询（利用复制域），相当于where
        Criteria criteria = new Criteria("item_keywords").is(searchMap.get("keywords"));
        Query query = new SimpleQuery(criteria);
        //设置分组选项，相当于group by。可能有多个分组（继续addGroupByField即可）
        GroupOptions groupOptions = new GroupOptions().addGroupByField("item_category");
        query.setGroupOptions(groupOptions);
        //分组页
        GroupPage<TbItem> items = solrTemplate.queryForGroupPage(query, TbItem.class);
        //分组结果
        GroupResult<TbItem> item_category = items.getGroupResult("item_category");
        //分组entry页
        Page<GroupEntry<TbItem>> groupEntries = item_category.getGroupEntries();
        //分组entryj集合，便利获取值
        List<GroupEntry<TbItem>> content = groupEntries.getContent();
        for (GroupEntry<TbItem> tbItemGroupEntry : content) {
            list.add(tbItemGroupEntry.getGroupValue());
        }
        return list;
    }

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * Redis查询品牌和规格列表
     */
    private Map searchBrandAndSpecList(String categoryName) {
        Map map = new HashMap();
        //1.根据商品分类名称得到模板id
        Long categoryId = (Long) redisTemplate.boundHashOps("itemCat").get(categoryName);
        if (categoryId != null) {
            //2.根据模板id获取品牌列表
            List brandList = (List) redisTemplate.boundHashOps("brandList").get(categoryId);
            map.put("brandList", brandList);
            //3.根据模板id获取规格列表
            List specdList = (List) redisTemplate.boundHashOps("specList").get(categoryId);
            map.put("specList", specdList);
        }
        return map;
    }
}
```





# 11 搜索 Solr-3

## 11.1 分页

> 查看10.4和10.5



## 11.2 多关键字搜索

> 如搜索“三星手机”时，可能自动**分词**为三星手机、三星、手机，**按顺序**查询出。是**或**的关系。
>
> 若搜索“三星 手机”时，将不会分词，是与的关系。所以需要在后端去掉空格（运营角度考虑，搜出的东西多点）
>
> 查看10.5



## 11.3 排序（未完整）

> 查看10.5

HTML暂时这样写

```html
<li class="active">
    <a href="#" ng-click="sortSearch('','')">综合</a>
</li>
<li>
    <a href="#">销量</a> <!--订单模块暂时没做-->
</li>
<li>
    <a href="#" ng-click="sortSearch('DESC','updatetime')">新品</a>
</li>
<li>
    <a href="#">评价</a> <!--评价模块暂时没做-->
</li>
<li>
    <a href="#" ng-click="sortSearch('ASC','price')">价格↑</a>
</li>
<li>
    <a href="#" ng-click="sortSearch('DESC','price')">价格↓</a>
</li>
```

新品按照上架时间来降序，需要在solrhome的scheme.xml中添加基本域，修改字段，并导入数据

```xml
<field name="item_updatetime" type="string" indexed="true" stored="true" /><!--updatetime,上架时间-->
```

```java
@Field("item_updatetime")
private Date updateTime;
```



> **销量排序**需要查询order和order_item表，统计出来（尽量统计**某一周期的销量**！）。但是销量是实时变化的，可以做个定时任务，来批量导入数据到solr中。定时任务可以采用**Spring Task**框架，可以放在凌晨。
>
> 评价排序同上，但是需要根据好评、中评、差评按权重来统计



## 11.4 隐藏品牌列表

> 关键字中输入品牌，那么下面的品牌列表需要隐藏。查看10.4

只需在前端判断**关键字子字符串**是否在**品牌列表**中



## 11.5 搜索页与首页对接（new）

> 查看10.4

静态页面传参，`$location`服务的`search()`方法，在数组中取值

```html
<input ng-model="keywords" type="text"  class="input-error input-xxlarge"/>
<button  type="button" ng-click="search()" >搜索</button>
```

```js
//搜索，传递参数
$scope.search = function () {
    location.href = "http://localhost:9104/search.html#?keywords="+$scope.keywords;
}
```



## 11.6 更新索引库（new）

在进行**商品审核后**更新到solr索引库,在**商品删除后**删除solr索引库中相应的记录。要符合分模块开发的要求：

1. 商家商品服务：**查询**方法，根据SPU的ID集合来查询SKU列表（状态为已审核）
2. 搜索服务：批量**导入**方法，接收的参数为SKU列表。**删除**SKU商品
3. 运营商后台：**审核通过**、**删除**时调用上面俩方法（删除时只需要搜索服务）

`com/pinyougou/sellergoods/service/impl/GoodsServiceImpl.java`

```java
//根据SPU的id集合查询SKU列表
@Override
public List<TbItem> findItemListByGoodsIdListAndStatus(Long[] goodsIds, String status){
    TbItemExample example = new TbItemExample();
    TbItemExample.Criteria criteria = example.createCriteria();
    criteria.andStatusEqualTo(status);
    criteria.andGoodsIdIn(Arrays.asList(goodsIds));//指定条件（SPU的ID集合）数组转集合
    return itemMapper.selectByExample(example);
}
```

`com/pinyougou/search/service/impl/ItemSearchServiceImpl.java`

```java
@Override
public void importList(List list){
    solrTemplate.saveBeans(list);
    solrTemplate.commit();
}

@Override
public void deleteByGoodsIds(List goodsIds) {
    Criteria criteria = new Criteria("item_goodsid").in(goodsIds);
    Query query = new SimpleQuery(criteria);
    solrTemplate.delete(query);
    solrTemplate.commit();
}
```

`com/pinyougou/manager/controller/GoodsController.java`

```java
@Reference(timeout = 10000)
private ItemSearchService itemSearchService;

@RequestMapping("/updateStatus")
public Result updateStatus(Long[] ids, String status){
    try {
        goodsService.updataStatus(ids,status);
        if ("1".equals(status)){ //审核通过
            //需要导入的SKU列表
            List<TbItem> list = goodsService.findItemListByGoodsIdListAndStatus(ids, "1");
            //引入pinyougou-search-interface
            itemSearchService.importList(list);
        }
        return new Result(true,"修改成功");
    } catch (Exception e) {
        e.printStackTrace();
        return new Result(false,"修改失败");

    }
}

@RequestMapping("/delete")
public Result delete(Long [] ids){
    try {
        itemSearchService.deleteByGoodsIds(Arrays.asList(ids));//这里
        goodsService.delete(ids);
        return new Result(true, "删除成功"); 
    } catch (Exception e) {
        e.printStackTrace();
        return new Result(false, "删除失败");
    }
}
```





# 12 网页静态化 Freemarker

> 网页静态化解决方案在实际开发中运用比较多，例如新闻网站，门户网站中的新闻频道或者是文章类的频道
>
> 对于电商网站的**商品详细页**来说，至少几百万个商品，每个商品又有大量的信息，这样的情况同样也适用

网页静态化技术和缓存技术的共同点都是为了**减轻数据库的访问压力**，但是具体的应用场景不同，缓存比较适合小规模的数据，而网页静态化比较适合大规模且相对变化不太频繁的数据。另外网页静态化还有利于**SEO（搜索引擎优化）**。

另外我们如果将**网页**以**纯静态化**的形式展现，就可以**使用Nginx这样的高性能的web服务器来部署**。Nginx可以承载**5万的并发**，而**Tomcat只有几百**。关于Nginx我们在后续的课程中会详细讲解。



## 12.1 入门

### 12.1.1 Demo

* Maven引入依赖

  ```xml
  <dependency>
      <groupId>org.freemarker</groupId>
      <artifactId>freemarker</artifactId>
      <version>2.3.23</version>
  </dependency>
  ```

* 模板文件`test.ftl`

  ```
  <html>
  <head>
  <title>demo</title>
  <mete charset="UTF-8"/>
  </head>
  <body>
  <#--注释，不会输出到源代码中-->
  <!--会输出到源代码中-->
  ${name},你好。${message}
  </body>
  </html>
  ```

* `Test.java`，执行后即可在D盘找到生成的html文件

  ```java
  public static void main(String[] args) throws IOException, TemplateException {
      //1.创建一个配置对象
      Configuration configuration = new Configuration(Configuration.getVersion());
      //2.设置模板所在目录
      configuration.setDirectoryForTemplateLoading(new File("D:\\Code-Workspace\\IDEA\\freemarkerdemo\\src\\main\\resources\\"));
      //3.设置字符集
      configuration.setDefaultEncoding("UTF-8");
      //4.获取模板对象
      Template template = configuration.getTemplate("test.ftl");
      //5.创建数据模型（可以是对象，也可以是map）
      Map map = new HashMap();
      map.put("name","张三");
      map.put("message","欢迎来品优购");//少给值运行时就报错
      //6.创建一个输出流对象
      FileWriter out = new FileWriter("d:\\test.html");
      //7.输出
      template.process(map,out);
      //8.关闭输出流
      out.close();
  }
  ```



### 12.1.2 指令

* assign：此指令用于在页面上定义一个变量

  * 定义简单类型

    ```
    <#assign linkman="周先生">
    联系人：${linkman}
    ```

  * 定义对象类型

    ```
    <#assign info={"mobile":"13301231212",'address':'北京市昌平区王府街'} >
    电话：${info.mobile}  地址：${info.address}
    ```

* include：此指令用于模板文件的嵌套

  * 创建模板文件head.ftl

  * 我们修改test.ftl，在模板文件中使用include指令引入刚才我们建立的模板

    ```
    <#include "head.ftl">
    ```

* if：判断（可以用==、=）

  ```
  <#if success==true>
  你已通过实名认证
  <#else>  
  你未通过实名认证
  </#if>
  ```

  在代码中对str变量赋值

  ```java
  map.put("success", true);
  ```

* list：遍历

  ```
  <#list goodsList as goods>
  	${goods_index+1} 商品名称： ${goods.name} 价格：${goods.price}<br>
  </#list>
  ```

  

### 12.1.3 内建函数

内建函数语法格式： `变量?函数名称`

* 获取集合大小

  ```
  共  ${goodsList?size}  条记录
  ```

* 转换JSON字符串为对象

  ```
  <#assign text="{'bank':'工商银行','account':'10101920201920212'}" />
  <#assign data=text?eval />
  开户行：${data.bank}  账号：${data.account}
  ```

* 日期格式化

  ```
  当前日期：${today?date} <br>
  当前时间：${today?time} <br>   
  当前日期+时间：${today?datetime} <br>        
  日期格式化：  ${today?string("yyyy年MM月")}
  ```

* 数字转换为字符串：数字会以每三位一个分隔符显示，不需要这个分隔符，使用内建函数c

  ```
  累计积分：${point?c}
  ```

* 空值处理运算符：在模板中使用了变量但是在代码中没有对变量赋值，那么运行生成时会抛出异常

  * 判断某变量是否存在:“`??`”

    ```
    <#if aaa??>
    aaa变量存在
    <#else>
    aaa变量不存在
    </#if>
    ```

  * 缺失变量默认值:“`!`”：使用!对null值做转换处理，值可以自定义

    ```
    ${aaa!'-'}
     <#-- 当aaa为null则返回！后边的内容-  -->
    ```

* 运算符

  * 算数运算符：`+, - , * , / , %`
  * 逻辑运算符：`&&、||、!`，只能作用于布尔值
  * 比较运算符
    * `=`或者`==`:判断两个值是否相等. 
    * `!=`:判断两个值是否不等. 
    * `>`或者`gt`:判断左边值是否大于右边值（有时需要括号括起来，否则和标签的小于号对应上，下面的同理）
    * `>=`或者`gte`:判断左边值是否大于等于右边值 
    * `<`或者`lt`:判断左边值是否小于右边值 
    * `<=`或者`lte`:判断左边值是否小于等于右边值 

  **注意**:  =和!=可以用于字符串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误,而且FreeMarker是精确比较,"x","x ","X"是不等的.其它的运行符可以作用于数字和日期,但不能作用于字符串,大部分的时候,使用gt等字母运算符代替>会有更好的效果,因为 FreeMarker会把>解释成FTL标签的结束字符,当然,也可以使用括号来避免这种情况,如:<#if (x>y)> 





## 12.2 商品详情页

> 运用Freemarker技术来实现商品详细页的静态化。通过地址栏输入某地址，如下形式`http://localhost:9101/gen_item.do?goodsId=149187842867952`能在本地电脑某目录生成商品详细页，页面的名称为商品goodsId.html

创建`pinyougou-page-interface`及`pinyougou-page-service`工程

配置文件参考入门

创建`page.properties`文件来存储生成的html文件位置

```properties
pagedir=d:\\item\\
```

Spring中配置文件添加如下配置

```xml
<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
    <property name="templateLoaderPath" value="/WEB-INF/ftl/"/><!--模板文件路径-->
    <property name="defaultEncoding" value="UTF-8"/>
</bean>
```

`ItemPageServiceImpl`

```java
@Service
public class ItemPageServiceImpl implements ItemPageService {

    @Autowired
    private FreeMarkerConfig freeMarkerConfig;

    @Value("${pagedir}")
    private String pagedir;

    @Autowired
    private TbGoodsMapper goodsMapper;

    @Autowired
    private TbGoodsDescMapper goodsDescMapper;

    @Override
    public boolean genItemHtml(Long goodsId) {
        Configuration configuration = freeMarkerConfig.getConfiguration();
        try {
            Template template = configuration.getTemplate("item.ftl");
            //创建数据模型
            Map dataModel = new HashMap();
            //1.商品主表数据
            TbGoods goods = goodsMapper.selectByPrimaryKey(goodsId);
            dataModel.put("goods",goods);
            //2.商品扩展表数据
            TbGoodsDesc goodsDesc = goodsDescMapper.selectByPrimaryKey(goodsId);
            dataModel.put("goodsDesc",goodsDesc);
		   //3.读取商品分类
            String itemCat1 = itemCatMapper.selectByPrimaryKey(goods.getCategory1Id()).getName();
            String itemCat2 = itemCatMapper.selectByPrimaryKey(goods.getCategory2Id()).getName();
            String itemCat3 = itemCatMapper.selectByPrimaryKey(goods.getCategory3Id()).getName();
            dataModel.put("itemCat1",itemCat1);
            dataModel.put("itemCat2",itemCat2);
            dataModel.put("itemCat3",itemCat3);
            //4.读取SKU列表数据
            TbItemExample example = new TbItemExample();
            TbItemExample.Criteria criteria = example.createCriteria();
            criteria.andGoodsIdEqualTo(goodsId);//SPU ID
            criteria.andStatusEqualTo("1");//状态有效
            example.setOrderByClause("is_default desc");//按照默认字段进行降序排序，目的是返回结果的第一条为默认SKU
            List<TbItem> itemList = itemMapper.selectByExample(example);
            dataModel.put("itemList",itemList);
            
            
            Writer writer = new FileWriter(pagedir+goodsId+".html");

            template.process(dataModel,writer);
            writer.close();

            return true;
        } catch (IOException | TemplateException e) {
            e.printStackTrace();
            return false;
        }
    }
}
```

`GoodsController`

```java
@RequestMapping("/genHtml")
public void genHtml(Long goodsId){
    itemPageService.genItemHtml(goodsId);
}
```



### 12.2.1 商品详情页-模板构建

修改模板文件`item.ftl`

* `<#include 'head.ftl'>`指令来构建头部和尾部

* 生成基本数据

  * 商品名称`${goods.goodsName}`
  * 商品副标题`${goods.caption}`
  * 商品介绍（暂时不涉及扩展属性）`${goods.introduction}`
  * 规格与包装`${goods.packageList}`
  * 售后保障`${goods.saleService}`

  * 运行控制层代码，测试生成效果`<http://localhost:9101/goods/genHtml.do?goodsId=149187842867960>`

* 生成图片列表

  * 转JSON字符串为对象

  * list内建函数遍历

    ```
    <#assign imageList=goodsDesc.itemImages?eval>
    
    <#if (imageList?size>0)>
    	<span><img jqimg="${imageList[0].url}" src="${imageList[0].url}" width="400px" height="500px" /</span>
    </#if>
    
    <ul>
    	<#list imageList as item>
    		<li><img src="${item.url}" bimg="${item.url}"  onmousemove="preview(this)" /></li>
    	</#list>
    </ul>
    ```

* 商品介绍中扩展属性（同上）

  ```
  <#assign customAttributeItems=goodsDesc.customAttributeItems?eval>
  
  <#list customAttributeItems as custom>
  	<#if custom.value??><#--变量存在才显示-->
  		<li>${custom.text}：${custom.value}</li>
  	</#if>
  </#list>
  ```

* 规格选项（同上）：==其中方法中带引号是因为，**页面先由Freemarker生成，再由前端来操控**。==

  ```
  <#assign specificationItems=goodsDesc.specificationItems?eval>
  
  <#list specificationItems as spec>
  	<dl>
  		<dt>
  			<div class="fl title">
  				<i>${spec.attributeName}</i>
  			</div>
  		</dt>
  		<#list spec.attributeValue as value>
  			<dd>
  			   <a href="javascript:;"
  				 class="{{isSelected('${spec.attributeName}','${value}')?'selected',''}}"
  				 ng-click="selectSpec('${spec.attributeName}','${value}');">${value}
  				 <span title="点击取消选择">&nbsp;</span>
  			  </a>
               </dd>
  		</#list>
  	</dl>
  </#list>
  ```

* **商品分类面包屑**（先修改`ItemPageServiceImpl`中的方法）

  ```
  <a href="#">${itemCat1}</a>
  <a href="#">${itemCat2}</a>
  <a href="#">${itemCat3}</a>
  ```



### 12.2.2 商品详情页-前端逻辑

* **数量增减**

  ```html
  <body ng-app="pinyougou" ng-controller="itemController" ng-init="num = 1">
      <input autocomplete="off" type="text" value="1" minnum="1" class="itxt"  ng-model="num"/>
      <a href="javascript:void(0)" class="increment plus" ng-click="addNum(1)">+</a>
      <a href="javascript:void(0)" class="increment mins" ng-click="addNum(-1)">-</a>
  </body>
  ```

  ```js
  app.controller("itemController",function ($scope) {
  
      $scope.addNum = function (x) {
          $scope.num = parseInt($scope.num);
          $scope.num += x;
          if ($scope.num<1){
              $scope.num = 1;
          }
      }
  
      $scope.selectedSpec = {};//存储用户选择的规格
      //跟新选中对象
      $scope.selectSpec = function (key, value) {
          $scope.selectedSpec[key] = value;
          searchSku();//查询并更新SKU
      }
      //判断规格是否被选中
      $scope.isSelected = function (key,value) {
          if ($scope.selectedSpec[key]==value){
              return true;
          } else {
              return false;
          }
      }
  
  
      $scope.sku = {};//当前选择的SKU
      $scope.loadSku = function () {
          $scope.sku = skuList[0];//模板生成时产生的JS脚本中的变量
          $scope.selectedSpec = JSON.parse(JSON.stringify($scope.sku.spec));//更新选中的SKU
      }
  
      //判断两个对象是否相等
      matchObject = function (obj1, obj2) {
          //由于可能两个对象的建个数都不同，所以需要都遍历
          for (let k in obj1) { //in遍历的时键
              if (obj1[k]!=obj2[k]){
                  return false;
              }
          }
          for (let k in obj2) { //in遍历的时键
              if (obj2[k]!=obj1[k]){
                  return false;
              }
          }
          return true;
      }
  
      //根据规格查找SKU，在每次用户选择规格后调用
      searchSku = function () {
          for (let i = 0; i < skuList.length; i++) {
              if (matchObject(skuList[i].spec,$scope.selectedSpec)){
                  $scope.sku = skuList[i];
                  return;
              }
          }
          //没找到。实际中应该是根据模板生成的SKU中的规格来决定展示在页面与否（可以不显示该规格）
          $scope.sku = {id:0,title:'-----',price:0};
      }
  
  });
  ```

* **规格选择**

  需要定义一个对象，存储用户选择的key/value，点击标签时更改此对象。控制层方法来判断当前规格与选项是否被选中

  ftl代码看规格选项中。JS代码看数量增减中



### 12.2.3 商品详情页-读取SKU信息

> 需求：当我们选择规格后，应该在页面上更新商品名称为SKU的商品标题，价格也应该为SKU的商品价格，不再是SPU数据

* **页面生成SKU列表变量**

  * 服务层（查看上面`ItemPageServiceImpl`）

  * ==解**决前端与静态文件交互**：**ftl页面JS脚本**（因为**从ftl生成html时就保存好数据**，所以不能放在前端）==

    ```
    var skuList = [
        <#list itemList as item>
            {
                    id:${item.id?c},
                    title:'${item.title}',
                    price:${item.price?c},
                    spec:${item.spec}
            },
        </#list>
    ];
    ```

* **显示SKU标题和价格**

  * 加载**默认SKU信息**（ftl页面中标题/价格等需要使用AngularJS来绑定SKU数据，不再时生成时的SPU模板数据），代码看上面

* **选择规格更新SKU**

  * 判断用户当前选择的规格和模板中JS代码的spec对象是否相等（对象不能使用`==`，遍历来判断），相等就更新sku数据

* **添加商品到购物车（当前为模拟）**

  需要SKU的ID和数量，暂时只弹框，因为需要跳转到购物车页面（实际中在边栏显示添加的商品）

  

  

## 12.3 系统模块对接

### 12.3.1 运营商后台调用页面生成服务

需要的是在**商品审核通过时生成html静态页**，修改pinyougou-manager-web的`GoodsController`

```java
@RequestMapping("/updateStatus")
public Result updateStatus(Long[] ids, String status){
    try {
        goodsService.updataStatus(ids,status);
        if ("1".equals(status)){ //审核通过
            //=====1.导入到solr索引库中=====
            //需要导入的SKU列表
            List<TbItem> list = goodsService.findItemListByGoodsIdListAndStatus(ids, "1");
            //引入pinyougou-search-interface
            itemSearchService.importList(list);

            
            //=====2.生成商品详细页=====
            for (Long id : ids) {
                itemPageService.genItemHtml(id);
            }
        }
        return new Result(true,"修改成功");
    } catch (Exception e) {
        e.printStackTrace();
        return new Result(false,"修改失败");
    }
}
```



### 12.3.2 创建商品详细页web工程

**这只是开发环境，使用Tomcat部署，在部署阶段，将部署到Nginx**

创建war模块工程`pinyougou-page-web` ，将目标目录（d:\item）的文件拷贝到此工程（生成的页面不用拷贝），只需在`pom.xml`设置端口为9105，`web.xml`中什么都不用配置。

在`pinyougou-search-web`中的`search.html`页面的遍历页面数据中设置a标签`http://localhost:9105/{{item.id}}.html`





# 13 消息中间件 JMS

## 13.1 JMS 入门

### 13.1.1 消息中间件

当前完成的模块之间调用

![当前完成的模块之间调用](images/1548443007647.png)

其中运营商后台的调用关系最多，用到了商家商品服务、广告内容服务、搜索服务和页面生成服务。这种模块之间的依赖也称之为耦合。而耦合越多，之后的维护工作就越困难。解决方案----消息中间件。

------

**消息中间件**利用高效可靠的消息传递机制进行**平台无关的数据交流**，并基于数据通信来进行[分布式系统](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)的集成。通过提供**消息传递**和**消息排队**模型，它可以在分布式环境下扩展进程间的通信。对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）。常见的消息中间件产品：

* **ActiveMQ**

  ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。

* RabbitMQ

  AMQP协议的领导实现，支持多种场景。淘宝的MySQL集群内部有使用它进行通讯，OpenStack开源云平台的通信组件，最先在金融行业得到运用。

* ZeroMQ

  史上最快的消息队列系统

* Kafka

  Apache下的一个子项目 。特点：高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统。适合处理海量数据。

------

改造系统模块调用关系

![改造系统模块调用关系](images/1548443431977.png)

使得运营商系统与搜索服务、页面生成服务解除了耦合，这俩模块的调用**不需要返回数据，所以可以解耦**，但是商家商品服务和广告内容服务由于**需要获取返回数据，所以不可以解耦**。



### 13.1.2 JMS简介

JMS（Java Messaging Service）是Java平台上有关面向消息中间件的**技术规范**，它便于消息系统中的Java应用程序进行消息交换，并且通过**提供标准的产生、发送、接收消息的接口**简化企业应用的开发

JMS 本身只定义了一系列的**接口规范**，是一种与厂商无关的 API，用来访问消息收发系统。它**类似于 JDBC**(Java Database Connectivity)，JDBC 是可以用来访问许多**不同关系数据库的 API**，而 JMS 则提供同样**与厂商无关的访问方法**。

JMS 使您能够通过**消息收发服务**（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。**消息**是 JMS 中的一种**类型对象**，由两部分组成：**报头**和**消息主体**。报头由**路由信息**以及**有关该消息的元数据**组成。消息主体则携带着**应用程序的数据或有效负载**。

JMS 定义了**五种不同的消息正文格式**，以及**调用的消息类型**，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。

* **TextMessage**--一个字符串对象
* **MapMessage**--一套名称-值对
* ObjectMessage--一个序列化的 Java 对象
* BytesMessage--一个字节的数据流
* StreamMessage -- Java 原始值的数据流

------

**JMS消息传递类型**

==此处的**生产者**与**消费者**和Dobbox中正好相反==

* **点对点**的，即一个生产者（如运营商后台）和一个消费者（如搜索服务或页面生成服务，但==**只能一个接收到**==）一一对应

  适用于**只需要执行一次**的，如品优购中搜索服务中导入solr；推送等

  ![点对点](images/1548444137783.png)

* **发布/ 订阅模式**，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收

  类似广播，适用于==**需要多次执行**==，如品优购中**页面生成服务**（由于部署在Nginx集群上，**并发**有多个服务，**存储同样数据**）；

  ![发布/ 订阅模式](images/1548444183797.png)



### 13.1.3 ActiveMQ使用

* [官网](http://activemq.apache.org/)下载
* 安装在Linux中
  1. 上传文件到Linux服务器：`scp apache-activemq-5.12.0-bin.tar.gz root@192.168.25.129:/root/`
  2. 解压：`tar -zxvf apache-activemq-5.12.0-bin.tar.gz`
  3. 为apache-activemq-5.12.0目录赋权：`chmod 777 apache-activemq-5.12.0`，（421权限）
  4. 进入apache-activemq-5.12.0\bin目录，赋与执行权限：`chmod 755 activemq`
  5. 启动：`./activemq start`
  6. 关闭：`./activemq stop`
  7. 进入ActiveMQ管理页面：`http://192.168.25.129:8161/`
  8. 输入用户名和密码 ，均为 admin
* **Queues**为点对点模式，Queues中信息含义如下（1+4=3）：
  * **Number Of Pending Messages**：等待消费的消息 这个是当前未出队列的数量
  * **Number Of Consumers**：当前监听（活跃）的消费者端的数量
  * **Messages Enqueued**：进入队列的消息  进入队列的总数量，包括出队列的
  * **Messages Dequeued**：出了队列的消息  可以理解为是消费这消费掉的数量
* **Topics**为订阅模式



## 13.2 JMS 入门 Demo

### 13.2.1 点对点模式

​	点对点的模式主要建立在一个**队列**上面，当连接一个列队的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息，**发送的消息，将会先进入队列中**，如果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在activemq服务器，直到接收端接收消息，点对点的消息模式**可以有多个发送端，多个接收端**，但是**一条消息，只会被一个接收端给接收到**，哪个接收端**先连上**ActiveMQ，则会先接收到，而后来的接收端则接收不到那条消息。

* 创建工程jmsDemo ，引入依赖

  ```xml
  <dependency>
      <groupId>org.apache.activemq</groupId>
      <artifactId>activemq-client</artifactId>
      <version>5.13.4</version>
  </dependency>
  ```

* 创建消息生产者类`QueueProducer`，`main()`方法代码如下（运行后在管理界面可以看到）

  * 获取session中方法的参数
    * 参数1：是否启动事务，启用则需要手动提交；不启用则自动提交
    * 参数2：消息确认模式
      * AUTO_ACKNOWLEDGE = 1    自动确认
      * CLIENT_ACKNOWLEDGE = 2    客户端手动确认
      * DUPS_OK_ACKNOWLEDGE = 3    自动批量确认
      * SESSION_TRANSACTED = 0    事务提交并确认

  ```java
  //1.创建连接工厂（此处的端口号是ActiveMQ的，不是管理界面web项目的）
  ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.129:61616");
  //2.获取连接
  Connection connection = connectionFactory.createConnection();
  //3.启动连接
  connection.start();
  //4.获取session
  //参数1：是否启动事务，启用则需要手动提交；不启用则自动提交
  //参数2：消息确认模式
  Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);		
  //5.创建队列对象
  Queue queue = session.createQueue("test-queue");
  //6.创建消息生产者
  MessageProducer producer = session.createProducer(queue);
  //7.创建消息
  TextMessage textMessage = session.createTextMessage("欢迎来到神奇的品优购世界");
  //8.发送消息
  producer.send(textMessage);
  //9.关闭资源
  producer.close();
  session.close();
  connection.close();
  ```

* 创建消息消费者类`QueueConsumer`，`main()`方法代码如下（运行后在管理界面可以看到）

  ```java
  //1.创建连接工厂
  ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.129:61616");
  //2.获取连接
  Connection connection = connectionFactory.createConnection();
  //3.启动连接
  connection.start();
  //4.获取session
  //参数1：是否启动事务，启用则需要手动提交；不启用则自动提交
  //参数2：消息确认模式
  Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
  //5.创建队列对象
  Queue queue = session.createQueue("test-queue");
  //6.创建消息消费
  MessageConsumer consumer = session.createConsumer(queue);
  //7.监听消息（lanbda
  consumer.setMessageListener(message -> {
      TextMessage textMessage=(TextMessage)message;
      try {
          System.out.println("接收到消息："+textMessage.getText());
      } catch (JMSException e) {
          e.printStackTrace();
      }
  });
  //匿名内部类方式
  /*consumer.setMessageListener(new MessageListener() {
      @Override
      public void onMessage(Message message) {
          TextMessage textMessage = (TextMessage) message;
          try {
              System.out.println("接收到消息：" + textMessage.getText());
          } catch (JMSException e) {
              e.printStackTrace();
          }
      }
  });*/
  //8.等待键盘输入，让程序保持监听状态
  System.in.read();
  //9.关闭资源
  consumer.close();
  session.close();
  connection.close();
  ```



### 13.2.2 发布/订阅模式

类似**广播**，需要当前时间处于监听状态，才可以收到

* 创建消息生产者类`TopicProducer`，`main()`方法代码如下（运行后在管理界面可以看到）

  和点对点模式差别仅仅就在第5/6步骤，创建Topic对象，传入消息生产者对象中

  ```java
  //1.创建连接工厂（此处的端口号是ActiveMQ的，不是管理界面web项目的）
  ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.129:61616");
  //2.获取连接
  Connection connection = connectionFactory.createConnection();
  //3.启动连接
  connection.start();
  //4.获取session
  //参数1：是否启动事务，启用则需要手动提交；不启用则自动提交
  //参数2：消息确认模式
  Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
  //5创建主题对象
  Topic topic = session.createTopic("test-topic");
  //6.创建消息生产者
  MessageProducer producer = session.createProducer(topic);
  //7.创建消息
  TextMessage textMessage = session.createTextMessage("欢迎来到神奇的品优购世界");
  //8.发送消息
  producer.send(textMessage);
  //9.关闭资源
  producer.close();
  session.close();
  connection.close();
  ```

* 创建消息消费者类`TopicConsumer`，`main()`方法代码如下（运行后在管理界面可以看到）

  和点对点模式差别仅仅就在第5/6步骤，创建Topic对象，传入消息消费者对象中

  ```java
  //1.创建连接工厂
  ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.129:61616");
  //2.获取连接
  Connection connection = connectionFactory.createConnection();
  //3.启动连接
  connection.start();
  //4.获取session  (参数1：是否启动事务,参数2：消息确认模式)
  Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
  
  //5.创建话题对象
  Topic topic = session.createTopic("test-topic");
  //6.创建消息消费
  MessageConsumer consumer = session.createConsumer(topic);
  
  //7.监听消息
  consumer.setMessageListener(new MessageListener() {
      @Override
      public void onMessage(Message message) {
          TextMessage textMessage = (TextMessage) message;
          try {
              System.out.println("接收到消息：" + textMessage.getText());
          } catch (JMSException e) {
              e.printStackTrace();
          }
      }
  });
  //匿名内部类方式略，参考点对点模式
  //8.等待键盘输入，让程序保持监听状态
  System.in.read();
  //9.关闭资源
  consumer.close();
  session.close();
  connection.close();
  ```

  



## 13.3 Spring JMS

* Maven中引入依赖

  ```xml
  <properties>
      <spring.version>4.2.4.RELEASE</spring.version>
  </properties>
  
  <dependencies>
      <dependency>
          <groupId>org.apache.activemq</groupId>
          <artifactId>activemq-client</artifactId>
          <version>5.13.4</version>
      </dependency>
      <dependency>
          <groupId>org.springframework</groupId>
          <artifactId>spring-jms</artifactId>
          <version>${spring.version}</version>
      </dependency>
      <dependency>
          <groupId>org.springframework</groupId>
          <artifactId>spring-test</artifactId>
          <version>${spring.version}</version>
      </dependency>
      <dependency>
          <groupId>junit</groupId>
          <artifactId>junit</artifactId>
          <version>4.9</version>
      </dependency>
  </dependencies>
  ```

* 生产者的Spring配置文件

  ```xml
  <context:component-scan base-package="cn.itcast.demo"></context:component-scan>     
  
  <!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供-->  
  <bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">  
      <property name="brokerURL" value="tcp://192.168.25.129:61616"/>  
  </bean>
  
  <!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory -->  
  <bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory">  
      <!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory -->  
      <property name="targetConnectionFactory" ref="targetConnectionFactory"/>  
  </bean>  
  
  <!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 -->  
  <bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate">  
      <!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 -->  
      <property name="connectionFactory" ref="connectionFactory"/>  
  </bean>      
  <!--这个是队列目的地，点对点的  文本信息-->  
  <bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue">  
      <constructor-arg value="queue_text"/>  
  </bean>    
  
  <!--这个是订阅模式目的地  文本信息-->  
  <bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic">  
      <constructor-arg value="topic_text"/>  
  </bean>  
  ```

* 消费者的Spring配置文件

  ```xml
  <!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供-->  
  <bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">  
      <property name="brokerURL" value="tcp://192.168.25.129:61616"/>  
  </bean>
  
  <!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory -->  
  <bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory">  
      <!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory -->  
      <property name="targetConnectionFactory" ref="targetConnectionFactory"/>  
  </bean>  
  
  <!--这个是队列目的地，点对点的  文本信息-->  
  <bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue">  
      <constructor-arg value="queue_text"/>  
  </bean>   
  
  <!--这个是订阅模式目的地  文本信息-->
  <bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic">
      <constructor-arg value="topic_text"/>
  </bean>
  
  <!-- 我的监听类 -->
  <bean id="myMessageListener" class="cn.itcast.demo.MyMessageListener"></bean>
  <!-- 消息监听容器 -->
  <bean class="org.springframework.jms.listener.DefaultMessageListenerContainer">
      <property name="connectionFactory" ref="connectionFactory" />
      <property name="destination" ref="queueTextDestination" /><!--订阅模式ref应该引用topicTextDestination-->
      <property name="messageListener" ref="myMessageListener" />
  </bean>
  ```

  

### 13.3.1 点对点模式

生产者

```java
@Component
public class QueueProducer {

    @Autowired
    private JmsTemplate jmsTemplate;

    @Autowired
    private Destination queueTextDestination;

    public void sendTextMessage(String text){
        jmsTemplate.send(queueTextDestination, session -> session.createTextMessage(text));
    	
        //传统匿名内部类方式    
    	//jmsTemplate.send(queueTextDestination, new MessageCreator() {
    	//   @Override
    	//   public Message createMessage(Session session) throws JMSException {
    	//       return session.createTextMessage(text);
    	//   }
    	//});
    }
}
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext-jms-producer.xml")
public class TestQueue {

    @Autowired
    private QueueProducer queueProducer;

    @Test
    public void testSend(){
        queueProducer.sendTextMessage("Spring JMS 点对点");
    }
}
```

消费者（根据配置文件创建监听类，自动执行）

```java
public class MyMessageListener implements MessageListener {

    @Override
    public void onMessage(Message message) {
        TextMessage textMessage = (TextMessage) message;
        try {
            System.out.println("接收到消息："+textMessage.getText());
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }
}
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext-jms-consumer.xml")
public class TestQueue {
    @Test//这个方法只是为了让程序保持监听状态
    public void testQueue(){
        try {
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



### 13.3.2 发布/订阅模式

生产者（只需修改Destination为Topic的即可）

```java
@Component
public class TopicProducer {

    @Autowired
    private JmsTemplate jmsTemplate;

    @Autowired
    private Destination topicTextDestination;

    public void sendTextMessage(String text){
        jmsTemplate.send(topicTextDestination, session -> session.createTextMessage(text));
    }
}
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext-jms-producer.xml")
public class TestTopic {

    @Autowired
    private TopicProducer topicProducer;

    @Test
    public void testSend(){
        topicProducer.sendTextMessage("Spring JMS 发布订阅");
    }
}
```

消费者（根据配置文件创建监听类，自动执行），与点对点模式代码完全一样

```java
public class MyMessageListener implements MessageListener {

    @Override
    public void onMessage(Message message) {
        TextMessage textMessage = (TextMessage) message;
        try {
            System.out.println("接收到消息："+textMessage.getText());
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }
}
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext-jms-consumer.xml")
public class TestQueue {
    @Test//这个方法只是为了让程序保持监听状态
    public void testQueue(){
        try {
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```







## 13.4 商品审核-导入Solr索引库（点对点）

> 运用消息中间件activeMQ实现运营商后台与搜索服务的零耦合。运营商执行商品审核后，向activeMQ发送消息（SKU列表），搜索服务从activeMQ接收到消息并导入到solr索引库。

### 13.4.1 消息生产者（运营商后台）

* Maven中移除耦合依赖`pinyougou-search-interface`，`GoodsController`中删除调用搜索服务接口的相关代码（主要在**删除**和**审核**的方法中）

* 在`pinyougou-manager-web`中引入`activemq-client`和`spring-jms`依赖

* 生产者的配置文件

  ```xml
  <!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供-->  
  <bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">  
      <property name="brokerURL" value="tcp://192.168.25.129:61616"/>  
  </bean>
  
  <!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory -->  
  <bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory">  
      <!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory -->  
      <property name="targetConnectionFactory" ref="targetConnectionFactory"/>  
  </bean>  
  
  <!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 -->  
  <bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate">  
      <!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 -->  
      <property name="connectionFactory" ref="connectionFactory"/>  
  </bean>   
  
  <!--这个是队列目的地，点对点的。导入solr索引库-->
  <bean id="queueSolrDestination" class="org.apache.activemq.command.ActiveMQQueue">
      <constructor-arg value="pinyougou_queue_solr"/>
  </bean>
  
  <!--这个是队列目的地，点对点的。删除solr索引库-->
  <bean id="queueSolrDeleteDestination" class="org.apache.activemq.command.ActiveMQQueue">
      <constructor-arg value="pinyougou_queue_solr_delete"/>
  </bean>
  
  <!--这个是订阅模式，生成静态页面-->
  <bean id="topicPageDestination" class="org.apache.activemq.command.ActiveMQTopic">
      <constructor-arg value="pinyougou_topic_page"/>
  </bean>
  
  <!--这个是订阅模式，删除商品详情静态页-->
  <bean id="topicPageDeleteDestination" class="org.apache.activemq.command.ActiveMQTopic">
      <constructor-arg value="pinyougou_topic_page_delete"/>
  </bean>
  ```

* 修改`GoodsController`

  ```java
  @Autowired
  private JmsTemplate jmsTemplate;
  
  @Autowired
  private Destination queueSolrDestination;//用于导入solr索引库的消息目标（点对点）
  
  @Autowired
  private Destination queueSolrDeleteDestination;//用于删除solr索引库的消息目标（点对点）
  
  @Autowired
  private Destination topicPageDestination;//用于生成商品详细静态页消息目标（发布/订阅）
  
  @Autowired
  private Destination topicPageDeleteDestination;//用于删除商品详细静态页消息目标（发布/订阅）
  
  
  @RequestMapping("/updateStatus")
  public Result updateStatus(Long[] ids, String status){
      try {
          goodsService.updataStatus(ids,status);
          if ("1".equals(status)){ //审核通过
  
              //=====1.利用ActiveMQ发送消息导入到solr索引库中=====
              //需要导入的SKU列表
              final List<TbItem> list = goodsService.findItemListByGoodsIdListAndStatus(ids, "1");
              //发送消息（转为JSON字符串发送。List没有实现可序列化接口，不能传递对象消息）
              jmsTemplate.send(queueSolrDestination, new MessageCreator() {
                  @Override
                  public Message createMessage(Session session) throws JMSException {
                      String jsonString = JSON.toJSONString(list);
                      return session.createTextMessage(jsonString);
                  }
              });
  
              //=====2.通过ActiveMQ发送消息，生成商品详细静态页面=====
              for (final Long id : ids) {
                  jmsTemplate.send(topicPageDestination, new MessageCreator() {
                      @Override
                      public Message createMessage(Session session) throws JMSException {
                          return session.createTextMessage(id+"");//因为要传入String类型
                      }
                  });
              }
          }
          return new Result(true,"修改成功");
      } catch (Exception e) {
          e.printStackTrace();
          return new Result(false,"修改失败");
  
      }
  }
  
  
  
  @RequestMapping("/delete")
  public Result delete(final Long [] ids){
      try {
          //利用ActiveMQ发送消息从索引库中删除
          jmsTemplate.send(queueSolrDeleteDestination, new MessageCreator() {
              @Override
              public Message createMessage(Session session) throws JMSException {
                  return session.createObjectMessage(ids);//Long实现了可序列化接口
              }
          });
  
          //删除每个服务器（Nginx集群）上的商品详情静态页
          jmsTemplate.send(topicPageDeleteDestination, new MessageCreator() {
              @Override
              public Message createMessage(Session session) throws JMSException {
                  return session.createObjectMessage(ids);//Long实现了可序列化接口
              }
          });
  
          goodsService.delete(ids);//只是逻辑删除
          return new Result(true, "删除成功"); 
      } catch (Exception e) {
          e.printStackTrace();
          return new Result(false, "删除失败");
      }
  }
  
  ```

  

### 13.4.2 消息消费者（搜索服务）

* 在`pinyougou-search-service`中引入`activemq-client`和`spring-jms`依赖

* 消费者的配置文件

  ```xml
  <!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供-->  
  <bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">  
      <property name="brokerURL" value="tcp://192.168.25.129:61616"/>  
  </bean>
  
  <!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory -->  
  <bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory">  
      <!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory -->  
      <property name="targetConnectionFactory" ref="targetConnectionFactory"/>  
  </bean>  
  
  <!--这个是队列目的地，点对点的。导入索引库-->
  <bean id="queueSolrDestination" class="org.apache.activemq.command.ActiveMQQueue">
      <constructor-arg value="pinyougou_queue_solr"/>
  </bean>
  <!-- 消息监听容器，导入索引库 -->
  <bean class="org.springframework.jms.listener.DefaultMessageListenerContainer">
      <property name="connectionFactory" ref="connectionFactory" />
      <property name="destination" ref="queueSolrDestination" />
      <property name="messageListener" ref="itemSearchListener" />
  </bean>
  
  <!--这个是队列目的地，点对点的。删除索引库-->
  <bean id="queueSolrDeleteDestination" class="org.apache.activemq.command.ActiveMQQueue">
      <constructor-arg value="pinyougou_queue_solr_delete"/>
  </bean>
  <!-- 消息监听容器，删除索引库 -->
  <bean class="org.springframework.jms.listener.DefaultMessageListenerContainer">
      <property name="connectionFactory" ref="connectionFactory" />
      <property name="destination" ref="queueSolrDeleteDestination" />
      <property name="messageListener" ref="itemDeleteListener" />
  </bean>
  ```

* 消息监听类

  ```java
  @Component
  public class ItemSearchListener implements MessageListener {
  
      @Autowired
      private ItemSearchService itemSearchService;
  
      @Override
      public void onMessage(Message message) {
          TextMessage textMessage = (TextMessage) message;
          try {
              String text = textMessage.getText();//JSON字符串
              System.out.println("监听到消息："+text);
              List<TbItem> tbItems = JSON.parseArray(text, TbItem.class);
              itemSearchService.importList(tbItems);
              System.out.println("导入到solr索引库");
          } catch (JMSException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  ```java
  @Component
  public class ItemDeleteListener implements MessageListener {
      @Autowired
      private ItemSearchService itemSearchService;
  
      @Override
      public void onMessage(Message message) {
          ObjectMessage objectMessage = (ObjectMessage) message;
          try {
              Long[] goodsIds = (Long[]) objectMessage.getObject();
              System.out.println("监听到消息："+goodsIds);
              itemSearchService.deleteByGoodsIds(Arrays.asList(goodsIds));
              System.out.println("执行索引库删除");
          } catch (JMSException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  





## 13.5 商品审核-网页静态化（发布/订阅）

> 运用消息中间件activeMQ实现运营商后台与网页生成服务的零耦合。运营商执行商品审核后，向activeMQ发送消息（商品ID），网页生成服务从activeMQ接收到消息后执行网页生成操作

![1548533430740](images/1548533430740.png)

### 13.5.1 消息生产者（运营商后台）

* Maven中移除耦合依赖`pinyougou-page-interface`，`GoodsController`中删除调用搜索服务接口的相关代码（主要在**删除**和**审核**的方法中）
* 其他的看13.4.1



### 13.5.2 消息消费者（页面生成服务）

* Maven中移除耦合依赖**`dubbox`**。配置文件中dubbox的service配置也删除，同时将`@Service`注解改用Spring的，包扫描

  ```xml
  <context:component-scan base-package="com.pinyougou.page.service.impl"/>
  ```

* 在`pinyougou-page-service`中引入`activemq-client`和`spring-jms`依赖

* 消费者的配置文件

  ```xml
  <!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供-->  
  <bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">  
      <property name="brokerURL" value="tcp://192.168.25.129:61616"/>  
  </bean>
  
  <!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory -->  
  <bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory">  
      <!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory -->  
      <property name="targetConnectionFactory" ref="targetConnectionFactory"/>  
  </bean>  
  
  <!--这个是队列目的地，发布订阅模式，生成页面-->
  <bean id="topicPageDestination" class="org.apache.activemq.command.ActiveMQTopic">
      <constructor-arg value="pinyougou_topic_page"/>
  </bean>
  <!-- 消息监听容器，生成页面 -->
  <bean class="org.springframework.jms.listener.DefaultMessageListenerContainer">
      <property name="connectionFactory" ref="connectionFactory" />
      <property name="destination" ref="topicPageDestination" />
      <property name="messageListener" ref="pageListener" />
  </bean>
  
  <!--这个是队列目的地，发布订阅模式，删除-->
  <bean id="topicPageDeleteDestination" class="org.apache.activemq.command.ActiveMQTopic">
      <constructor-arg value="pinyougou_topic_page_delete"/>
  </bean>
  <!-- 消息监听容器，删除页面 -->
  <bean class="org.springframework.jms.listener.DefaultMessageListenerContainer">
      <property name="connectionFactory" ref="connectionFactory" />
      <property name="destination" ref="topicPageDeleteDestination" />
      <property name="messageListener" ref="pageDeleteListener" />
  </bean>
  ```

* 消息监听类

  ```java
  @Component
  public class PageListener implements MessageListener {
      @Autowired
      private ItemPageService itemPageService;
  
      @Override
      public void onMessage(Message message) {
          TextMessage textMessage = (TextMessage) message;
          try {
              String text = textMessage.getText();
              System.out.println("接收到的消息："+text);
              boolean b = itemPageService.genItemHtml(Long.parseLong(text));
              System.out.println("网页生成结果："+b);
          } catch (JMSException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  ```java
  @Component
  public class PageDeleteListener implements MessageListener {
  
      @Autowired
      private ItemPageService itemPageService;
      @Override
      public void onMessage(Message message) {
          ObjectMessage objectMessage = (ObjectMessage) message;
          try {
              Long[] goodsIds = (Long[]) objectMessage.getObject();
              System.out.println("接收到消息："+goodsIds);
              boolean b = itemPageService.deleteItemHtml(goodsIds);
              System.out.println("删除网页"+b);
          } catch (JMSException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  



## 13.6 商品删除-删除商品详细页（发布/订阅）

### 13.6.1 消息生产者（运营商后台）

* 配置文件及代码查看13.4.1

### 13.6.2 消息消费者（页面生成服务）

* 配置文件及代码查看13.5.2

* 需要在`ItemPageServiceImpl`添加删除的方法

  ```java
  @Override
  public boolean deleteItemHtml(Long[] goodsIds) {
      try {
          for (Long goodsId : goodsIds) {
              new File(pagedir+goodsId+".html").delete();
          }
          return true;
      } catch (Exception e) {
          e.printStackTrace();
          return false;
      }
  }
  ```

  



# 14 Spring Boot与短信解决方案

![1548615453022](images/1548615453022.png)



## 14.1 Spring Boot入门

### 14.1.1 Demo

和之前的Maven工程打包方式不同，无论时什么Spring Boot工程都是jar包

* 启动器：`spring-boot-start-*`

* `<properties>`标签中直接指定Java版本`<java.version>1.8</java.version>`

  ```xml
  <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-parent</artifactId>
      <version>2.1.2.RELEASE</version>
      <relativePath/> <!-- lookup parent from repository -->
  </parent>
  <properties>
      <java.version>1.8</java.version>
  </properties>
  <dependencies>
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
      </dependency>
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-devtools</artifactId><!--热部署插件-->
      </dependency>
  </dependencies>
  ```

  使用IDEA并使用热部署插件，不会自动重启，需要**手动make**或者**Debug模式启动**，或者**修改IDEA的配置**

  1. ![1548621994782](images/1548621994782.png)

  2. Shift+Ctrl+Alt+/(Mac: Shift+Command+Alt+/)，选择Registry...

     ![1548622074174](images/1548622074174.png)

* 启动类

  ```java
  //@SpringBootApplication其实就是以下三个注解的总和：@Configuration，@EnableAutoConfiguration，@ComponentScan
  //但是@ComponentScan默认扫描当前类所在包
  @SpringBootApplication
  public class DemoApplication {
  
      public static void main(String[] args) {
          SpringApplication.run(DemoApplication.class, args);
      }
  }
  ```

* 配置文件`application.properties`，可以修改Tomcat端口等。也可以自定义配置（通过**`Environment`**获取）。

  ```properties
  #Tomcat端口
  server.port=80
  
  #自定义配置
  url=http://www.itcast.com
  ```

* Web开发

  ```java
  @RestController
  public class HelloWorldController {
  
      @Autowired
      private Environment environment;
  
      @RequestMapping("/hello")
      public String  hello(){
          return "hello world spring boot! "+environment.getProperty("url");
      }
  }
  ```

  

### 14.1.2 Spring Boot与ActiveMQ整合

* 引入activemq的starter（启动器）

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-activemq</artifactId>
  </dependency>
  ```

* 使用**内置/外置ActiveMQ**的点对点模式

  要使用外置ActiveMQ，只需在`application.properties`中添加

  `spring.activemq.broker-url=tcp://192.168.25.129:61616`即可完成

  ```java
  //消息生产者
  @RestController
  public class QueueController {
  
      @Autowired
      private JmsMessagingTemplate jmsMessagingTemplate;
  
      @RequestMapping("/send")
      public void send(String text){
          jmsMessagingTemplate.convertAndSend("itcast",text);//第一个参数为队列目的地，不指定默认为Queue
      }
  
      @RequestMapping("/sendMap")
      public void sendMap(){
          Map map = new HashMap();
          map.put("mobile",10086);
          map.put("content","新年好！");
          jmsMessagingTemplate.convertAndSend("itcast_map",map);//第一个参数为队列目的地对象，不指定默认为Queue
      }
  }
  ```

  ```java
  @Component
  public class Consumer {
  
      @JmsListener(destination = "itcast")//监听队列的目的地
      public void readMessage(String text){
          System.out.println("接收到消息："+text);
      }
  
      @JmsListener(destination = "itcast_map")//监听队列的目的地
      public void readMapMessage(Map map){
          System.out.println("接收到消息了："+map);
      }
  }
  ```


* **发布/订阅模式**（暂时参考）

  发布端口代码

  ```java
  @Service
  public class Publisher {
  
      @Resource
      private JmsMessagingTemplate jmsMessagingTemplate;
  
      public void publish(String destName, Object message) {
          //开启订阅模式
          jmsTemplate.setPubSubDomain(true);
          Destination destination = new ActiveMQTopic(destName);
          jmsMessagingTemplate.convertAndSend(destination, message);
      }
  }
  ```

  订阅端口代码

  对于订阅者来说需要考虑一个事情：当发布消息的时候订阅端挂了，那么这个消息需要在订阅者下次启动的时候去消费。

  ```java
  @Configuration
  public class JmsConfig {
      @Bean
      JmsListenerContainerFactory<?> myJmsListenerContainerFactory(ConnectionFactory connectionFactory) {
          SimpleJmsListenerContainerFactory simpleJmsListenerContainerFactory = new SimpleJmsListenerContainerFactory();
          simpleJmsListenerContainerFactory.setConnectionFactory(connectionFactory);
          //开启订阅模式
          simpleJmsListenerContainerFactory.setPubSubDomain(true);
          //开启持久化订阅,订阅端不在线能保持未消费的消息
          simpleJmsListenerContainerFactory.setClientId("yuxi");//区分不同的订阅者
          simpleJmsListenerContainerFactory.setSubscriptionDurable(true);//设置了持久化订阅
          return simpleJmsListenerContainerFactory;
      }
  }
  ```

  ```java
  @Service
  public class Subscriber {
  
      @JmsListener(destination = "test.topic", containerFactory = "myJmsListenerContainerFactory")
      public void subscriber(Object obj) {
          try {
              //接受对象消息
              if (obj instanceof ActiveMQObjectMessage) {
                  Object sourObj = ((ActiveMQObjectMessage) obj).getObject();
                  if (sourObj instanceof Tenant)
                      System.out.println("收到订阅消息：" + sourObj);
              }
          } catch (JMSException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  

  

  

## 14.2 短信发送平台-阿里云通信

> 由阿里大于改名

登录阿里云—>阿里云通信—>短信服务，设置签名和模板等信息。按照快速学习指导及API的Demo即可完成。



### 14.2.1 短信微服务

> 构建一个**通用的短信发送微服务**（独立于品优购的**单独工程**），接收activeMQ的消息（Map类型）  消息包括手机号（mobile）、短信模板号（template_code）、签名（sign_name）、参数字符串（param ）

* Maven依赖

  ```xml
  <properties>
      <java.version>1.8</java.version>
  </properties>
  
  <dependencies>
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
      </dependency>
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-activemq</artifactId>
      </dependency>
      <dependency>
          <groupId>com.aliyun</groupId>
          <artifactId>aliyun-java-sdk-core</artifactId>
          <version>4.0.3</version>
      </dependency>
      <dependency>
          <groupId>com.aliyun</groupId>
          <artifactId>aliyun-java-sdk-dysmsapi</artifactId>
          <version>1.1.0</version>
      </dependency>
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-devtools</artifactId>
          <scope>runtime</scope>
      </dependency>
  </dependencies>
  ```

* application配置文件

  ```properties
  server.port=9003
  spring.activemq.broker-url=tcp://192.168.25.129:61616
  accessKeyId=不告诉你
  accessKeySecret=不告诉你
  ```

* **ActiveMQ监听类**（调用发送短信工具类）

  ```java
  @Component
  public class SmsListener {
      @Autowired
      private SmsUtil smsUtil;
      
      @JmsListener(destination="sms")
      public void sendSms(Map<String,String> map){		
          try {
              SendSmsResponse response = smsUtil.sendSms(
                  map.get("mobile"), 
                  map.get("template_code"),
                  map.get("sign_name"),
                  map.get("param")  );					 
              System.out.println("Code=" + response.getCode());
              System.out.println("Message=" + response.getMessage());
              System.out.println("RequestId=" + response.getRequestId());
              System.out.println("BizId=" + response.getBizId());			
          } catch (ClientException e) {
              e.printStackTrace();			
          }		
      }
  }
  ```

* 发送短信工具类（阿里云通信）

  ```java
  @Component
  public class SmsUtil {
  
      //产品名称:云通信短信API产品,开发者无需替换
      static final String product = "Dysmsapi";
      //产品域名,开发者无需替换
      static final String domain = "dysmsapi.aliyuncs.com";
  
      @Autowired
      private Environment env;
      /**
       * 发送短信
       * @param mobile 手机号
       * @param template_code 模板号
       * @param sign_name 签名
       * @param param 参数
       * @return
       * @throws ClientException
       */
      public SendSmsResponse sendSms(String mobile,String template_code,String sign_name,String param) throws ClientException {
  
          String accessKeyId =env.getProperty("accessKeyId");
          String accessKeySecret = env.getProperty("accessKeySecret");
  
          //可自助调整超时时间
          System.setProperty("sun.net.client.defaultConnectTimeout", "10000");
          System.setProperty("sun.net.client.defaultReadTimeout", "10000");
  
          //初始化acsClient,暂不支持region化
          IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret);
          DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain);
          IAcsClient acsClient = new DefaultAcsClient(profile);
  
          //组装请求对象-具体描述见控制台-文档部分内容
          SendSmsRequest request = new SendSmsRequest();
          //必填:待发送手机号
          request.setPhoneNumbers(mobile);
          //必填:短信签名-可在短信控制台中找到
          request.setSignName(sign_name);
          //必填:短信模板-可在短信控制台中找到
          request.setTemplateCode(template_code);
          //可选:模板中的变量替换JSON串,如模板内容为"亲爱的${name},您的验证码为${code}"时,此处的值为
          request.setTemplateParam(param);
  
          //选填-上行短信扩展码(无特殊需求用户请忽略此字段)
          //request.setSmsUpExtendCode("90997");
  
          //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者
          request.setOutId("yourOutId");
  
          //hint 此处可能会抛出异常，注意catch
          SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request);
  
          return sendSmsResponse;
      }
  
      public  QuerySendDetailsResponse querySendDetails(String mobile,String bizId) throws ClientException {
          String accessKeyId =env.getProperty("accessKeyId");
          String accessKeySecret = env.getProperty("accessKeySecret");
          //可自助调整超时时间
          System.setProperty("sun.net.client.defaultConnectTimeout", "10000");
          System.setProperty("sun.net.client.defaultReadTimeout", "10000");
          //初始化acsClient,暂不支持region化
          IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret);
          DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain);
          IAcsClient acsClient = new DefaultAcsClient(profile);
          //组装请求对象
          QuerySendDetailsRequest request = new QuerySendDetailsRequest();
          //必填-号码
          request.setPhoneNumber(mobile);
          //可选-流水号
          request.setBizId(bizId);
          //必填-发送日期 支持30天内记录查询，格式yyyyMMdd
          SimpleDateFormat ft = new SimpleDateFormat("yyyyMMdd");
          request.setSendDate(ft.format(new Date()));
          //必填-页大小
          request.setPageSize(10L);
          //必填-当前页码从1开始计数
          request.setCurrentPage(1L);
          //hint 此处可能会抛出异常，注意catch
          QuerySendDetailsResponse querySendDetailsResponse = acsClient.getAcsResponse(request);
          return querySendDetailsResponse;
      }
  }
  ```

  



## 14.3 用户注册

> 此次注册的用户名和密码为：xiaobai/123123

用户服务接口层

1. 创建pinyougou-user-interface（jar）
2. 引入pojo依赖

用户服务实现层

1. 创建pinyougou-user-service（war）

2. 引入spring  dubbox   activeMQ相关依赖，引入依赖（ pinyougou-user-interface  pinyougou-dao  pinyougou-common），运行端口为9006

3. 添加web.xml  

4. 创建Spring 配置文件applicationContext-service.xml 和applicationContent-tx.xml 

   ```xml
   <dubbo:protocol name="dubbo" port="20886" />
   <dubbo:annotation package="com.pinyougou.user.service.impl" />  
   <dubbo:application name="pinyougou-user-service"/>  
   <dubbo:registry address="zookeeper://192.168.25.135:2181"/>
   ```

5. **ActiveMQ配置文件**参考上面的配置即可

用户中心WEB层

1. 创建war工程  pinyougou-user-web 我们将注册功能放入此工程
2. 添加web.xml 
3. 引入依赖pinyougou-user-interface 、spring相关依赖（参照其它web工程）,tomcat运行端口9106
4. 添加spring配置文件
5. 拷贝静态原型页面register.html 及相关资源 

------

==**验证码思路**==

1. 点击页面上的”**获取短信验证码**”链接，向后端**传递手机号**。后端随机生成6位数字作为短信验证码，将其**保存在redis中**（手机号作为key），并发送到ActiveMQ。
2. 用户**注册**时，后端**根据手机号查询redis中的验证码**与用户**填写的验证码**是否相同，如果不同则提示用户不能注册。

------

`UserController`

```java
//发送验证码
@RequestMapping("/sendCode")
public Result sendCode(String phone){
    if (!PhoneFormatCheckUtils.isPhoneLegal(phone)){//利用这个工具类提供的正则表达式校验手机号
        return new Result(false,"手机号格式不正确");
    }
    try {
        userService.createSmsCode(phone);
        return new Result(true,"验证码发送成功");
    } catch (Exception e) {
        e.printStackTrace();
        return new Result(false,"验证码发送失败");

    }
}

//注册（判断验证码后决定是否注册）
@RequestMapping("/add")
public Result add(@RequestBody TbUser user,String smscode){
    //校验验证码
    boolean b = userService.checkSmsCode(user.getPhone(), smscode);
    if (!b){
        return new Result(false, "验证码错误");
    }
    try {
        userService.add(user);
        return new Result(true, "增加成功");
    } catch (Exception e) {
        e.printStackTrace();
        return new Result(false, "增加失败");
    }
}
```

`UserServiceImpl`（MD5加密）

```java
@Autowired
private RedisTemplate redisTemplate;

@Autowired
private JmsTemplate jmsTemplate;

@Autowired
private Destination smsDestination;//也可以new出来

@Value("${template_code}")
private String template_code;//在common模块中存放的配置文件，并且已经由spring加载了

@Value("${sign_name}")
private String sign_name;

//发送验证码
@Override
public void createSmsCode(final String phone) {
    //1.生成6位随机数验证码
    Random random = new Random();
    final String smscode = random.nextInt(1000000)+"";
    System.out.println("验证码："+smscode);
    //2.将验证码放入Redis缓存
    redisTemplate.boundHashOps("smscode").put(phone,smscode);
    //3.将短信内容发送到ActiveMQ
    jmsTemplate.send(smsDestination, new MessageCreator() {
        @Override
        public Message createMessage(Session session) throws JMSException {
            MapMessage mapMessage = session.createMapMessage();
            mapMessage.setString("mobile",phone);//手机号
            mapMessage.setString("template_code",template_code);//模板
            mapMessage.setString("sign_name",sign_name);//签名
            Map map = new HashMap();
            map.put("number",smscode);
            mapMessage.setString("param", JSON.toJSONString(map));//验证码
            return mapMessage;
        }
    });

}

//判断验证码是否正确
@Override
public boolean checkSmsCode(String phone, String smscode) {
    String  redisSmsCode = (String) redisTemplate.boundHashOps("smscode").get(phone);
    if (redisSmsCode==null){
        return false;
    }
    if (!smscode.equals(redisSmsCode)){
        return false;
    }
    return true;
}

//验证码正确就注册
@Override
public void add(TbUser user) {
    user.setCreated(new Date());//用户注册时间
    user.setUpdated(new Date());//修改时间
    user.setSourceType("1");//用户来源
    user.setPassword(DigestUtils.md5Hex(user.getPassword()));//org.apache.commons...MD5加密
    userMapper.insert(user);
}
```

前端服务层/控制层/HTML中绑定变量并调用发送验证码方法和注册方法（验证码单独绑定，不在entity中）

```java
this.sendCode = function (phone) {
    $http.get('../user/sendCode.do?phone='+phone);
}
this.add=function(entity){
    return  $http.post('../user/add.do',entity );
}
```

```js
//控制层 
app.controller('userController' ,function($scope,$controller   ,userService){

    //发送验证码
    $scope.sendCode = function () {
        if ($scope.entity.phone==null || $scope.entity.phone == ""){
            alert("请填写手机号！");
            return;
        }
        userService.sendCode($scope.entity.phone).success(function (data) {
            alert(data.message);
        })
    }

    //注册（后端会判断验证码是否正确）
    $scope.reg = function () {

        if ($scope.entity.password!=$scope.password){
            alert("两次输入密码不一致");
            return;
        }
        userService.add($scope.entity,$scope.smscode).success(function (data) {
            alert(data.message);
        })
    }
});	
```





# 15 单点登录解决方案 CAS

![1548947245390](images/1548947245390.png)

> 单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
>
> 我们目前的系统存在诸多子系统，而这些子系统是分别部署在不同的服务器中，那么使用传统方式的session是无法解决的，我们需要使用相关的单点登录技术来解决。

## 15.1 CAS 入门

### 15.1.1 CAS 简介

CAS 是 Yale 大学发起的一个开源项目，旨在为 Web 应用系统提供一种可靠的单点登录方法，CAS 在 2004 年 12 月正式成为 JA-SIG 的一个项目。CAS 具有以下特点：

* 开源的企业级单点登录解决方案。
* CAS Server 为需要独立部署的 Web 应用。
* CAS Client 支持非常多的客户端(这里指单点登录系统中的各个 Web 应用)，包括 Java, .Net, PHP, Perl, Apache, uPortal, Ruby 等。

从结构上看，CAS 包含两个部分： CAS Server 和 CAS Client。CAS Server 需要独立部署，主要负责对用户的认证工作；CAS Client 负责处理对客户端受保护资源的访问请求，需要登录时，重定向到 CAS Server。下图是 CAS 最基本的协议过程：

![](images/CAS 最基本的协议过程.png)

SSO单点登录访问流程主要有以下步骤：

1. 访问服务：SSO客户端发送请求访问应用系统提供的服务资源。
2. 定向认证：SSO客户端会重定向用户请求到SSO服务器。
3. 用户认证：用户身份认证。
4. 发放票据：SSO服务器会产生一个随机的Service Ticket。
5. 验证票据：SSO服务器验证票据Service Ticket的合法性，验证通过后，允许客户端访问服务。
6. 传输用户信息：SSO服务器验证票据通过后，传输用户认证结果信息给客户端。



### 15.1.2 CAS服务端部署

Cas服务端其实就是一个war包，在资源`\cas\source\cas-server-4.0.0-release\cas-server-4.0.0\modules`目录下。将其改名为cas.war放入tomcat目录下的webapps下，启动并键入`http://localhost:8080/cas/login`即可看到CAS自带的简单登录界面。默认的用户名和密码为：casuser /Mellon。可以在`\cas\WEB-INF\deployerConfigContext.xml`中修改添加。

后续可修改数据源为数据库。



### 15.1.3 CAS服务端配置

* 端口修改

  * 修改Tomcat端口为**9100**，在`conf\server.xml`中（这里只改一处，一般情况要改2处）
  * 修改CAS配置文件，在`WEB-INF/cas.properties`中，修改为`server.name=http://localhost:9100`

* 去除HTTPS认证

  CAS默认使用的是HTTPS协议，如果使用HTTPS协议需要SSL安全证书（需向特定的机构申请和购买） 。如果对安全要求不高或是在开发测试阶段，可使用HTTP协议。我们这里讲解通过修改配置，让CAS使用HTTP协议。

  * 修改cas的`WEB-INF/deployerConfigContext.xml`

    ```xml
    <bean id="proxyAuthenticationHandler"
         class="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler"
          p:httpClient-ref="httpClient" p:requireSecure="false"/>
    <!--增加参数p:requireSecure="false"，该属性意思为是否需要安全验证，即HTTPS，false为不采用-->
    ```

  * 修改cas的`/WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml`

    ```xml
    <bean id="ticketGrantingTicketCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator"
          p:cookieSecure="true"
          p:cookieMaxAge="-1"
          p:cookieName="CASTGC"
          p:cookiePath="/cas" />
    <!--
    	参数p:cookieSecure="true"，同理为HTTPS验证相关，TRUE为采用HTTPS验证，FALSE为不采用https验证。
    	参数p:cookieMaxAge="-1"，是COOKIE的最大生命周期，-1为无生命周期，即只在当前打开的窗口有效，关闭或重新打开其它窗口，仍会要求验证。可以根据需要修改为大于0的数字，比如3600等，意思是在3600秒内，打开任意窗口，都不需要验证。
    	我们这里将cookieSecure改为false ,  cookieMaxAge 改为3600
    -->
    ```

  * 修改cas的`WEB-INF/spring-configuration/warnCookieGenerator.xml`

    ```xml
    <bean id="warnCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator"
          p:cookieSecure="true"
          p:cookieMaxAge="-1"
          p:cookieName="CASPRIVACY"
          p:cookiePath="/cas" />
    <!-- 我们这里将cookieSecure改为false ,  cookieMaxAge 改为3600 -->
    ```

    

### 15.1.4 CAS 客户端入门 Demo

#### 1、两个war工程

1. 创建Maven工程（**war**）casclient_demo1  引入cas客户端依赖并制定tomcat运行**端口**为9001

   ```xml
   <dependency>  
       <groupId>org.jasig.cas.client</groupId>  
       <artifactId>cas-client-core</artifactId>  
       <version>3.3.3</version>  
   </dependency>
   <!--这个Demo使用JSP，需引入JSP依赖-->
   ```

2. `web.xml`

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="http://java.sun.com/xml/ns/javaee"
            xsi:schemaLocation="http://java.sun.com/xml/ns/javaee"
            version="2.5">	
       <!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置 -->  
       <listener>  
           <listener-class>org.jasig.cas.client.session.SingleSignOutHttpSessionListener</listener-class>  
       </listener>  
       <!-- 该过滤器用于实现单点登出功能，可选配置。 -->  
       <filter>  
           <filter-name>CAS Single Sign Out Filter</filter-name>  
           <filter-class>org.jasig.cas.client.session.SingleSignOutFilter</filter-class>  
       </filter>  
       <filter-mapping>  
           <filter-name>CAS Single Sign Out Filter</filter-name>  
           <url-pattern>/*</url-pattern>  
       </filter-mapping>  
       
       
       <!-- 该过滤器负责用户的认证工作，必须启用它 -->  
       <filter>  
           <filter-name>CASFilter</filter-name>       <filter-class>org.jasig.cas.client.authentication.AuthenticationFilter</filter-class>  
           <init-param>  
               <param-name>casServerLoginUrl</param-name>  
               <param-value>http://localhost:9100/cas/login</param-value>  
               <!--这里的server是服务端的IP -->  
           </init-param>  
           <init-param>  
               <param-name>serverName</param-name>  
               <param-value>http://localhost:9001</param-value>
           </init-param>  
       </filter>  
       <filter-mapping>  
           <filter-name>CASFilter</filter-name>  
           <url-pattern>/*</url-pattern>  
       </filter-mapping>  
       
       
       <!-- 该过滤器负责对Ticket的校验工作，必须启用它 -->  
       <filter>  
           <filter-name>CAS Validation Filter</filter-name>  
           <filter-class>     org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter</filter-class>  
           <init-param>  
               <param-name>casServerUrlPrefix</param-name>  
               <param-value>http://localhost:9100/cas</param-value>  
           </init-param>  
           <init-param>  
               <param-name>serverName</param-name>  
               <param-value>http://localhost:9001</param-value>
           </init-param>  
       </filter>  
       <filter-mapping>  
           <filter-name>CAS Validation Filter</filter-name>  
           <url-pattern>/*</url-pattern>  
       </filter-mapping>  
       
       <!-- 该过滤器负责实现HttpServletRequest请求的包裹， 比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。 -->  
       <filter>  
           <filter-name>CAS HttpServletRequest Wrapper Filter</filter-name>  
           <filter-class>  
               org.jasig.cas.client.util.HttpServletRequestWrapperFilter</filter-class>  
       </filter>  
       <filter-mapping>  
           <filter-name>CAS HttpServletRequest Wrapper Filter</filter-name>  
           <url-pattern>/*</url-pattern>  
       </filter-mapping>  
       <!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 -->  
       <filter>  
           <filter-name>CAS Assertion Thread Local Filter</filter-name>       <filter-class>org.jasig.cas.client.util.AssertionThreadLocalFilter</filter-class>  
       </filter>  
       <filter-mapping>  
           <filter-name>CAS Assertion Thread Local Filter</filter-name>  
           <url-pattern>/*</url-pattern>  
       </filter-mapping>  
   </web-app>
   ```

3. `index.jsp`

   ```jsp
   <%@ page language="java" contentType="text/html; charset=utf-8"
       pageEncoding="utf-8"%>
   <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
   <html>
       <head>
           <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
           <title>一品优购</title>
       </head>
       <body>
           欢迎来到一品优购
           <%=request.getRemoteUser()%>
           <a href="http://localhost:9100/cas/logout?service=http://www.baidu.com">退出登录</a>
       </body>
   </html>
   ```

4. 客户端工程2搭建同上，需要修改pom.xml和web.xml中客户端端口为**9002**

5. 启动客户端1和2，键入`http://localhost:9001/`或`http://localhost:9002/`均会跳转到CAS登录页，其中一个输入正确用户名密码后，另一个就不用登录了，直接登录成功。

   

#### 2、单点退出登录

地址栏输入**`http://localhost:9000/cas/logout`**即可单点退出登录（放在注销按钮即可），并能看到退出后CAS的提示页面。

希望退出后**跳转（重定向）**到指定的页面，需要修改cas系统的配置文件`cas-servlet.xml`

```xml
<bean id="logoutAction" class="org.jasig.cas.web.flow.LogoutAction"
      p:servicesManager-ref="servicesManager"
      p:followServiceRedirects="${cas.logout.followServiceRedirects:true}"/> <!--改为true-->
```

退出登录的连接需要**传递`service`参数**，告诉重定向的URL。查看1中index.jsp页面代码



#### 3、CAS服务端数据源设置

> 我们现在让用户名密码从我们的品优购的user表里做验证

1. 修改cas服务端中`WEB-INF/deployerConfigContext.xml` ，添加如下配置

   将jar包放入服务端`WEB-INF\lib`中：`cas-server-support-jdbc-4.0.0`、`c3p0-0.9.1.2`、`mysql-connector-java`

   ```XML
   <!--3308端口是自己修改的MySQL8-->
   <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"  
         p:driverClass="com.mysql.jdbc.Driver"  
         p:jdbcUrl="jdbc:mysql://127.0.0.1:3308/pinyougoudb?serverTimezone=GMT%2B8"
         p:user="root"  
         p:password="w111151" /> 
   <bean id="passwordEncoder" 
         class="org.jasig.cas.authentication.handler.DefaultPasswordEncoder"  
         c:encodingAlgorithm="MD5"  
         p:characterEncoding="UTF-8" />  
   <bean id="dbAuthHandler"  
         class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"  
         p:dataSource-ref="dataSource"  
         p:sql="select password from tb_user where username = ?"  
         p:passwordEncoder-ref="passwordEncoder"/>  
   ```

2. 然后在配置文件开始部分找到如下配置

   ```XML
   <bean id="authenticationManager" class="org.jasig.cas.authentication.PolicyBasedAuthenticationManager">
       <constructor-arg>
           <map>               
               <entry key-ref="proxyAuthenticationHandler" value-ref="proxyPrincipalResolver" />
               <!--使用固定的用户名和密码，我们在下面可以看到这两个bean,若使用数据库认证用户名和密码，需要将这句注释掉-->
               <entry key-ref="primaryAuthenticationHandler" value-ref="primaryPrincipalResolver" />
               <!--使用数据库的用户名和密码-->
               <entry key-ref="dbAuthHandler" value-ref="primaryPrincipalResolver"/>
           </map>
       </constructor-arg>      
       <property name="authenticationPolicy">
           <bean class="org.jasig.cas.authentication.AnyAuthenticationPolicy" />
       </property>
   </bean>
   ```

   

#### 4、CAS服务端界面改造

> 将CAS默认的登录页更改为自己的品优购登陆页

1. 将品优购的登陆页login.html拷贝到cas系统下`WEB-INF\view\jsp\default\ui` 目录下

2. 将css  js等文件夹拷贝到  cas目录下

3. 将原来的`casLoginView.jsp` 改名（可以为之后的修改操作做参照），将`login.html`改名为`casLoginView.jsp`

4. 编辑`casLoginView.jsp` 内容

   1. 添加指令

      ```jsp
      <%@ page pageEncoding="UTF-8" %>
      <%@ page contentType="text/html; charset=UTF-8" %>
      <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
      <%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>
      <%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
      <%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
      ```

   2. 修改form标签

      ```jsp
      <form:form method="post" id="fm1" commandName="${commandName}" htmlEscape="true" class="sui-form">
          ......
      </form:form>
      ```

   3. 修改用户名框

      ```jsp
      <form:input id="username" tabindex="1" 
                  accesskey="${userNameAccessKey}" path="username" autocomplete="off" htmlEscape="true" 
                  placeholder="邮箱/用户名/手机号" class="span2 input-xfat" />
      ```

   4. 修改密码框

      ```jsp
      <form:password  id="password" tabindex="2" path="password" 
                     accesskey="${passwordAccessKey}" htmlEscape="true" autocomplete="off" 
                     placeholder="请输入密码" class="span2 input-xfat"   />
      ```

   5. 修改登陆按钮

      ```jsp
      <input type="hidden" name="lt" value="${loginTicket}" />
      <input type="hidden" name="execution" value="${flowExecutionKey}" />
      <input type="hidden" name="_eventId" value="submit" />
      <input class="sui-btn btn-block btn-xlarge btn-danger" accesskey="l" value="登陆" type="submit" />
      ```



#### 5、CAS服务端界面错误提示

1. 在表单内加入错误提示框

   ```jsp
   <form:errors path="*" id="msg" cssClass="errors" element="div" htmlEscape="false" />
   ```

   测试：输入错误的用户名和密码，提示是英文。这个提示信息是在`WEB-INF\classes`目录下的`messages.properties`中

   ```properties
   authenticationFailure.AccountNotFoundException=Invalid credentials.
   authenticationFailure.FailedLoginException=Invalid credentials.
   ```

2. 设置国际化为zn_CN  ,修改`cas-servlet.xml`

   ```xml
   <bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver" p:defaultLocale="zh_CN" />
   ```

3. 将此信息拷贝到`messages_zh_CN.properties`下，并改为中文提示（转码，但是我直接使用中文也可以显示）

   ```properties
   # 用户名不存在时的错误提示
   authenticationFailure.AccountNotFoundException=\u7528\u6237\u4E0D\u5B58\u5728. 
   # 密码错误的提示
   authenticationFailure.FailedLoginException=\u5BC6\u7801\u9519\u8BEF.
   ```

   



## 15.2 CAS客户端与SpringSecurity集成

> 建立Maven项目casclient_demo3 ，引入spring依赖和spring secrity 相关依赖 ，tomcat端口设置为**9003**
> 建立web.xml ，添加过滤器等配置
> 创建配置文件spring-security.xml 
> 添加html页面

### 15.2.1 Spring Security与 CAS整合

Maven依赖

```xml
<!--Web、SpringSecurity等依赖-->
<dependency>  
    <groupId>org.springframework.security</groupId>  
    <artifactId>spring-security-cas</artifactId>  
    <version>4.1.0.RELEASE</version>  
</dependency>     
<dependency>  
    <groupId>org.jasig.cas.client</groupId>  
    <artifactId>cas-client-core</artifactId>  
    <version>3.3.3</version>  
    <exclusions>  
        <exclusion>  
            <groupId>org.slf4j</groupId>  
            <artifactId>log4j-over-slf4j</artifactId>  
        </exclusion>  
    </exclusions>  
</dependency> 
```

修改`spring-security.xml`，替代了原生web.xml配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"
             xmlns:beans="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                                 http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd">

    <!--   entry-point-ref  入口点引用。由于登陆页面不再使用SpringSecurity的，而使用CAS中的 -->
    <http use-expressions="false" entry-point-ref="casProcessingFilterEntryPoint">  
        <intercept-url pattern="/**" access="ROLE_USER"/>   
        <csrf disabled="true"/>  
        <!-- custom-filter为过滤器， position 表示将过滤器放在指定的位置上，before表示放在指定位置之前  ，after表示放在指定的位置之后。替换默认过滤器  -->           
        <custom-filter ref="casAuthenticationFilter"  position="CAS_FILTER" />      
        <custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/>  
        <custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/>  
    </http>

    <!-- CAS入口点 开始 -->
    <beans:bean id="casProcessingFilterEntryPoint" class="org.springframework.security.cas.web.CasAuthenticationEntryPoint">  
        <!-- 单点登录服务器登录URL -->  
        <beans:property name="loginUrl" value="http://localhost:9100/cas/login"/>  
        <beans:property name="serviceProperties" ref="serviceProperties"/>  
    </beans:bean>      
    <beans:bean id="serviceProperties" class="org.springframework.security.cas.ServiceProperties">  
        <!--service 配置自身工程的根地址+/login/cas   -->  
        <beans:property name="service" value="http://localhost:9003/login/cas"/>
    </beans:bean>  
    <!-- CAS入口点 结束 -->

    
    <!-- 认证过滤器 开始 -->
    <beans:bean id="casAuthenticationFilter" class="org.springframework.security.cas.web.CasAuthenticationFilter">  
        <beans:property name="authenticationManager" ref="authenticationManager"/>  
    </beans:bean>  
    <!-- 认证管理器 -->
    <authentication-manager alias="authenticationManager">
        <authentication-provider  ref="casAuthenticationProvider">
        </authentication-provider>
    </authentication-manager>
    <!-- 认证提供者 -->
    <beans:bean id="casAuthenticationProvider"     class="org.springframework.security.cas.authentication.CasAuthenticationProvider">  
        <beans:property name="authenticationUserDetailsService">  
            <beans:bean class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper">  
                <beans:constructor-arg ref="userDetailsService" />  
            </beans:bean>  
        </beans:property>  
        <beans:property name="serviceProperties" ref="serviceProperties"/>  
        <!-- ticketValidator 为票据验证器 -->
        <beans:property name="ticketValidator">  
            <beans:bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator">  
                <beans:constructor-arg index="0" value="http://localhost:9100/cas"/>  
            </beans:bean>  
        </beans:property>  
        <beans:property name="key" value="an_id_for_this_auth_provider_only"/> 
    </beans:bean>        
    <!-- 认证类 -->
    <beans:bean id="userDetailsService" class="cn.itcast.demo.service.UserDetailServiceImpl"/>  
    <!-- 认证过滤器 结束 -->
    
    <!-- 单点登出  开始  -->     
    <beans:bean id="singleLogoutFilter" class="org.jasig.cas.client.session.SingleSignOutFilter"/>          
    <beans:bean id="requestSingleLogoutFilter" class="org.springframework.security.web.authentication.logout.LogoutFilter">  
        <!--经过此配置，当用户在地址栏输入本地工程的/logout/cas，即可登出，替代了下面一长串（相当于这俩之间映射关系）-->
        <beans:constructor-arg value="http://localhost:9100/cas/logout?service=http://localhost:9103"/>  
        <beans:constructor-arg>  
            <beans:bean class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/>  
        </beans:constructor-arg>  
        <beans:property name="filterProcessesUrl" value="/logout/cas"/>  
    </beans:bean>  
    <!-- 单点登出  结束 -->  
</beans:beans>
```

认证类：这个类的主要作用是在登陆后（CAS完成认证后）得到用户名，可以根据用户名查询角色或执行一些逻辑

```java
public class UserDetailServiceImpl implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //构建角色集合
        List<GrantedAuthority> authorities=new ArrayList();
        authorities.add(new SimpleGrantedAuthority("ROLE_USER"));
        return new User(username, null  , authorities);
    }
}
```



### 15.2.2 获取登录名

> 我们在处理后端逻辑需要获得登录名，那么如何获取单点登录的用户名呢? 其实和我们之前获得用户名的方式是完全相同的

`web.xml`加载springmvc

```xml
<servlet>
    <servlet-name>springmvc</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载-->
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:springmvc.xml</param-value>
    </init-param>
</servlet>

<servlet-mapping>
    <servlet-name>springmvc</servlet-name>
    <url-pattern>*.do</url-pattern>
</servlet-mapping>
```

创建`springmvc.xml`

```xml
<context:component-scan base-package="cn.itcast.demo" />
<mvc:annotation-driven />
```

创建`UserController`

```java
@RestController
public class UserController {
    
    @RequestMapping("/findLoginUser")
    public void  findLoginUser(){
        String name = SecurityContextHolder.getContext().getAuthentication().getName();
        System.out.println(name);		
    }	
}
//地址栏输入http://localhost:9003/findLoginUser.do 即可在控制台看到输出的登录名
```



### 15.2.3 退出登录

根据`spring-security.xml`中配置的，只需登录成功后再本项目中访问`<a href="/logout/cas">退出登录</a>`即可退出登录



### 15.2.4 附录 Spring Security 内置过滤器表

| **别名**                     | **Filter** **类**                              |
| ---------------------------- | ---------------------------------------------- |
| CHANNEL_FILTER               | ChannelProcessingFilter                        |
| SECURITY_CONTEXT_FILTER      | SecurityContextPersistenceFilter               |
| CONCURRENT_SESSION_FILTER    | ConcurrentSessionFilter                        |
| LOGOUT_FILTER                | LogoutFilter                                   |
| X509_FILTER                  | X509AuthenticationFilter                       |
| PRE_AUTH_FILTER              | AstractPreAuthenticatedProcessingFilter 的子类 |
| CAS_FILTER                   | CasAuthenticationFilter                        |
| FORM_LOGIN_FILTER            | UsernamePasswordAuthenticationFilter           |
| BASIC_AUTH_FILTER            | BasicAuthenticationFilter                      |
| SERVLET_API_SUPPORT_FILTER   | SecurityContextHolderAwareRequestFilter        |
| JAAS_API_SUPPORT_FILTER      | JaasApiIntegrationFilter                       |
| REMEMBER_ME_FILTER           | RememberMeAuthenticationFilter                 |
| ANONYMOUS_FILTER             | AnonymousAuthenticationFilter                  |
| SESSION_MANAGEMENT_FILTER    | SessionManagementFilter                        |
| EXCEPTION_TRANSLATION_FILTER | ExceptionTranslationFilter                     |
| FILTER_SECURITY_INTERCEPTOR  | FilterSecurityInterceptor                      |
| SWITCH_USER_FILTER           | SwitchUserFilter                               |



## 15.3 品优购用户中心

> 用户中心实现单点登录

### 15.3.1 用户中心实现单点登录

1. 将用户中心相关的页面（`home-`开头的）拷贝至  `pinnyougou-user-web`

2. `pom.xml` 引入springSecurity（2个）、cas客户端和springSecurity Cas整合包依赖

3. `web.xml`  添加spring-security过滤器，监听器，设置首页为home-index.html

   ```xml
   <context-param>
       <param-name>contextConfigLocation</param-name>
       <param-value>classpath:spring/spring-security.xml</param-value>
   </context-param>
   <listener>
       <listener-class>
           org.springframework.web.context.ContextLoaderListener
       </listener-class>
   </listener>
   
   <filter>  
       <filter-name>springSecurityFilterChain</filter-name>  
       <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>  
   </filter>  
   <filter-mapping>  
       <filter-name>springSecurityFilterChain</filter-name>  
       <url-pattern>/*</url-pattern>  
   </filter-mapping>
   
   <welcome-file-list>
       <welcome-file>home-index.html</welcome-file>
   </welcome-file-list>
   ```

4. 添加`spring-security.xml`，并做以下修改（参考15.2）

   ```xml
   <!-- 匿名访问资源 -->
   <http pattern="/css/**" security="none"></http>
   <http pattern="/js/**" security="none"></http>
   <http pattern="/image/**" security="none"></http>
   <http pattern="/plugins/**" security="none"></http>
   <!--注意这三个放行-->
   <http pattern="/register.html" security="none"></http>
   <http pattern="/user/add.do" security="none"></http>
   <http pattern="/user/sendCode.do" security="none"></http>
   
   <!--修改客户端id地址-->
   <beans:bean id="serviceProperties" class="org.springframework.security.cas.ServiceProperties">    
       <beans:property name="service" value="http://localhost:9106/login/cas"/>
   </beans:bean>  
   
   <!--认证类-->
   <beans:bean id="userDetailsService" class="com.pinyougou.user.service.UserDetailServiceImpl"/>  
   ```

5. 创建认证类`UserDetailsServiceImpl`

   ```java
   public class UserDetailServiceImpl implements UserDetailsService {
       @Override
       public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
           System.out.println("经过认证类："+username);
           //构建角色集合
           List<GrantedAuthority> authorities=new ArrayList();
           authorities.add(new SimpleGrantedAuthority("ROLE_USER"));
           return new User(username, ""  , authorities);
       }
   }
   ```

   

### 15.3.2 页面显示用户名

`LoginController`

```java
@RestController
@RequestMapping("/login")
public class LoginController {
    @RequestMapping("/name")
    public Map showName(){
        String name = SecurityContextHolder.getContext().getAuthentication().getName();//得到登陆人账号
        Map map=new HashMap<>();
        map.put("loginName", name);
        return map;
    }
}
```

前端用AngularJS调用这个显示即可



### 15.3.3 退出登录

根据配置文件修改：`<a href="/logout/cas">退出登录 </a>`即可，一般是到项目首页







# 16 购物车解决方案

![1548949336574](images/1548949336574.png)



## 16.1 购物车需求分析与解决方案

用户在商品**详细页**点击**加入购物车**，提交商品SKU编号和购买数量，添加到购物车。购物车数据的存储结构如下：

![1548949415904](images/1548949415904.png)

当用户在未登录的情况下，将此购物车存入**cookies** , 在用户登陆的情况下，将购物车数据存入**redis**  。如果用户登陆时，cookies 中存在购物车，需要将cookies的购物车**合并**到 redis 中存储。

工程搭建：

1. 创建工程`pinyougou-cart-interface`  ，依赖`pinyougou-pojo`

2. 创建工程`pinyougou-cart-service`（war），依赖`pinyougou-cart-interface`和`pinyougou-common`工程 和spring、 dubbox  等相关依赖,  添加`web.xml` 与spring配置文件（参照其他service工程）  tomcat插件端口设置为**9007**  ，dubbo端口为**20887**

3. 创建工程`pinyougou-cart-web`  ,依赖 `pinyougou-cart-interface`   `springsecurity` 、`CAS` 等。添加`web.xml` 与spring配置文件（参照其他web工程）tomcat插件端口设置为**9107** ，拷贝`UserDetailServiceImpl`  ,  拷贝页面资源

4. 将资源文件夹中 **Cookie工具类**拷贝到`pinyougou-common`工程中。需要在`pinyougou-common`工程引入`servlet-api`依赖

5. 购物车实体类：在`pinyougou-pojo`的`com.pinyougou.pojogroup`中创建购物车实体类。对每个商家的购物车进行的封装

   ```java
   public class Cart implements Serializable{
       private String sellerId;//商家ID
       private String sellerName;//商家名称
       private List<TbOrderItem> orderItemList;//购物车明细，涉及tb_order_item表
       //getter、setter  ......
   }
   ```



## 16.2 Cookie存储购物车

使用cookie存储购物车数据。服务层负责逻辑，**控制层负责读写cookie（这是和Redis存储购物车的区别）**

`CartServiceImpl`

```java
@Service
public class CartServiceImpl implements CartService {

    @Autowired
    private TbItemMapper itemMapper;

    @Override
    public List<Cart> addGoodsToCartList(List<Cart> cartList, Long itemId, Integer num) {
        //1.根据商品SKU ID查询SKU商品信息
        TbItem item = itemMapper.selectByPrimaryKey(itemId);
        if (item==null){
            throw new RuntimeException("商品不存在");
        }
        if (!item.getStatus().equals("1")){
            throw new RuntimeException("商品状态无效");
        }
        //2.获取商家ID
        String sellerId = item.getSellerId();
        //3.根据商家ID判断购物车列表中是否存在该商家的购物车
        Cart cart = searchCartBySellerId(cartList, sellerId);
        //4.如果购物车列表中不存在该商家的购物车
        if (cart==null){
            //4.1 新建购物车对象（所属商家的购物车）
            cart = new Cart();
            cart.setSellerId(sellerId);//商家id
            cart.setSellerName(item.getSeller());//商家名称
            List<TbOrderItem> orderItemList = new ArrayList<>();//订单明细列表（所属一个商家）
            TbOrderItem orderItem = createOrderItem(item, num);//订单明细对象
            orderItemList.add(orderItem);
            cart.setOrderItemList(orderItemList);

            //4.2 将新建的购物车对象添加到购物车列表
            cartList.add(cart);
        } else {
            //5.如果购物车列表中存在该商家的购物车
            // 查询订单明细列表中是否存在该商品
            TbOrderItem orderItem = searchOrderItemByItemId(cart.getOrderItemList(), itemId);
            //5.1. 如果没有，新增订单明细对象
            if (orderItem==null){
                orderItem = createOrderItem(item,num);
                cart.getOrderItemList().add(orderItem);
            } else {
                //5.2. 如果有，在原购物车明细上添加数量，更改金额
                orderItem.setNum(orderItem.getNum()+num);
                orderItem.setTotalFee(new BigDecimal(orderItem.getPrice().doubleValue()*orderItem.getNum()));
                //订单明细对象数量小于等于0，移除此明细对象
                if (orderItem.getNum()<=0){
                    cart.getOrderItemList().remove(orderItem);
                }
                //订单明细列表数量小于等于0，在购物车列表中移除该购物车
                if (cart.getOrderItemList().size()<=0){
                    cartList.remove(cart);
                }
            }
        }

        return cartList;
    }

    //根据商家ID查询购物车对象
    private Cart searchCartBySellerId(List<Cart> cartList,String sellerId){
        for (Cart cart : cartList) {
            if (cart.getSellerId().equals(sellerId)){
                return cart;
            }
        }
        return null;
    }

    //创建订单明细对象
    private TbOrderItem createOrderItem(TbItem item,Integer num){
        TbOrderItem orderItem = new TbOrderItem();
        orderItem.setGoodsId(item.getGoodsId());
        orderItem.setItemId(item.getId());
        orderItem.setNum(num);
        orderItem.setPicPath(item.getImage());
        orderItem.setPrice(item.getPrice());
        orderItem.setSellerId(item.getSellerId());
        orderItem.setTitle(item.getTitle());
        orderItem.setTotalFee(new BigDecimal(item.getPrice().doubleValue()*num));
        return orderItem;
    }

    //根据SKUID在订单明细列表中查询订单明细对象
    private TbOrderItem searchOrderItemByItemId(List<TbOrderItem> orderItemList,Long itemId){
        for (TbOrderItem orderItem : orderItemList) {
            if (orderItem.getItemId().longValue()==itemId.longValue()){
                return orderItem;
            }
        }
        return null;
    }
}
```

`CartController`

```java
@RestController
@RequestMapping("/cart")
public class CartController {
    @Reference
    private CartService cartService;

    @Autowired
    private HttpServletRequest request;

    @Autowired
    private HttpServletResponse response;

    @RequestMapping("/findCartList")
    public List<Cart> findCartList(){
        //从cookie中取出购物车
        String cartListString = CookieUtil.getCookieValue(request, "cartList", "UTF-8");
        if (cartListString==null || cartListString.equals("")){
            cartListString = "[]";
        }
        List<Cart> cartList_cookie = JSON.parseArray(cartListString, Cart.class);
        return cartList_cookie;
    }


    @RequestMapping("/addGoodsToCartList")
    public Result addGoodsToCartList(Long itemId,Integer num){
        try {
            //从cookie中取出购物车
            List<Cart> cartList = findCartList();
            //向购物车添加商品
            cartList = cartService.addGoodsToCartList(cartList, itemId, num);
            //将购物车存入cookie
            String cartListString = JSON.toJSONString(cartList);
            CookieUtil.setCookie(request,response,"cartList",cartListString,3600*24,"UTF-8");
            return new Result(true,"存入购物车成功");
        } catch (Exception e) {
            e.printStackTrace();
            return new Result(false,"存入购物车失败");

        }
    }
}
```

前端购物车列表（和之前一样，AngularJS遍历，绑定数据）

前端购物车数量增减与移除（调用后端`addGoodsToCartList()`方法，传递id，和num，num可正可负）

```js
//购物车服务层
app.service('cartService',function($http){
    //购物车列表
    this.findCartList=function(){
        return $http.get('cart/findCartList.do');
    }

    //添加商品到购物车
    this.addGoodsToCartList=function(itemId,num){
        return $http.get('cart/addGoodsToCartList.do?itemId='+itemId+'&num='+num);
    }

    //求合计
    this.sum=function(cartList){
        var totalValue={totalNum:0, totalMoney:0.00 };//合计实体
        for(var i=0;i<cartList.length;i++){
            var cart=cartList[i];
            for(var j=0;j<cart.orderItemList.length;j++){
                var orderItem=cart.orderItemList[j];//购物车明细
                totalValue.totalNum+=orderItem.num;
                totalValue.totalMoney+= orderItem.totalFee;
            }
        }
        return totalValue;
    }
});
```

```js
//购物车控制层
app.controller('cartController',function($scope,cartService){
    //查询购物车列表
    $scope.findCartList=function(){
        cartService.findCartList().success(
            function(response){
                $scope.cartList=response;
                $scope.totalValue=cartService.sum($scope.cartList);//求合计数
            }
        );
    }

    //添加商品到购物车
    $scope.addGoodsToCartList=function(itemId,num){
        cartService.addGoodsToCartList(itemId,num).success(
            function(response){
                if(response.success){
                    $scope.findCartList();//刷新列表
                }else{
                    alert(response.message);//弹出错误提示
                }
            }
        );
    }
});
```

HTML中`{{totalValue.totalMoney.toFixed(2)}}`方法可以保留两位小数



## 16.3 Redis存储购物车

判断当前用户是否登陆，如果未登录采用Cookie存储，如果登录则采用Redis存储。登录后要进行Cookie购物车与Redis购物车的合并操作，并清除Cookie购物车

### 16.3.1 获取当前登录人账号

`spring-security.xml` 更改配置：

去掉

```xml
<http pattern="/cart/*.do" security="none"></http>
```

添加

```xml
<http use-expressions="false" entry-point-ref="casProcessingFilterEntryPoint">
    <intercept-url pattern="/cart/*.do" access="IS_AUTHENTICATED_ANONYMOUSLY"/><!---->
    <intercept-url pattern="/**" access="ROLE_USER"/>  
    <custom-filter position="CAS_FILTER" ref="casAuthenticationFilter" />  
    <custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/>  
    <custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/>  
</http>
```

`access="IS_AUTHENTICATED_ANONYMOUSLY"` 用于设置**资源可以在不登陆时可以访问**，此配置与 `security="none"`的区别在于当用户未登陆时获取登陆人**账号的值为`anonymousUser`** ，而`security="none"`的话，无论是否登陆都不能获取登录人账号的值（在获取时就报空指针异常，因为不走SpringSecurity）



### 16.3.2 远程购物车存取

`CartServiceImpl`

```java
@Autowired
private RedisTemplate redisTemplate;
//从redis中查询购物车
@Override
public List<Cart> findCartListFromRedis(String username) {
    System.out.println("从redis提取购物车"+username);
    List<Cart> cartList = (List<Cart>) redisTemplate.boundHashOps("cartList").get(username);
    if (cartList==null){
        cartList = new ArrayList<>();
    }
    return cartList;
}

//将购物车保存到redis
@Override
public void saveCartListToRedis(String username, List<Cart> cartList) {
    System.out.println("向redis保存购物车"+username);
    redisTemplate.boundHashOps("cartList").put(username,cartList);

}
```

`CartController`

```java
@RestController
@RequestMapping("/cart")
public class CartController {
    @Reference
    private CartService cartService;

    @Autowired
    private HttpServletRequest request;

    @Autowired
    private HttpServletResponse response;

    @RequestMapping("/findCartList")
    public List<Cart> findCartList() {
        String name = SecurityContextHolder.getContext().getAuthentication().getName();
        System.out.println("name:" + name);
        if ("anonymousUser".equals(name)) { //未登录
            //从cookie中取出购物车
            String cartListString = CookieUtil.getCookieValue(request, "cartList", "UTF-8");
            if (cartListString == null || cartListString.equals("")) {
                cartListString = "[]";
            }
            List<Cart> cartList_cookie = JSON.parseArray(cartListString, Cart.class);
            return cartList_cookie;

        } else {
            List<Cart> cartList_redis = cartService.findCartListFromRedis(name);
            return cartList_redis;
        }

    }

    @RequestMapping("/addGoodsToCartList")
    public Result addGoodsToCartList(Long itemId, Integer num) {
        String name = SecurityContextHolder.getContext().getAuthentication().getName();
        System.out.println("name:" + name);


        try {
            //从cookie中取出购物车
            List<Cart> cartList = findCartList();
            //向购物车添加商品
            cartList = cartService.addGoodsToCartList(cartList, itemId, num);
            if ("anonymousUser".equals(name)) { //未登录
                //将购物车存入cookie
                String cartListString = JSON.toJSONString(cartList);
                CookieUtil.setCookie(request, response, "cartList", cartListString, 3600 * 24, "UTF-8");

            } else {
                cartService.saveCartListToRedis(name,cartList);
            }
            return new Result(true, "存入购物车成功");
        } catch (Exception e) {
            e.printStackTrace();
            return new Result(false, "存入购物车失败");

        }
    }
}
```



### 16.3.3 跳板页

创建跳板页：`pinyougou-cart-web` 工程新建`login.html `（因为这个会被CAS拦截，登录后继续跳转），页面添加脚本

```html
<script type="text/javascript">
    location.href="cart.html";
</script>
```

购物车页面链接到跳板页

```html
请<a href="login.html">登录</a> 
```



## 16.4 购物车合并

`CartServiceImpl`

```java
@Override
public List<Cart> mergeCartList(List<Cart> cartList1, List<Cart> cartList2) {
    for (Cart cart : cartList2) {
        for (TbOrderItem orderItem : cart.getOrderItemList()) {
            //调用封装好的方法
            cartList1 = addGoodsToCartList(cartList1, orderItem.getItemId(), orderItem.getNum());
        }
    }
    return cartList1;
}
```

`CartController`

```java
@RequestMapping("/findCartList")
public List<Cart> findCartList(){
    String username = SecurityContextHolder.getContext().getAuthentication().getName(); 
    String cartListString  = util.CookieUtil.getCookieValue(request, "cartList", "UTF-8");
    if(cartListString==null || cartListString.equals("")){
        cartListString="[]";
    }
    List<Cart> cartList_cookie = JSON.parseArray(cartListString, Cart.class);
    if(username.equals("anonymousUser")){//如果未登录			
        return cartList_cookie;			
    }else{
        List<Cart> cartList_redis =cartService.findCartListFromRedis(username);//从redis中提取	
        if(cartList_cookie.size()>0){//如果本地存在购物车
            //合并购物车
            cartList_redis=cartService.mergeCartList(cartList_redis, cartList_cookie);	
            //清除本地cookie的数据
            util.CookieUtil.deleteCookie(request, response, "cartList");
            //将合并后的数据存入redis 
            cartService.saveCartListToRedis(username, cartList_redis); 
        }			
        return cartList_redis;			
    }	
}
```







## 16.5 全部代码

```java
@Service
public class CartServiceImpl implements CartService {
    /**
     * 添加商品到购物车
     *
     * @param cartList
     * @param itemId
     * @param num
     * @return
     */
    @Autowired
    private TbItemMapper itemMapper;

    @Override
    public List<Cart> addGoodsToCartList(List<Cart> cartList, Long itemId, Integer num) {
        //1.根据商品SKU ID查询SKU商品信息
        TbItem item = itemMapper.selectByPrimaryKey(itemId);
        if (item==null){
            throw new RuntimeException("商品不存在");
        }
        if (!item.getStatus().equals("1")){
            throw new RuntimeException("商品状态无效");
        }
        //2.获取商家ID
        String sellerId = item.getSellerId();
        //3.根据商家ID判断购物车列表中是否存在该商家的购物车
        Cart cart = searchCartBySellerId(cartList, sellerId);
        //4.如果购物车列表中不存在该商家的购物车
        if (cart==null){
            //4.1 新建购物车对象（所属商家的购物车）
            cart = new Cart();
            cart.setSellerId(sellerId);//商家id
            cart.setSellerName(item.getSeller());//商家名称
            List<TbOrderItem> orderItemList = new ArrayList<>();//订单明细列表（所属一个商家）
            TbOrderItem orderItem = createOrderItem(item, num);//订单明细对象
            orderItemList.add(orderItem);
            cart.setOrderItemList(orderItemList);

            //4.2 将新建的购物车对象添加到购物车列表
            cartList.add(cart);
        } else {
            //5.如果购物车列表中存在该商家的购物车
            // 查询订单明细列表中是否存在该商品
            TbOrderItem orderItem = searchOrderItemByItemId(cart.getOrderItemList(), itemId);
            //5.1. 如果没有，新增订单明细对象
            if (orderItem==null){
                orderItem = createOrderItem(item,num);
                cart.getOrderItemList().add(orderItem);
            } else {
                //5.2. 如果有，在原购物车明细上添加数量，更改金额
                orderItem.setNum(orderItem.getNum()+num);
                orderItem.setTotalFee(new BigDecimal(orderItem.getPrice().doubleValue()*orderItem.getNum()));
                //订单明细对象数量小于等于0，移除此明细对象
                if (orderItem.getNum()<=0){
                    cart.getOrderItemList().remove(orderItem);
                }
                //订单明细列表数量小于等于0，在购物车列表中移除该购物车
                if (cart.getOrderItemList().size()<=0){
                    cartList.remove(cart);
                }
            }
        }

        return cartList;
    }


    @Autowired
    private RedisTemplate redisTemplate;
    /**
     * 从redis中查询购物车
     *
     * @param username
     * @return
     */
    @Override
    public List<Cart> findCartListFromRedis(String username) {
        System.out.println("从redis提取购物车"+username);
        List<Cart> cartList = (List<Cart>) redisTemplate.boundHashOps("cartList").get(username);
        if (cartList==null){
            cartList = new ArrayList<>();
        }
        return cartList;
    }

    /**
     * 将购物车保存到redis
     *
     * @param username
     * @param cartList
     */
    @Override
    public void saveCartListToRedis(String username, List<Cart> cartList) {
        System.out.println("向redis保存购物车"+username);
        redisTemplate.boundHashOps("cartList").put(username,cartList);

    }

    /**
     * 合并购物车
     *
     * @param cartList1
     * @param cartList2
     * @return
     */
    @Override
    public List<Cart> mergeCartList(List<Cart> cartList1, List<Cart> cartList2) {
        for (Cart cart : cartList2) {
            for (TbOrderItem orderItem : cart.getOrderItemList()) {
                //调用封装好的方法
                cartList1 = addGoodsToCartList(cartList1, orderItem.getItemId(), orderItem.getNum());
            }
        }
        return cartList1;
    }


    //根据商家ID查询购物车对象
    private Cart searchCartBySellerId(List<Cart> cartList,String sellerId){
        for (Cart cart : cartList) {
            if (cart.getSellerId().equals(sellerId)){
                return cart;
            }
        }
        return null;
    }

    //创建订单明细对象
    private TbOrderItem createOrderItem(TbItem item,Integer num){
        TbOrderItem orderItem = new TbOrderItem();
        orderItem.setGoodsId(item.getGoodsId());
        orderItem.setItemId(item.getId());
        orderItem.setNum(num);
        orderItem.setPicPath(item.getImage());
        orderItem.setPrice(item.getPrice());
        orderItem.setSellerId(item.getSellerId());
        orderItem.setTitle(item.getTitle());
        orderItem.setTotalFee(new BigDecimal(item.getPrice().doubleValue()*num));
        return orderItem;
    }

    //根据SKUID在订单明细列表中查询订单明细对象
    private TbOrderItem searchOrderItemByItemId(List<TbOrderItem> orderItemList,Long itemId){
        for (TbOrderItem orderItem : orderItemList) {
            if (orderItem.getItemId().longValue()==itemId.longValue()){
                return orderItem;
            }
        }
        return null;
    }
}
```

```java
@RestController
@RequestMapping("/cart")
public class CartController {
    @Reference
    private CartService cartService;

    @Autowired
    private HttpServletRequest request;

    @Autowired
    private HttpServletResponse response;

    @RequestMapping("/findCartList")
    public List<Cart> findCartList(){
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        String cartListString  = util.CookieUtil.getCookieValue(request, "cartList", "UTF-8");
        if(cartListString==null || cartListString.equals("")){
            cartListString="[]";
        }
        List<Cart> cartList_cookie = JSON.parseArray(cartListString, Cart.class);
        if(username.equals("anonymousUser")){//如果未登录
            return cartList_cookie;
        }else{
            List<Cart> cartList_redis =cartService.findCartListFromRedis(username);//从redis中提取
            if(cartList_cookie.size()>0){//如果本地存在购物车
                //合并购物车
                cartList_redis=cartService.mergeCartList(cartList_redis, cartList_cookie);
                //清除本地cookie的数据
                util.CookieUtil.deleteCookie(request, response, "cartList");
                //将合并后的数据存入redis
                cartService.saveCartListToRedis(username, cartList_redis);
                System.out.println("合并购物车");
            }
            return cartList_redis;
        }
    }


    @RequestMapping("/addGoodsToCartList")
    public Result addGoodsToCartList(Long itemId, Integer num) {
        String name = SecurityContextHolder.getContext().getAuthentication().getName();
        System.out.println("name:" + name);


        try {
            //从cookie中取出购物车
            List<Cart> cartList = findCartList();
            //向购物车添加商品
            cartList = cartService.addGoodsToCartList(cartList, itemId, num);
            if ("anonymousUser".equals(name)) { //未登录
                //将购物车存入cookie
                System.out.println("向cookie中存入购物车");
                String cartListString = JSON.toJSONString(cartList);
                CookieUtil.setCookie(request, response, "cartList", cartListString, 3600 * 24, "UTF-8");

            } else {
                cartService.saveCartListToRedis(name,cartList);
            }
            return new Result(true, "存入购物车成功");
        } catch (Exception e) {
            e.printStackTrace();
            return new Result(false, "存入购物车失败");

        }
    }
}
```


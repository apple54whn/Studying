# 1 数据库简介

- 数据库就是用来**存储和管理**数据的仓库
- 数据库管理系统（DBMS，数据的仓库）的概述
  - 方便查询；可存储的数据量大；保证数据的完整、一致；安全可靠
  - RDBMS（关系型数据库管理系统）使用表格存储数据
- 常见数据库
  - Oracle（神喻）：甲骨文（最高！）
  - **MySQL**：甲骨文
  - SQL Server：微软
  - DB2：IBM
  - Sybase：赛尔斯
- **RDBMS** = 管理员（**manager**）+仓库（**database**）
  - database = N个**table**
    - **表结构**：定义表的列名和列类型
    - **表记录**：一行一行的记录
- **MySQL重要文件夹**
  - C:\Program Files\MySQL\MySQL Server 8.0：**DBMS管理程序**
  - C:\ProgramData\MySQL\MySQL Server 8.0\data：**DBMS数据库文件**（卸载MySQL时不会删除这个目录）
    - 每个目录表示一个数据库，，每个数据库目录下会有0~N个扩展名为ibd的table文件
- **MySQL重要文件**
  - C:\Program Files\MySQL\MySQL Server 8.0\bin\ **mysqld**.exe：**服务器程序**，必须先启动它
  - C:\Program Files\MySQL\MySQL Server 8.0\bin\ **mysql**.exe：**客户端程序**操作服务器，服务器必须先开启
  - D:\Program Files\MySQL\MySQL Server 5.1\bin\ **my.ini**：**服务器配置文件**
    - 配置MySQL的端口：默认为3306，没有必要去修改它；
    - 配置字符编码：
      - [client]下配置客户端编码：default-character-set=gbk
      - [mysqld]下配置服务器编码：character-set-server=utf8
    - 配置二进制数据大小上限：
      - 在[mysqld]下配置：max_allowed_packet=8M
- **服务器操作**
  - 开启服务器(必须保证mysql为windows服务)：**net start mysql**，mysqld.exe进程存在
  - 关闭服务器(必须保证mysql为windows服务)：**net stop mysql**，mysqld.exe进程不存在
- **客户端操作**
  - 登录服务器：**mysql -uroot -p123 -hlocalhost**
  - 退出服务器：**exit或quit**



# 2 SQL

* **结构化查询语言**(Structured Query Language)

  * 作用：**客户端使用SQL来操作服务器**

* **SQL语法**

  * SQL语句可以在**单行或多行**书写，以**分号结尾**
  * 可使用空格和缩进来增强语句的可读性
  * MySQL不区别大小写，**建议使用大写**

* SQL语句**分类**

  * **DDL**（Data Definition Language）：**数据定义语言**

    数据库或表的**结构**操作，创建、删除、修改：库、表结构

  * **DML**（Data Manipulation Language）：**数据操作语言**

    对表的**记录**进行更新（增、删、改）

  * **DQL**（Data Query Language）：**数据查询语言**，用来查询记录数据

  * DCL（Data Control Language）：数据控制语言，用来对用户的创建，及授权

## 2.1 DDL

### 2.1.1 数据库(DATABASE)

* <span style="color:red;font-weight:bold">创建数据库(CREATE DATABASE)</span>

  ```mysql
  CREATE DATABASE [IF NOT EXISTS] mydb1 [CHARSET=utf8];
  ```

* <span style="color:red;font-weight:bold">删除数据库(DROP DATABASE)</span>

  ```mysql
  DROP DATABASE [IF EXISTS] mydb1;
  ```

* <span style="color:red;font-weight:bold">查看所有数据库(SHOW DATABASES)</span>

  ```mysql
  SHOW DATABASES;
  ```

* <span style="color:red;font-weight:bold">切换数据库(USE 数据库名)</span>

  ```mysql
  USE 数据库名;
  ```

* 修改数据库编码

  ```mysql
  ALTER DATABASE mydb1 CHARACTER SET utf8;
  ```

### 2.1.2 数据类型(列类型)

* **int**：整型

  **double**：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；

  **decimal**：浮点型，在表示钱方面使用该类型，因为不会出现精度缺失问题；

  **char**：固定长度字符串类型； char(255)，数据的长度不足指定长度，补空格到指定长度！

  **varchar**：可变长度字符串类型； varchar(65535)

* text(clob)：**字符串类型**；tinytext(2^8-1B)、text(2^16-1B)、mediumtext(2^24-1B)、longtext(2^32-1B)

  blob：**字节类型**；tinytext(2^8-1B)、text(2^16-1B)、mediumtext(2^24-1B)、longtext(2^32-1B)

* 在数据库中所有的<span style="color:red;font-weight:bold">字符串类型，必须使用**单引**</span>，不能使用双引;日期类型也要使用单引！

### 2.1.3 表(TABLE)

* <span style="color:red;font-weight:bold">创建表(CREATE TABLE)</span>

  ```mysql
  CREATE TABLE [IF NOT EXISTS] 表名(
    列名 列类型,
    列名 列类型,
    ...
    列名 列类型
  );
  ```

* <span style="color:red;font-weight:bold">删除表(DROP TABLE)</span>

  ```mysql
  DROP TABLE 表名;
  ```

* <span style="color:red;font-weight:bold">查看当前数据库中所有表名称(SHOW TABLES)</span>

  ```mysql
  SHOW TABLES;
  ```

  <span style="color:red;font-weight:bold">查看表结构(DESC)</span>

  ```mysql
  DESC 表名;
  ```

  查看指定表的创建语句(了解)

  ```mysql
  SHOW CREATE TABLE 表名;
  ```

* <span style="color:red;font-weight:bold">修改表</span>：前缀：<span style="color:red;font-weight:bold">ALTER TABLE 表名</span>

  * 修改<span style="color:red;font-weight:bold">表名称(RENAME TO</span>)

    ```mysql
    ALTER TABLE 原表名 RENAME TO 新表名;
    ```

  * 修改之<span style="color:red;font-weight:bold">添加列(ADD)</span>

    ```mysql
    ALTER TABLE 表名 ADD (
        列名 列类型,
        列名 列类型,
        ...
    );
    ```

  * 修改之<span style="color:red;font-weight:bold">删除列(DROP)</span>

    ```mysql
    ALTER TABLE 表名 DROP 列名;
    ```

  * 修改之<span style="color:red;font-weight:bold">修改列名类型(CHANGE)</span>

    ```mysql
    ALTER TABLE 表名 CHANGE 原列名 新列名 列类型 主键自增长;//新的类型可能会影响到已存在数据
    ```

  * 修改之<span style="color:red;font-weight:bold">修改列类型(MODIFY)</span>

    ```mysql
    ALTER TABLE 表名 MODIFY 列名 列类型;//新的类型可能会影响到已存在数据
    ```

## 2.2 DML

* <span style="color:red;font-weight:bold">插入数据(INSERT INTO)</span>

  ```mysql
  INSERT INTO 表名(
      列名1,列名2, ...
  ) VALUES(列值1, 列值2, ...);
  //没有指定的列等同与插入null值,插入记录总是插入一行
  ```

  ```mysql
  INSERT INTO 表名 
  VALUES(列值1, 列值2);
  //插入所有列。值的顺序，必须与表创建时给出的列的顺序相同
  ```

* <span style="color:red;font-weight:bold">删除数据(DELETE FROM)</span>

  ```mysql
  DELETE FROM 表名 [WHERE 条件];
  ```

* <span style="color:red;font-weight:bold">修改数据(UPDATE...SET)</span>

  ```mysql
  UPDATE 表名 SET 列名1=列值1, 列名2=列值2, ... [WHERE 条件]
  ```

  * **条件(可选的)**

    * 条件必须是一个boolean类型的值或表达式

    * 运算符：=、!=、<>、>、<、>=、<=、BETWEEN...AND、IN(...)、IS NULL、NOT、OR、AND

      ```mysql
      WHERE age >= 18 AND age <= 80
      WHERE age BETWEEN 18 AND 80
      WHERE name='zhangSan' OR name='liSi'
      WHERE name IN ('zhangSan', 'liSi')
      WHERE age IS NULL, 不能使用等号
      WHERE age IS NOT NULL
      ```

## 2.3 DQL

* <span style="color:red;font-weight:bold">查询不会修改数据库表记录！</span>
* <span style="color:red;font-weight:bold">顺序：SELECT、FROM、WHERE、GROUP BY、HAVING、ORDER BY</span>

### 2.3.1 基本查询

* <span style="color:red;font-weight:bold">字段(列)控制</span>

  * <span style="color:red;font-weight:bold">查询列(SELECT...FROM)</span>

    ```mysql
    SELECT * FROM 表名;//其中“*”表示查询所有列
    ```

    ```mysql
    SELECT 列1 [, 列2, ... 列N] FROM 表名;//查询指定列
    ```

  * 完全重复的<span style="color:red;font-weight:bold">记录只一次(DISTINCT</span>)

    ```mysql
    SELECT DISTINCT 列1 [, 列2, ... 列N]  FROM 表名;
    ```

  * <span style="color:red;font-weight:bold">列运算</span>

    * 数量类型的列可以做<span style="color:red;font-weight:bold">加、减、乘、除</span>运算

      ```mysql
      SELECT sal*1.5 FROM emp;
      SELECT sal+comm FROM emp;
      ```

    * 字符串类型可以做<span style="color:red;font-weight:bold">连续运算</span>

      ```mysql
      SELECT CONCAT('$', sal) FROM emp;
      ```

    * <span style="color:red;font-weight:bold">转换NULL值</span>

      ```mysql
      SELECT IFNULL(comm, 0)+1000 FROM emp;//如果comm中存在NULL值，那么当成0来运算
      ```

    * <span style="color:red;font-weight:bold">给列起别名</span>

      ```mysql
      SELECT IFNULL(comm, 0)+1000 AS 奖金 FROM emp;//AS可以省略
      ```

* <span style="color:red;font-weight:bold">条件控制</span>

  * <span style="color:red;font-weight:bold">条件查询(WHERE)</span>

    ```mysql
    SELECT empno,ename,sal,comm FROM emp WHERE sal > 10000 AND comm IS NOT NULL;
    SELECT empno,ename,sal FROM emp WHERE sal BETWEEN 20000 AND 30000;
    SELECT empno,ename,job FROM emp WHERE job IN ('经理', '董事长');
    ```

  * <span style="color:red;font-weight:bold">模糊查询(LIKE)</span>

    * <span style="color:red;font-weight:bold">_匹配一个任意字符</span>

      ```mysql
      SELECT * FROM emp WHERE ename LIKE '张_';/*姓张，名字由两个字组成的员工*/
      SELECT * FROM emp WHERE ename LIKE '___'; /*姓名由3个字组成的员工*/
      ```

    * <span style="color:red;font-weight:bold">%匹配0~N个任意字符</span>

      ```mysql
      SELECT * FROM emp WHERE ename LIKE '张%';/*查询的是姓张的所有员工*/
      SELECT * FROM emp WHERE ename LIKE '%阿%';/*查询姓名中间带有阿字的员工*/
      SELECT * FROM emp WHERE ename LIKE '%';/*条件不存在，如果姓名为NULL的查询不出来*/
      ```

### 2.3.2 排序(ORDER BY..*SC)

* <span style="color:red;font-weight:bold">升序(ORDER BY...ASC)</span>

  ```mysql
  SELECT * FROM WHERE emp ORDER BY sal ASC;//ASC是可以省略的
  ```

* <span style="color:red;font-weight:bold">降序(ORDER BY...DESC)</span>

  ```mysql
  SELECT * FROM WHERE emp ORDER BY comm DESC;//DESC不能省略
  ```

* 多列作为排序条件

  ```mysql
  SELECT * FROM WHERE emp ORDER BY sal ASC, comm DESC;//sal升序排，如果sal相同，comm降序排
  ```

### 2.3.3 聚合函数(列的纵向运算)

* 一般用于**分组后**的统计

* <span style="color:red;font-weight:bold">COUNT</span>

  ```mysql
  SELECT COUNT(*) FROM emp;//计算emp表中所有列都不为NULL的记录的行数
  SELECT COUNT(comm) FROM emp;//计算emp表中comm列不为NULL的记录的行数
  ```

* <span style="color:red;font-weight:bold">MAX</span>

  ```mysql
  SELECT MAX(sal) FROM emp;//查询最高工资
  ```

* <span style="color:red;font-weight:bold">MIN</span>

  ```mysql
  SELECT MIN(sal) FROM emp;//查询最低工资
  ```

* <span style="color:red;font-weight:bold">SUM</span>

  ```mysql
  SELECT SUM(sal) FROM emp;//查询工资合计
  ```

* <span style="color:red;font-weight:bold">AVG</span>

  ```mysql
  SELECT AVG(sal) FROM emp;//查询平均工资
  ```

### 2.3.4 分组查询(GROUP BY)

* **记录使用某一列进行<span style="color:red;font-weight:bold">分组(GROUP BY)</span>，然后查询组信息**

  ```mysql
  SELECT deptno, COUNT(*) FROM emp GROUP BY deptno;//deptno分组，查询部门编号和每个部门记录
  SELECT job, MAX(SAL) FROM emp GROUP BY job;//使用job分组，查询每种工作的最高工资
  ```

* <span style="color:red;font-weight:bold">组条件(HAVING)</span>

  ```mysql
  SELECT deptno, COUNT(*) FROM emp GROUP BY deptno HAVING COUNT(*) > 3;
  //以部门分组，查询每组记录数。条件为记录数大于3
  ```

### 2.3.5 limit子句(方言)

* LIMIT用来限定查询结果的**起始行**，以及**总行数**

  ```mysql
  /*1. 一页的记录数：10行;2. 查询第3页*/
  select * from emp limit 20, 10;
  /* (当前页-1) * 每页记录数*/
  ```



# 3 编码、备份

* 查看MySQL数据库编码

  ```mysql
  SHOW VARIABLES LIKE 'char%';
  ```

  * **character_set_client**：MySQL使用该编码来解读客户端发送过来的数据，例如该编码为UTF8，那么如果客户端发送过来的数据不是UTF8，那么就会出现乱码。8.0默认为gbk。

    * **character_set_results**：MySQL会把数据转换成该编码后，再发送给客户端，例如该编码为UTF8，那么如果客户端不使用UTF8来解读，那么就会出现乱码。8.0默认为gbk。

  * 在my.ini中设置(8.0中默认没有值，但默认为gbk)

    ```ini
    default-character-set=gbk
    #可以修改三个变量：client、results、connection
    ```

* 数据库导出SQL脚本(备份数据库**内容**，并不是备份数据库！)

  **生成的脚本文件中不包含create database语句**

  ```powershell
  # mysqldump –u用户名 –p密码 数据库名 > 生成的脚本文件路径
  mysqldump -uroot -p123 mydb1 > C:\mydb.sql 
  
  #mysql workbench操作
  ```

* SQL脚本导入到数据库，要先创建数据库

  ```powershell
  #mysql -u用户名 -p密码 数据库 < 脚本文件路径
  mysql -uroot -p123 mydb1 < C:\mydb.sql
  
  #创建数据库，切换并执行如下
  source c:\mydb.sql
  
  ##mysql workbench操作
  ```



# 4 约束

* 约束是添加在列上的，用来**约束列**的

## 4.1 主键约束（PRIMARY KEY）

* 特点：**非空**、**唯一**、**被引用**（学习外键时）

  * **创建表时设置主键**

    ```mysql
    CREATE TABLE stu(
    	stuid CHAR(6) PRIMARY KEY
    );
    ```

    ```mysql
    CREATE TABLE stu(
    	stuid CHAR(6),
        PRIMARY KEY(stuid)
    );
    ```

  * **没有主键时添加主键**

    ```mysql
    ALTER TABLE stu ADD PRIMARY KEY(sid);
    ```

  * **删除主键**

    ```mysql
    ALTER TABLE stu DROP PRIMARY KEY;
    ```

## 4.2 主键自增长(AUTO_INCREMENT)

* 保证在插入数据时主键列的唯一和非空特性，一般用UUID

  * 创建表时指定主键自增长

    ```mysql
    CREATE TABLE stu(
    	stuid CHAR(6) PRIMARY KEY AUTO_INCREMENT
    );
    ```

  *  修改表时设置主键自增长

    ```mysql
    ALTER TABLE stu CHANGE sid sid INT AUTO_INCREMENT;
    ```

  * 修改表时删除主键自增长

    ```mysql
    ALTER TABLE stu CHANGE sid sid INT;
    ```

## 4.3 非空约束(NOT NULL)

*  因为某些列不能设置为NULL值，所以可以对列添加非空约束

  * 创建表时设置

    ```mysql
    CREATE TABLE stu(
    		sid INT PRIMARY KEY AUTO_INCREMENT,
    		sname	VARCHAR(20) NOT NULL,
      );
    ```

## 4.4 唯一约束(UNIQUE)

* 数据库某些列不能设置重复的值，所以可以对列添加唯一约束

  * 创建表时设置

    ```mysql
    CREATE TABLE stu(
    		sid INT PRIMARY KEY AUTO_INCREMENT,
    		sname	VARCHAR(20) NOT NULL UNIQUE
      );
    ```

## 4.5 概念模型

* 对象模型：可以双向关联，而且引用的是对象，而不是一个主键！在java中是domain！！！例如：User
* 关系模型：只能多方引用一方，而且引用的只是主键，而不是一整行记录。在数据库中就是表

* 当我们要完成一个软件系统时，需要把系统中的**实体抽取出来，形成概念模型**。  例如部门、员工都是系统中的实体。概念模型中的实体最终会成为**Java中的类**、**数据库中表**。实体之间还存在着关系：
  * 1对多：例如每个员工都从属一个部门，而一个部门可以有多个员工，其中员工是多方，而部门是一方。
    * 1对1：例如老公和老婆就是一对一的关系，一个老公只能有一个老婆，一个老婆只能有一个老公。
    * 多对多：老师与学生的关系就是多对多，一个老师可以有多个学生，一个学生可以有多个老师。

## 4.6 外键约束

* 外键**可以为空**
* 外键**可以重复**
* 外键必须是另一表(可以是自己)的主键的值(**外键要引用主键**)
* 一张表中可以有**多个外键**

* 语法：**CONSTRAINT** 约束名称 **FOREIGN** **KEY**(外键列名) **REFERENCES** 关联表(关联表的主键) 

  ```mysql
  CONSTRAINT 约束名称 FOREIGN KEY(外键列名) REFERENCES 关联表(关联表的主键) 
  ```

  * **创建表时指定外键约束**

    ```mysql
    create talbe emp (
        empno int primary key,
        ...
        deptno int,
        CONSTRAINT fk_emp_dpet FOREIGN KEY(dpetno) REFERENCES dpet(dpetno)
        /*CONSTRAINT fk_emp FOREIGN KEY(mgr) REFERENCES emp(empno)*/
    );
    ```

  * **修改表时添加外键约束**

    ```mysql
    ALERT TABLE emp
    ADD CONSTRAINT fk_emp_dept FOREIGN KEY(deptno) REFERENCES dept(deptno);
    ```

  * **修改表时删除外键约束**

    ```mysql
    ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept;/*约束名称*/
    ```

### 4.6.1 一对一关系

* 从表中**外键**又是**主键**（外键保证主表必须有记录；主键保证记录唯一）

  ```mysql
  create table husband(
      hid int PRIMARY KEY,
      ...
  );
  create table wife(
      wid int PRIMARY KEY,
      ...
      ADD CONSTRAINT fk_wife_wid FOREIGN KEY(wid) REFERENCES husband(hid)
  );
  ```

### 4.6.2 多对多关系

* 需要使用**中间表**，在中间表中使用两个**外键**，分别引用其他两个表的主键

  ```mysql
  create table student(
    sid int PRIMARY KEY,
    ...
  );
  create table teacher(
    tid int PRIMARY KEY,
    ...
  );
  create table stu_tea(
    sid int,
    tid int,
    ADD CONSTRAINT fk_stu_tea_sid FOREIGN KEY(sid) REFERENCES student(sid),
    ADD CONSTRAINT fk_stu_tea_tid FOREIGN KEY(tid) REFERENCES teacher(tid)
  );
  ```

# 5 多表查询

## 5.1 合并结果集(了解)

 * 要求被合并的表中（结果集），列的类型和列数相同
     * UNION，去除重复行
     * UNION ALL，不去除重复行

## 5.2 连接查询

### 5.2.1 内连接(INNER JOIN...ON)

* 需要去除笛卡尔积中不需要的数据；内连接查询出的所有记录都满足条件

* 标准(**INNER JOIN...ON**)

    ```mysql
    SELECT * FROM 表1 (AS) 别名1 INNER JOIN 表2 别名2 ON 别名1.xx=别名2.xx
    ```

* 方言(,   WHERE)

    ```mysql
    SELECT * FROM 表1 别名1, 表2 别名2 WHERE 别名1.xx=别名2.xx
    ```

* 自然

    ```mysql
    SELECT * FROM 表1 别名1 NATURAL JOIN 表2 别名2
    ```

### 5.2.2 外连接(* JOIN...ON)

* **左外**(**LEFT JOIN...ON**)

  左表记录无论是否满足条件都会查询出，而右表满足条件才能查出。左表中不满条件的记录，右表补NULL

  ```mysql
  SELECT * FROM 表1 别名1 LEFT OUTER JOIN 表2 别名2 ON 别名1.xx=别名2.xx
  ```

  * 左外自然；NATURAL ，不用加on

* **右外**(**RIGHT JOIN**)

  右表记录无论是否满足条件都会查询出，而左表满足条件才能查出。右表中不满条件的记录，左表补NULL

  ```mysql
  SELECT * FROM 表1 别名1 RIGHT OUTER JOIN 表2 别名2 ON 别名1.xx=别名2.xx
  ```

  * 右外自然：NATURAL ，不用加on

* **全连接**：可以使用UNION来完成全链接

## 5.3 子查询

* 查询中有查询（查看select关键字的个数！）

* FROM后作为表存在(多行多列)

  * **多行多列**

    ```mysql
    SELECT * FROM 表1 别名1 , (SELECT ....) 别名2 WHERE 条件
    ```

* WHERE后作为条件存在

  * **单行单列**

    ```mysql
    SELECT * FROM 表1 别名1 WHERE 列1 [=、>、<、>=、<=、!=] (SELECT 列 FROM 表2 别名2 WHERE 条件)
    ```

  * 多行单列(IN,ALL,ANY)

    ```mysql
    SELECT * FROM 表1 别名1 WHERE 列1 [IN, ALL, ANY] (SELECT 列 FROM 表2 别名2 WHERE 条件)
    ```

  * 单行多列

    ```mysql
    SELECT * FROM 表1 别名1 WHERE (列1,列2) IN (SELECT 列1, 列2 FROM 表2 别名2 WHERE 条件)
    ```


# 6 DQL练习

## 6.1 单表查询

* 找出奖金高于工资60%的员工

  ```mysql
  SELECT * FROM emp
  WHERE COMM>SAL*0.6;
  ```

* 找出部门编号10所有经理，部门编号20中所有销售员，即不是经理又不是销售员但其工资大或等于20000的...

  ```mysql
  select * from emp
  where (DEPTNO=10 AND JOB='经理') OR (DEPTNO=20 AND JOB='销售员') OR (JOB NOT IN('经理','销售员') AND SAL>=20000);
  ```

* 查询2000年入职的员工

  ```mysql
  select * from emp
  WHERE HIREDATE LIKE '2002%';
  ```

* 查询所有员工详细信息，用工资降序排序，如果工资相同使用入职日期升序排序

  ```mysql
  select * from emp
  order by SAL desc,HIREDATE ASC;
  ```

* 查询每种工作的最高工资、最低工资、平均工资、人数

  ```mysql
  select JOB,AVG(SAL) 平均工资,MAX(SAL) AS 最高工资,MIN(SAL)最低工资,COUNT(*) 人数 from emp
  group by JOB;
  ```

* 有奖金的工种

  ```mysql
  select JOB FROM emp
  where COMM IS NOT NULL
  group by JOB;
  ```

* 显示非销售人员工作名称以及从事同一工作雇员的月工资的总和，并且要满足从事同一工作的雇员的月工资合计大于50000，输出结果按月工资的合计升序排列

  ```mysql
  select JOB,SUM(SAL) FROM EMP
  GROUP BY JOB
  HAVING SUM(SAL)>50000 AND JOB!='销售员'
  ORDER BY SUM(SAL) ASC;
  ```

## 6.2 多表查询

* 查出至少有一个员工的部门。显示部门编号、部门名称、部门位置、部门人数

  ```mysql
  SELECT D.*,I.CNT
  FROM dept D INNER JOIN (SELECT DEPTNO,COUNT(*) CNT FROM EMP GROUP BY EMP.DEPTNO) I
  ON D.DEPTNO=I.DEPTNO;
  ```

* 列出薪金比关羽高的所有员工

  ```mysql
  SELECT * 
  FROM emp
  WHERE sal>(SELECT sal FROM emp WHERE ename='关羽')
  ```

* 列出所有员工的姓名及其直接上级的姓名

  ```mysql
  SELECT E1.ename,IFNULL(E2.ename,'BOSS') 领导
  FROM emp E1 LEFT OUTER JOIN emp E2
  ON E1.mgr=E2.empno;
  ```

* 列出受雇日期早于直接上级的所有员工的编号、姓名、部门名称(**三张表**)

  ```mysql
  SELECT E1.empno,E1.ename,D.dname
  FROM emp E1 INNER JOIN emp E2 INNER JOIN dept D
  ON E1.mgr=E2.empno AND E1.deptno=D.deptno AND E1.hiredate<E2.hiredate;
  ```

* 列出薪金高于公司平均薪金的所有员工信息，所在部门名称，上级领导，工资等级(**四张表**)

  ```mysql
  SELECT E1.*,D.dname,E2.ename,S.grade
  FROM emp E1 LEFT JOIN emp E2 ON E1.mgr=E2.empno
  			LEFT JOIN dept D ON E1.deptno=D.deptno
              LEFT JOIN salgrade S ON E1.sal BETWEEN S.losal AND S.hisal
  WHERE E1.sal>(SELECT AVG(sal) FROM emp);
  ```

* **查出年份、利润、年度增长比**

  ```mysql
  SELECT E1.*,IFNULL(CONCAT((E1.zz-E2.zz)/E2.zz*100,'%'),0)
  FROM lirun E1 LEFT JOIN lirun E2 ON E1.`year`=E2.`year`+1
  ORDER BY E1.`year` ASC;
  ```







# 7 JDBC

* JDBC（Java DataBase Connectivity）就是Java数据库连接，说白了就是用Java语言来操作数据库

## 7.1 步骤

```JAVA
Connection connection = null;
Statement statement = null;
ResultSet resultSet = null;
try {
    //1.注册驱动。类中有静态代码块，自动注册到DriverManager中（4.0之后不用写）
    Class.forName("com.mysql.jdbc.Driver");
    
    //2.通过DriverManager获得连接.
    connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/exam111","root","w19");
    //在使用6以上版本时，会碰到时区异常，需要在url添加?serverTimezone=UTC
    
    //3.获得语句执行者。1.executeUpdate执行DDL，DML;2.executeQuery执行DQL
    statement = connection.createStatement();
    
    //4.执行SQL语句。1.返回改变的行数(int型);2.返回ResultSet
    statement.executeUpdate("INSERT INTO stu VALUES ('0002','李四','女')");//增
    statement.executeUpdate("delete from stu");//删
    statement.executeUpdate("update stu set sname='王八蛋' where sid='0001'");//改
    resultSet = statement.executeQuery("select * from stu");//查
    while(resultSet.next()){
        System.out.println("sid="+resultSet.getObject(1)+                   		         ",sname="+resultSet.getString(2)+",gander="+resultSet.getString("gander"));
    }
} catch (Exception e) {
    throw new RuntimeException(e);
} finally {
    try {
        //5.关闭
        if(resultSet!=null) resultSet.close();
        if(statement!=null) statement.close();
        if(connection!=null) connection.close();

    } catch (SQLException e) {
        e.printStackTrace();
    }
}

```

* **ResultSet**就是一张二维的表格，它内部有一个“行光标”，光标默认的位置在“第一行上方”，我们可以调用对象的next()方法把“行光标”向下移动一行，当第一次调用next()方法时，“行光标”就到了第一行记录位置
* 不确定数据类型使用**getObject**()方法

## 7.2 PreparedStatement

* 好处：

  * 防SQL攻击
  * 提高代码的可读性、可维护性
  * 提高效率

* 用法：

  * 给出SQL模板！

  * 调用Connection的PreparedStatement prepareStatement(String sql模板)；

  * 调用pstmt的setXxx()系列方法sql模板中的?赋值！

  * 调用pstmt的executeUpdate()或executeQuery()，但它的方法都没有参数。

    ```java
    String sql = "select * from tab_student where s_number=?";
    PreparedStatement pstmt = con.prepareStatement(sql);
    pstmt.setString(1, "S_1001");
    ResultSet rs = pstmt.executeQuery();
    ```


## 7.3 JdbcUtils工具类

* 连接数据库的四大参数是：驱动类、url、用户名，以及密码。让JdbcUtils工具类从配置文件中读取配置参数，然后创建连接对象

## 7.4 UserDao

* DAO（Data Access Object）模式就是写一个类，把**访问数据库的代码封装**起来。在数据库与业务逻辑之间

  * 实体域，即操作的对象，例如我们操作的表是user表，那么就需要先写一个User类；

  * DAO模式需要先提供一个DAO接口；

  * 然后再提供一个DAO接口的实现类；

  * 再编写一个DAO工厂，Service通过工厂来获取DAO实现。

* 把UserDao修改为接口，然后把原来的UserDao修改类名为UserDaoImpl

  修改UserService中对UserDao的实例化：private UserDao userDao = DaoFactory.getUserDao()

  创建DaoFactory，提供getUserDao()



## 7.3 时间问题

* 数据库类型与java中类型的对应关系

  * java.**util.Date**--->java.**sql**.Date、Time、Timestamp

    * 把util的Date转换成毫秒值

      使用毫秒值创建sql的Date、Time、Timestamp

  * java.sql.Date、Time、Timestamp--->java.util.Date

    * 这一步不需要处理了：因为java.sql.Date是java.util.Date子类

  ```java
  java.util.Date date = new java.util.Date();
  long l = date.getTime();
  java.sql.Date sqlDate = new java.sql.Date(l);
  ```


# 8 事务

## * 8.1 事务的四大特性（ACID）

* **原子性**（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。

* **一致性**（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。

* **隔离性**（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。

* **持久性**（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。


## 8.2 MySQL中操作事务

* 开启事务：**start transaction**

* 结束事务：**commit**或**rollback**

## 8.3 JDBC中操作事务

* 在JDBC中处理事务，都是通过**Connection**完成。同一事务中所有的操作，都在使用**同一个Connection对象**

* **Connection**的三个方法与事务相关：

  * **setAutoCommit**(boolean)：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置**false**，那么就相当于开启了事务了；

  * **commit**()：提交事务

  * **rollback**()：回滚事务

## 8.4 事务的隔离级别

* 并发事务**问题**
  * **脏读**：读到另一个事务的**未提交更新数据**，即读取到了脏数据
  * **不可重复读**：对同一记录的两次读取不一致，因为另一事务对该记录做了修改
  * **幻读**（虚读）：对同一张表的两次查询不一致，因为另一事务插入了一条记录

* **四大隔离级别**

  * SERIALIZABLE（**串行化**）

    * 不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的；

    * 性能最差；

  * REPEATABLE READ（**可重复读**）（MySQL）

    * 防止脏读和不可重复读，不能处理幻读问题；
    * 性能比SERIALIZABLE好

  * READ COMMITTED（**读已提交数据**）（Oracle）

    * 防止脏读，没有处理不可重复读，也没有处理幻读；
    * 性能比REPEATABLE READ好

  * READ UNCOMMITTED（**读未提交数据**）

    * 可能出现任何事务并发问题
    * 性能最好

## 8.5 ThreadLocal

* ThreadLocal内部其实是个Map来保存数据。虽然在使用ThreadLocal时只给出了值，没有给出键，其实它内部使用了当前线程做为键
* 三个方法
  * void set(T value)：保存值；
  * T get()：获取值；
  * void remove()：移除值。


# 9 数据库连接池

* 连接池也是使用**四大连接参数**来完成创建连接对象
* 连接池必须实现：**javax**.sql.DataSource接口
* 连接池返回的Connection对象，它的close()方法与众不同！调用它的close()不是关闭，而是把连接归还给池！
* DBCP连接池

  * DBCP是Apache提供的一款开源免费的数据库连接池
* **C3P0连接池**

  * C3P0也是开源免费的连接池！C3P0被很多人看好

    * 代码配置

    ```java
    //创建连接池对象
    ComboPooledDataSource dataSource = new ComboPooledDataSource();
    //对池进行四大参数配置
    dataSource.setDriverClass("com.mysql.jdbc.Driver");
    dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/exam?serverTimezone=UTC");
    dataSource.setUser("root");
    dataSource.setPassword("w1994h1127n");
    Connection connection = dataSource.getConnection();
    ```

    * xml文件配置
      * 文件名称：必须叫c3p0-config.xml；文件位置：必须在src下

## 9.1 装饰者模式

* 对象增强的手段：
  * **继承**：会使**类增多**
    * 特点：增强的内容是死的、被增强的对象也是死的
  * **装饰者模式**（不知被增强对象具体类型，”**是你还有你、一切拜托你**“）
    * 特点：增强的内容是死的、被增强的对象可以是任意的。如IO流
  * 动态代理
    * 特点：增强的内容可以任意、被增强的对象也是任意的

## 9.2 common-dbutils.jar

* QueryRunner
  * update方法：

    * int update(String sql, Object... params) -->  可执行增、删、改语句
    * int update(Connection con, String sql, Object... parmas) --> 需要调用者提供Connection，这说明本方法不再管理Connection了。支持事务!

  * query方法：

    * T query(String sql, ResultSetHandler rsh, Object... params) --> 可执行查询

      它会先得到ResultSet，然后调用rsh的handle()把rs转换成需要的类型！

    * T query(Connection con, String sql, ResultSetHadler rsh, Object... params)，支持事务



* ResultSetHandler接口：
  * BeanHandler(单行) --> 构造器需要一个Class类型的参数，用来把一行结果转换成指定类型的javaBean对象
  * BeanListHandler(多行) --> 构造器也是需要一个Class类型的参数，用来把一行结果集转换成一个javabean，那么多行就是转换成List对象，一堆javabean
  * MapHandler(单行) --> 把一行结果集转换Map对象
  * MapListHandler(多行) --> 把一行记录转换成一个Map，多行就是多个Map，即List< Map>！
  * ScalarHandler(单行单列) --> 通常用与select count(*) from t_stu语句！结果集是单行单列的！它返回一个Object
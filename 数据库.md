# 1 数据库简介

- 数据库就是用来**存储和管理**数据的仓库
- 数据库管理系统（DBMS，数据的仓库）的概述
  - 方便查询；可存储的数据量大；保证数据的完整、一致；安全可靠
  - RDBMS（关系型数据库管理系统）使用表格存储数据
- 常见数据库
  - Oracle（神喻）：甲骨文（最高！）
  - **MySQL**：甲骨文
  - SQL Server：微软
  - SQLite：嵌入式小型数据库，应用在手机端
  - DB2：IBM，常用于银行系统
  - Sybase：赛尔斯
- **RDBMS** = 管理员（**manager**）+仓库（**database**）
  - database = N个**table**
    - **表结构**：定义表的列名和列类型
    - **表记录**：一行一行的记录
- **MySQL重要文件夹**
  - C:\Program Files\MySQL\MySQL Server 8.0：**DBMS管理程序**
  - C:\ProgramData\MySQL\MySQL Server 8.0\data：**DBMS数据库文件**（卸载MySQL时不会删除这个目录）
    - 每个目录表示一个数据库，，每个数据库目录下会有0~N个扩展名为ibd的table文件
- **MySQL重要文件**
  - C:\Program Files\MySQL\MySQL Server 8.0\bin\ **mysqld**.exe：**服务器程序**，必须先启动它
  - C:\Program Files\MySQL\MySQL Server 8.0\bin\ **mysql**.exe：**客户端程序**操作服务器，服务器必须先开启
  - D:\Program Files\MySQL\MySQL Server 5.1\bin\ **my.ini**：**服务器配置文件**
    - 配置MySQL的端口：默认为3306，没有必要去修改它；
    - 配置字符编码：
      - [client]下配置客户端编码：default-character-set=gbk
      - [mysqld]下配置服务器编码：character-set-server=utf8
    - 配置二进制数据大小上限：
      - 在[mysqld]下配置：max_allowed_packet=8M
- **服务器操作**
  - 开启服务器(必须保证mysql为windows服务)：**net start mysql**，mysqld.exe进程存在
  - 关闭服务器(必须保证mysql为windows服务)：**net stop mysql**，mysqld.exe进程不存在
- **客户端操作**
  - 登录服务器：**mysql -uroot -p123 -hlocalhost**
  - 退出服务器：**exit或quit**



# 2 SQL

* **结构化查询语言**(Structured Query Language)

  * 作用：**客户端使用SQL来操作服务器**

* **SQL语法**

  * SQL语句可以在**单行或多行**书写，以**分号结尾**
  * 可使用空格和缩进来增强语句的可读性
  * MySQL不区别大小写，**建议使用大写**

* SQL语句**分类**

  * **DDL**（Data Definition Language）：**数据定义语言**

    数据库或表的**结构**操作，创建、删除、修改：库、表结构

  * **DML**（Data Manipulation Language）：**数据操作语言**

    对表的**记录**进行更新（增、删、改）

  * **DQL**（Data Query Language）：**数据查询语言**，用来查询记录数据

  * DCL（Data Control Language）：数据控制语言，用来对用户的创建，及授权

## 2.1 DDL

### 2.1.1 数据库(DATABASE)

* <span style="color:red;font-weight:bold">创建数据库(CREATE DATABASE)</span>

  ```mysql
  CREATE DATABASE [IF NOT EXISTS] mydb1 [CHARSET=utf8];
  ```

* <span style="color:red;font-weight:bold">删除数据库(DROP DATABASE)</span>

  ```mysql
  DROP DATABASE [IF EXISTS] mydb1;
  ```

* <span style="color:red;font-weight:bold">查看所有数据库(SHOW DATABASES)</span>

  ```mysql
  SHOW DATABASES;
  ```

* <span style="color:red;font-weight:bold">切换数据库(USE 数据库名)</span>

  ```mysql
  USE 数据库名;
  ```

* 修改数据库编码

  ```mysql
  ALTER DATABASE mydb1 CHARACTER SET utf8;
  ```

### 2.1.2 数据类型(列类型)

* **int**：整型

  **double**：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；

  **decimal**：浮点型，在表示钱方面使用该类型，因为不会出现精度缺失问题；

  **char**：固定长度字符串类型； char(255)，数据的长度不足指定长度，补空格到指定长度！

  **varchar**：可变长度字符串类型； varchar(65535)

* text(clob)：**字符串类型**；tinytext(2^8-1B)、text(2^16-1B)、mediumtext(2^24-1B)、longtext(2^32-1B)

  blob：**字节类型**；tinytext(2^8-1B)、text(2^16-1B)、mediumtext(2^24-1B)、longtext(2^32-1B)

* 在数据库中所有的<span style="color:red;font-weight:bold">字符串类型，必须使用**单引**</span>，不能使用双引;日期类型也要使用单引！

### 2.1.3 表(TABLE)

* <span style="color:red;font-weight:bold">创建表(CREATE TABLE)</span>

  ```mysql
  CREATE TABLE [IF NOT EXISTS] 表名(
    列名 列类型,
    列名 列类型,
    ...
    列名 列类型
  );
  ```

* <span style="color:red;font-weight:bold">删除表(DROP TABLE)</span>

  ```mysql
  DROP TABLE 表名;
  ```

* <span style="color:red;font-weight:bold">查看当前数据库中所有表名称(SHOW TABLES)</span>

  ```mysql
  SHOW TABLES;
  ```

  <span style="color:red;font-weight:bold">查看表结构(DESC)</span>

  ```mysql
  DESC 表名;
  ```

  查看指定表的创建语句(了解)

  ```mysql
  SHOW CREATE TABLE 表名;
  ```

* <span style="color:red;font-weight:bold">修改表</span>：前缀：<span style="color:red;font-weight:bold">ALTER TABLE 表名</span>

  * 修改<span style="color:red;font-weight:bold">表名称(RENAME TO</span>)

    ```mysql
    ALTER TABLE 原表名 RENAME TO 新表名;
    ```

  * 修改之<span style="color:red;font-weight:bold">添加列(ADD)</span>

    ```mysql
    ALTER TABLE 表名 ADD (
        列名 列类型,
        列名 列类型,
        ...
    );
    ```

  * 修改之<span style="color:red;font-weight:bold">删除列(DROP)</span>

    ```mysql
    ALTER TABLE 表名 DROP 列名;
    ```

  * 修改之<span style="color:red;font-weight:bold">修改列名类型(CHANGE)</span>

    ```mysql
    ALTER TABLE 表名 CHANGE 原列名 新列名 列类型 主键自增长;//新的类型可能会影响到已存在数据
    ```

  * 修改之<span style="color:red;font-weight:bold">修改列类型(MODIFY)</span>

    ```mysql
    ALTER TABLE 表名 MODIFY 列名 列类型;//新的类型可能会影响到已存在数据
    ```

## 2.2 DML

* <span style="color:red;font-weight:bold">插入数据(INSERT INTO)</span>

  ```mysql
  INSERT INTO 表名(
      列名1,列名2, ...
  ) VALUES(列值1, 列值2, ...);
  //没有指定的列等同与插入null值,插入记录总是插入一行
  ```

  ```mysql
  INSERT INTO 表名 
  VALUES(列值1, 列值2);
  //插入所有列。值的顺序，必须与表创建时给出的列的顺序相同
  ```

* <span style="color:red;font-weight:bold">删除数据(DELETE FROM)</span>

  ```mysql
  DELETE FROM 表名 [WHERE 条件];
  ```

* <span style="color:red;font-weight:bold">修改数据(UPDATE...SET)</span>

  ```mysql
  UPDATE 表名 SET 列名1=列值1, 列名2=列值2, ... [WHERE 条件]
  ```

  * **条件(可选的)**

    * 条件必须是一个boolean类型的值或表达式

    * 运算符：=、!=、<>、>、<、>=、<=、BETWEEN...AND、IN(...)、IS NULL、NOT、OR、AND

      ```mysql
      WHERE age >= 18 AND age <= 80
      WHERE age BETWEEN 18 AND 80
      WHERE name='zhangSan' OR name='liSi'
      WHERE name IN ('zhangSan', 'liSi')
      WHERE age IS NULL, 不能使用等号
      WHERE age IS NOT NULL
      ```

## 2.3 DQL

* <span style="color:red;font-weight:bold">查询不会修改数据库表记录！</span>
* <span style="color:red;font-weight:bold">顺序：SELECT、FROM、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT</span>

### 2.3.1 基本查询

* <span style="color:red;font-weight:bold">字段(列)控制</span>

  * <span style="color:red;font-weight:bold">查询列(SELECT...FROM)</span>

    ```mysql
    SELECT * FROM 表名;//其中“*”表示查询所有列
    ```

    ```mysql
    SELECT 列1 [, 列2, ... 列N] FROM 表名;//查询指定列
    ```

  * 完全重复的<span style="color:red;font-weight:bold">记录只一次(DISTINCT</span>)

    ```mysql
    SELECT DISTINCT 列1 [, 列2, ... 列N]  FROM 表名;
    ```

  * <span style="color:red;font-weight:bold">列运算</span>

    * 数量类型的列可以做<span style="color:red;font-weight:bold">加、减、乘、除</span>运算

      ```mysql
      SELECT sal*1.5 FROM emp;
      SELECT sal+comm FROM emp;
      ```

    * 字符串类型可以做<span style="color:red;font-weight:bold">连续运算</span>

      ```mysql
      SELECT CONCAT('$', sal) FROM emp;
      ```

    * <span style="color:red;font-weight:bold">转换NULL值</span>

      ```mysql
      SELECT IFNULL(comm, 0)+1000 FROM emp;//如果comm中存在NULL值，那么当成0来运算
      ```

    * <span style="color:red;font-weight:bold">给列起别名</span>

      ```mysql
      SELECT IFNULL(comm, 0)+1000 AS 奖金 FROM emp;//AS可以省略
      ```

* <span style="color:red;font-weight:bold">条件控制</span>

  * <span style="color:red;font-weight:bold">条件查询(WHERE)</span>

    ```mysql
    SELECT empno,ename,sal,comm FROM emp WHERE sal > 10000 AND comm IS NOT NULL;
    SELECT empno,ename,sal FROM emp WHERE sal BETWEEN 20000 AND 30000;
    SELECT empno,ename,job FROM emp WHERE job IN ('经理', '董事长');
    ```

  * <span style="color:red;font-weight:bold">模糊查询(LIKE)</span>

    * <span style="color:red;font-weight:bold">_匹配一个任意字符</span>

      ```mysql
      SELECT * FROM emp WHERE ename LIKE '张_';/*姓张，名字由两个字组成的员工*/
      SELECT * FROM emp WHERE ename LIKE '___'; /*姓名由3个字组成的员工*/
      ```

    * <span style="color:red;font-weight:bold">%匹配0~N个任意字符</span>

      ```mysql
      SELECT * FROM emp WHERE ename LIKE '张%';/*查询的是姓张的所有员工*/
      SELECT * FROM emp WHERE ename LIKE '%阿%';/*查询姓名中间带有阿字的员工*/
      SELECT * FROM emp WHERE ename LIKE '%';/*条件不存在，如果姓名为NULL的查询不出来*/
      ```

### 2.3.2 排序(ORDER BY..*SC)

* <span style="color:red;font-weight:bold">升序(ORDER BY...ASC)</span>

  ```mysql
  SELECT * FROM WHERE emp ORDER BY sal ASC;//ASC是可以省略的
  ```

* <span style="color:red;font-weight:bold">降序(ORDER BY...DESC)</span>

  ```mysql
  SELECT * FROM WHERE emp ORDER BY comm DESC;//DESC不能省略
  ```

* 多列作为排序条件

  ```mysql
  SELECT * FROM WHERE emp ORDER BY sal ASC, comm DESC;//sal升序排，如果sal相同，comm降序排
  ```

### 2.3.3 聚合函数(列的纵向运算)

* 一般用于**分组后**的统计

* <span style="color:red;font-weight:bold">COUNT</span>

  ```mysql
  SELECT COUNT(*) FROM emp;//计算emp表中所有列都不为NULL的记录的行数
  SELECT COUNT(comm) FROM emp;//计算emp表中comm列不为NULL的记录的行数
  ```

* <span style="color:red;font-weight:bold">MAX</span>

  ```mysql
  SELECT MAX(sal) FROM emp;//查询最高工资
  ```

* <span style="color:red;font-weight:bold">MIN</span>

  ```mysql
  SELECT MIN(sal) FROM emp;//查询最低工资
  ```

* <span style="color:red;font-weight:bold">SUM</span>

  ```mysql
  SELECT SUM(sal) FROM emp;//查询工资合计
  ```

* <span style="color:red;font-weight:bold">AVG</span>

  ```mysql
  SELECT AVG(sal) FROM emp;//查询平均工资
  ```

### 2.3.4 分组查询(GROUP BY)

* **记录使用某一列进行<span style="color:red;font-weight:bold">分组(GROUP BY)</span>，然后查询组信息**

  ```mysql
  SELECT deptno, COUNT(*) FROM emp GROUP BY deptno;//deptno分组，查询部门编号和每个部门记录
  SELECT job, MAX(SAL) FROM emp GROUP BY job;//使用job分组，查询每种工作的最高工资
  ```

* <span style="color:red;font-weight:bold">组条件(HAVING)</span>

  ```mysql
  SELECT deptno, COUNT(*) FROM emp GROUP BY deptno HAVING COUNT(*) > 3;
  //以部门分组，查询每组记录数。条件为记录数大于3
  ```

### 2.3.5 limit子句(方言)

* LIMIT用来限定查询结果的**起始行**，以及**总行数**

  ```mysql
  /*1. 一页的记录数：10行;2. 查询第3页*/
  select * from emp limit 20, 10;
  /* (当前页-1) * 每页记录数*/
  ```



# 3 编码、备份

* 查看MySQL数据库编码

  ```mysql
  SHOW VARIABLES LIKE 'char%';
  ```

  * **character_set_client**：MySQL使用该编码来解读客户端发送过来的数据，例如该编码为UTF8，那么如果客户端发送过来的数据不是UTF8，那么就会出现乱码。8.0默认为gbk。

    * **character_set_results**：MySQL会把数据转换成该编码后，再发送给客户端，例如该编码为UTF8，那么如果客户端不使用UTF8来解读，那么就会出现乱码。8.0默认为gbk。

  * 在my.ini中设置(8.0中默认没有值，但默认为gbk)

    ```ini
    default-character-set=gbk
    #可以修改三个变量：client、results、connection
    ```

* 数据库导出SQL脚本(备份数据库**内容**，并不是备份数据库！)

  **生成的脚本文件中不包含create database语句**

  ```powershell
  # mysqldump –u用户名 –p密码 数据库名 > 生成的脚本文件路径
  mysqldump -uroot -p123 mydb1 > C:\mydb.sql 
  
  #mysql workbench操作
  ```

* SQL脚本导入到数据库，要先创建数据库

  ```powershell
  #mysql -u用户名 -p密码 数据库 < 脚本文件路径
  mysql -uroot -p123 mydb1 < C:\mydb.sql
  
  #创建数据库，切换并执行如下
  source c:\mydb.sql
  
  ##mysql workbench操作
  ```



# 4 约束

* 约束是添加在列上的，用来**约束列**的

## 4.1 主键约束（PRIMARY KEY）

* 特点：**非空**、**唯一**、**被引用**（学习外键时）

  * **创建表时设置主键**

    ```mysql
    CREATE TABLE stu(
    	stuid CHAR(6) PRIMARY KEY
    );
    ```

    ```mysql
    CREATE TABLE stu(
    	stuid CHAR(6),
        PRIMARY KEY(stuid)
    );
    ```

  * **没有主键时添加主键**

    ```mysql
    ALTER TABLE stu ADD PRIMARY KEY(sid);
    ```

  * **删除主键**

    ```mysql
    ALTER TABLE stu DROP PRIMARY KEY;
    ```

## 4.2 主键自增长(AUTO_INCREMENT)

* 保证在插入数据时主键列的唯一和非空特性，一般用UUID

  * 创建表时指定主键自增长

    ```mysql
    CREATE TABLE stu(
    	stuid CHAR(6) PRIMARY KEY AUTO_INCREMENT
    );
    ```

  *  修改表时设置主键自增长

    ```mysql
    ALTER TABLE stu CHANGE sid sid INT AUTO_INCREMENT;
    ```

  * 修改表时删除主键自增长

    ```mysql
    ALTER TABLE stu CHANGE sid sid INT;
    ```

## 4.3 非空约束(NOT NULL)

*  因为某些列不能设置为NULL值，所以可以对列添加非空约束

  * 创建表时设置

    ```mysql
    CREATE TABLE stu(
    		sid INT PRIMARY KEY AUTO_INCREMENT,
    		sname	VARCHAR(20) NOT NULL,
      );
    ```

## 4.4 唯一约束(UNIQUE)

* 数据库某些列不能设置重复的值，所以可以对列添加唯一约束

  * 创建表时设置

    ```mysql
    CREATE TABLE stu(
    		sid INT PRIMARY KEY AUTO_INCREMENT,
    		sname	VARCHAR(20) NOT NULL UNIQUE
      );
    ```

## 4.5 概念模型

* 对象模型：可以双向关联，而且引用的是对象，而不是一个主键！在java中是domain！！！例如：User
* 关系模型：只能多方引用一方，而且引用的只是主键，而不是一整行记录。在数据库中就是表

* 当我们要完成一个软件系统时，需要把系统中的**实体抽取出来，形成概念模型**。  例如部门、员工都是系统中的实体。概念模型中的实体最终会成为**Java中的类**、**数据库中表**。实体之间还存在着关系：
  * 1对多：例如每个员工都从属一个部门，而一个部门可以有多个员工，其中员工是多方，而部门是一方。
    * 1对1：例如老公和老婆就是一对一的关系，一个老公只能有一个老婆，一个老婆只能有一个老公。
    * 多对多：老师与学生的关系就是多对多，一个老师可以有多个学生，一个学生可以有多个老师。

## 4.6 外键约束

* 外键**可以为空**
* 外键**可以重复**
* 外键必须是另一表(可以是自己)的主键的值(**外键要引用主键**)
* 一张表中可以有**多个外键**

* 语法：**CONSTRAINT** 约束名称 **FOREIGN** **KEY**(外键列名) **REFERENCES** 关联表(关联表的主键) 

  ```mysql
  CONSTRAINT 约束名称 FOREIGN KEY(外键列名) REFERENCES 关联表(关联表的主键) 
  ```

  * **创建表时指定外键约束**

    ```mysql
    create talbe emp (
        empno int primary key,
        ...
        deptno int,
        CONSTRAINT fk_emp_dpet FOREIGN KEY(dpetno) REFERENCES dpet(dpetno)
        /*CONSTRAINT fk_emp FOREIGN KEY(mgr) REFERENCES emp(empno)*/
    );
    ```

  * **修改表时添加外键约束**

    ```mysql
    ALERT TABLE emp
    ADD CONSTRAINT fk_emp_dept FOREIGN KEY(deptno) REFERENCES dept(deptno);
    ```

  * **修改表时删除外键约束**

    ```mysql
    ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept;/*约束名称*/
    ```

### 4.6.1 一对一关系

* 从表中**外键**又是**主键**（外键保证主表必须有记录；主键保证记录唯一）

  ```mysql
  create table husband(
      hid int PRIMARY KEY,
      ...
  );
  create table wife(
      wid int PRIMARY KEY,
      ...
      ADD CONSTRAINT fk_wife_wid FOREIGN KEY(wid) REFERENCES husband(hid)
  );
  ```

### 4.6.2 多对多关系

* 需要使用**中间表**，在中间表中使用两个**外键**，分别引用其他两个表的主键

  ```mysql
  create table student(
    sid int PRIMARY KEY,
    ...
  );
  create table teacher(
    tid int PRIMARY KEY,
    ...
  );
  create table stu_tea(
    sid int,
    tid int,
    ADD CONSTRAINT fk_stu_tea_sid FOREIGN KEY(sid) REFERENCES student(sid),
    ADD CONSTRAINT fk_stu_tea_tid FOREIGN KEY(tid) REFERENCES teacher(tid)
  );
  ```

# 5 多表查询

## 5.1 合并结果集(了解)

 * 要求被合并的表中（结果集），列的类型和列数相同
     * UNION，去除重复行
     * UNION ALL，不去除重复行

## 5.2 连接查询

### 5.2.1 内连接(INNER JOIN...ON)

* 需要**去除笛卡尔积中不需要的数据**；内连接查询出的所有记录都满足条件

* 标准(**INNER JOIN...ON**)

    ```mysql
    SELECT * FROM 表1 (AS) 别名1 INNER JOIN 表2 别名2 ON 别名1.xx=别名2.xx
    ```

* 方言(,   WHERE)

    ```mysql
    SELECT * FROM 表1 别名1, 表2 别名2 WHERE 别名1.xx=别名2.xx
    ```

* 自然

    ```mysql
    SELECT * FROM 表1 别名1 NATURAL JOIN 表2 别名2
    ```

### 5.2.2 外连接(* JOIN...ON)

* **左外**(**LEFT JOIN...ON**)

  左表记录无论是否满足条件都会查询出，而右表满足条件才能查出。左表中不满条件的记录，右表补NULL

  ```mysql
  SELECT * FROM 表1 别名1 LEFT OUTER JOIN 表2 别名2 ON 别名1.xx=别名2.xx
  ```

  * 左外自然；NATURAL ，不用加on

* **右外**(**RIGHT JOIN**)

  右表记录无论是否满足条件都会查询出，而左表满足条件才能查出。右表中不满条件的记录，左表补NULL

  ```mysql
  SELECT * FROM 表1 别名1 RIGHT OUTER JOIN 表2 别名2 ON 别名1.xx=别名2.xx
  ```

  * 右外自然：NATURAL ，不用加on

* **全连接**：可以使用UNION来完成全链接

## 5.3 子查询

* 查询中有查询（查看select关键字的个数！）

* FROM后作为表存在(多行多列)

  * **多行多列**

    ```mysql
    SELECT * FROM 表1 别名1 , (SELECT ....) 别名2 WHERE 条件
    ```

* WHERE后作为条件存在

  * **单行单列**

    ```mysql
    SELECT * FROM 表1 别名1 WHERE 列1 [=、>、<、>=、<=、!=] (SELECT 列 FROM 表2 别名2 WHERE 条件)
    ```

  * 多行单列(IN,ALL,ANY)

    ```mysql
    SELECT * FROM 表1 别名1 WHERE 列1 [IN, ALL, ANY] (SELECT 列 FROM 表2 别名2 WHERE 条件)
    ```

  * 单行多列

    ```mysql
    SELECT * FROM 表1 别名1 WHERE (列1,列2) IN (SELECT 列1, 列2 FROM 表2 别名2 WHERE 条件)
    ```


# 6 DQL练习

## 6.1 单表查询

* 找出奖金高于工资60%的员工

  ```mysql
  SELECT * FROM emp
  WHERE COMM>SAL*0.6;
  ```

* 找出部门编号10所有经理，部门编号20中所有销售员，即不是经理又不是销售员但其工资大或等于20000的...

  ```mysql
  select * from emp
  where (DEPTNO=10 AND JOB='经理') OR (DEPTNO=20 AND JOB='销售员') OR (JOB NOT IN('经理','销售员') AND SAL>=20000);
  ```

* 查询2000年入职的员工

  ```mysql
  select * from emp
  WHERE HIREDATE LIKE '2002%';
  ```

* 查询所有员工详细信息，用工资降序排序，如果工资相同使用入职日期升序排序

  ```mysql
  select * from emp
  order by SAL desc,HIREDATE ASC;
  ```

* 查询每种工作的最高工资、最低工资、平均工资、人数

  ```mysql
  select JOB,AVG(SAL) 平均工资,MAX(SAL) AS 最高工资,MIN(SAL)最低工资,COUNT(*) 人数 from emp
  group by JOB;
  ```

* 有奖金的工种

  ```mysql
  select JOB FROM emp
  where COMM IS NOT NULL
  group by JOB;
  ```

* 显示非销售人员工作名称以及从事同一工作雇员的月工资的总和，并且要满足从事同一工作的雇员的月工资合计大于50000，输出结果按月工资的合计升序排列

  ```mysql
  select JOB,SUM(SAL) FROM EMP
  GROUP BY JOB
  HAVING SUM(SAL)>50000 AND JOB!='销售员'
  ORDER BY SUM(SAL) ASC;
  ```

## 6.2 多表查询

* 查出至少有一个员工的部门。显示部门编号、部门名称、部门位置、部门人数

  ```mysql
  SELECT D.*,I.CNT
  FROM dept D INNER JOIN (SELECT DEPTNO,COUNT(*) CNT FROM EMP GROUP BY EMP.DEPTNO) I
  ON D.DEPTNO=I.DEPTNO;
  ```

* 列出薪金比关羽高的所有员工

  ```mysql
  SELECT * 
  FROM emp
  WHERE sal>(SELECT sal FROM emp WHERE ename='关羽')
  ```

* 列出所有员工的姓名及其直接上级的姓名

  ```mysql
  SELECT E1.ename,IFNULL(E2.ename,'BOSS') 领导
  FROM emp E1 LEFT OUTER JOIN emp E2
  ON E1.mgr=E2.empno;
  ```

* 列出受雇日期早于直接上级的所有员工的编号、姓名、部门名称(**三张表**)

  ```mysql
  SELECT E1.empno,E1.ename,D.dname
  FROM emp E1 INNER JOIN emp E2 INNER JOIN dept D
  ON E1.mgr=E2.empno AND E1.deptno=D.deptno AND E1.hiredate<E2.hiredate;
  ```

* 列出薪金高于公司平均薪金的所有员工信息，所在部门名称，上级领导，工资等级(**四张表**)

  ```mysql
  SELECT E1.*,D.dname,E2.ename,S.grade
  FROM emp E1 LEFT JOIN emp E2 ON E1.mgr=E2.empno
  			LEFT JOIN dept D ON E1.deptno=D.deptno
              LEFT JOIN salgrade S ON E1.sal BETWEEN S.losal AND S.hisal
  WHERE E1.sal>(SELECT AVG(sal) FROM emp);
  ```

* **查出年份、利润、年度增长比**

  ```mysql
  SELECT E1.*,IFNULL(CONCAT((E1.zz-E2.zz)/E2.zz*100,'%'),0)
  FROM lirun E1 LEFT JOIN lirun E2 ON E1.`year`=E2.`year`+1
  ORDER BY E1.`year` ASC;
  ```







# 7 JDBC

* JDBC（Java DataBase Connectivity）就是Java数据库连接，说白了就是用Java语言来操作数据库

## 7.1 步骤

* 导包

```JAVA
Connection connection = null;
Statement statement = null;
ResultSet resultSet = null;
try {
    //1.注册驱动。类中有静态代码块，自动注册到DriverManager中（4.0之后不用写）
    Class.forName("com.mysql.jdbc.Driver");
    
    //2.通过DriverManager获得连接.
    connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/exam111","root","w19");
    //在使用6以上版本时，会碰到时区异常，需要在url添加?serverTimezone=UTC
    
    //3.获得语句执行者。1.executeUpdate执行DDL，DML;2.executeQuery执行DQL
    statement = connection.createStatement();
    
    //4.执行SQL语句。1.返回改变的行数(int型);2.返回ResultSet
    statement.executeUpdate("INSERT INTO stu VALUES ('0002','李四','女')");//增
    statement.executeUpdate("delete from stu");//删
    statement.executeUpdate("update stu set sname='王八蛋' where sid='0001'");//改
    resultSet = statement.executeQuery("select * from stu");//查
    while(resultSet.next()){
        System.out.println("sid="+resultSet.getObject(1)+                   		         ",sname="+resultSet.getString(2)+",gander="+resultSet.getString("gander"));
    }
} catch (Exception e) {
    throw new RuntimeException(e);
} finally {
    try {
        //5.关闭
        if(resultSet!=null) resultSet.close();
        if(statement!=null) statement.close();
        if(connection!=null) connection.close();

    } catch (SQLException e) {
        e.printStackTrace();
    }
}

```

* **ResultSet**就是一张二维的表格，它内部有一个“行光标”，光标默认的位置在“第一行上方”，我们可以调用对象的next()方法把“行光标”向下移动一行，当第一次调用next()方法时，“行光标”就到了第一行记录位置
* 不确定数据类型使用**getObject**()方法或**getString**()方法

## 7.2 PreparedStatement

* **预编译声明**，是Statement接口的子接口。尽量使用这个而不是父类

* 好处：

  * 防SQL攻击
  * 提高代码的可读性、可维护性
  * **提高效率**（重复使用同一SQL模板）

* 用法：

  * 使用Connection的prepareStatement(String sql)：即创建它时就让它与一条SQL模板绑定；

  * 调用PreparedStatement的setXXX()系列方法为**?参数设置值**

  * 调用executeUpdate()或executeQuery()方法，但要注意，调用没有参数的方法

    ```java
    String sql = "select * from tab_student where s_number=?";
    PreparedStatement pstmt = con.prepareStatement(sql);
    pstmt.setString(1, "S_1001");
    ResultSet rs = pstmt.executeQuery();
    ```

* 预处理的原理

  * 服务器的工作：
    * 校验sql语句的语法！
    * 编译：一个与函数相似的东西！
    * 执行：调用函数

  * PreparedStatement：

    * 前提：连接的数据库必须支持预处理！几乎没有不支持的！

    * 每个pstmt都与一个sql模板绑定在一起，先把sql模板给数据库，数据库先进行校验，再进行编译。执行时只是把参数传递过去而已！

    * 若二次执行时，就不用再次校验语法，也不用再次编译！直接执行！

## 7.3 JdbcUtils工具类1.0

* 连接数据库的四大参数是：驱动类、url、用户名，以及密码。让JdbcUtils工具类从配置文件中读取配置参数，然后创建连接对象

## 7.4 面向接口编程(UserDao)

* DAO（Data Access Object）模式就是写一个类，把**访问数据库的代码封装**起来。在数据库与业务逻辑之间

  * 实体域，即操作的对象，例如我们操作的表是user表，那么就需要先写一个User类；

  * DAO模式需要先提供一个DAO接口；

  * 然后再提供一个DAO接口的实现类；

  * 再编写一个DAO工厂，Service通过工厂来获取DAO实现。

* 把UserDao修改为接口，然后把原来的UserDao修改类名为UserDaoImpl

  修改UserService中对UserDao的实例化：private UserDao userDao = DaoFactory.getUserDao()

  创建DaoFactory，提供getUserDao()

## 7.5 ORM(**对象关系映射**)

## 7.6 时间问题

* 领域对象（domain）中的所有属性不能出现java.sql包下的东西！即不能使用java.sql.Date；

  ResultSet#getDate()返回的是java.sql.Date()

  PreparedStatement#setDate(int, Date)，其中第二个参数也是java.sql.Date

* 数据库类型与java中类型的对应关系

  * java.**util.Date**--->java.**sql**.Date、Time、Timestamp

    * 把util的Date转换成毫秒值

      使用毫秒值创建sql的Date、Time、Timestamp

  * java.sql.Date、Time、Timestamp--->java.util.Date

    * 这一步不需要处理了：因为java.sql.Date是java.util.Date子类

  ```java
  java.util.Date date = new java.util.Date();
  long l = date.getTime();
  java.sql.Date sqlDate = new java.sql.Date(l);
  ```

## 7.7 大数据

* 目标：把mp3保存到数据库中。在my.ini中修改如下配置！max_allowed_packet=20M

* 所谓大数据，就是大的字节数据，或大的字符数据。标准SQL中提供了如下类型来保存大数据类型

  * clob(text)：**字符串类型**；tinytext(2^8-1B)、text(2^16-1B)、mediumtext(2^24-1B)、longtext(2^32-1B)
    * SQL中提供clob、blob，但是MySQL中没有clob，通过text替代
  * blob：**字节类型**；tinytext(2^8-1B)、text(2^16-1B)、mediumtext(2^24-1B)、longtext(2^32-1B)

* 数据库表为

  ```mysql
  CREATE TABLE tab_bin(
  	id 	INT 	PRIMARY KEY AUTO_INCREMENT,
  	filename	VARCHAR(100),
  	data 	MEDIUMBLOB
  );
  ```

* 向数据库**插入二进制数据**需要使用PreparedStatement为原**setBinaryStream**(int, InputSteam)方法来完成

  ```java
  con = JdbcUtils.getConnection();
  String sql = "insert into tab_bin(filename,data) values(?, ?)";
  pstmt = con.prepareStatement(sql);
  pstmt.setString(1, "a.jpg");
  InputStream in = new FileInputStream("f:\\a.jpg");
  pstmt.setBinaryStream(2, in);
  pstmt.executeUpdate();
  ```

* **读取二进制数据**，需要在查询后使用**ResultSet**类的**getBinaryStream**()方法来获取输入流对象

  ```java
  con = JdbcUtils.getConnection();
  String sql = "select filename,data from tab_bin where id=?";
  pstmt = con.prepareStatement(sql);
  pstmt.setInt(1, 1);
  rs = pstmt.executeQuery();
  rs.next();
  
  String filename = rs.getString("filename");
  OutputStream out = new FileOutputStream("F:\\" + filename);
  
  InputStream in = rs.getBinaryStream("data");
  IOUtils.copy(in, out);
  out.close();
  ```


## 7.8 批处理

* 批处理只针对更新（**增、删、改**）语句，批处理没有查询什么事儿
* MySQL的批处理也需要通过参数来打开：在四大参数之一url添加**rewriteBatchedStatements=true**

* Statement批处理。可以多次调用Statement类的addBatch(String sql)方法，把需要执行的所有SQL语句添加到一个“批”中，然后调用Statement类的executeBatch()方法来执行当前“批”中的语句

  * void addBatch(String sql)：添加一条语句到“批”中
  * int[] executeBatch()：执行“批”中所有语句。返回值表示每条语句所影响的行数据
  * void clearBatch()：清空“批”中的所有语句

* **PreparedStatement批处理**。因为每个PreparedStatement对象都绑定一条SQL模板。所以向PreparedStatement中添加的不是SQL语句，而是**给“?”赋值**

  * void addBatch()；添加“批”
  * int[] executeBatch()：执行“批”。返回值表示每条语句所影响的行数据

  ```JAVA
  con = JdbcUtils.getConnection();
  String sql = "insert into stu values(?,?,?,?)";
  pstmt = con.prepareStatement(sql);
  for(int i = 0; i < 10; i++) {
      pstmt.setString(1, "S_10" + i);
      pstmt.setString(2, "stu" + i);
      pstmt.setInt(3, 20 + i);
      pstmt.setString(4, i % 2 == 0 ? "male" : "female");
      pstmt.addBatch();
  }
  pstmt.executeBatch();
  ```




# 8 数据库连接池(DataSource)

* 池参数（有默认值）：初始大小、最小空闲连接数、增量、最大空闲连接数、最大连接数、最大的等待时间
* 连接池也是使用**四大连接参数**来完成创建连接对象
* 连接池必须实现：**javax**.sql.DataSource接口
* 连接池返回Connection对象，它的**close()方法**与众不同！调用它的close()不是关闭，而是**把连接归还给池**！

## 8.1 DBCP连接池

* DBCP是Apache提供的一款开源免费的数据库连接池

  ```java
  BasicDataSource ds = new BasicDataSource();
  ds.setUsername("root");
  ds.setPassword("123");
  ds.setUrl("jdbc:mysql://localhost:3306/mydb1");
  ds.setDriverClassName("com.mysql.jdbc.Driver");		
  Connection con = ds.getConnection();
  System.out.println(con.getClass().getName());
  con.close();
  ```

## 8.2 C3P0连接池(ComboPooledDataSource)

* C3P0也是开源免费的连接池！C3P0被很多人看好。

  * 代码配置

  ```java
  //创建连接池对象
  ComboPooledDataSource dataSource = new ComboPooledDataSource();
  //对池进行四大参数配置
  dataSource.setDriverClass("com.mysql.jdbc.Driver");
  dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/exam?serverTimezone=UTC");
  dataSource.setUser("root");
  dataSource.setPassword("w1994h1127n");
  Connection connection = dataSource.getConnection();
  ```

  * **xml文件配置**
    * 文件名称：必须叫c3p0-config.xml；文件位置：必须在src下

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <c3p0-config>
  	<!-- 默认配置，当使用ComboPooledDataSource无参构造器时，使用的就是这个配置 -->
  	<default-config>
  		<!-- 基本配置 -->
  		<property name="jdbcUrl">jdbc:mysql://localhost:3306/mydb1</property>
  		<property name="driverClass">com.mysql.jdbc.Driver</property>
  		<property name="user">root</property>
  		<property name="password">123</property>
  		<!-- 每次增量，当需要创建Connection对象时，一次创建几个 -->
  		<property name="acquireIncrement">3</property>
  		<!-- 当创建池对象后，池中应该有几个Connection对象 -->
  		<property name="initialPoolSize">10</property>
  		<!-- 池中最少Connection个数，如果少于这个值，就会创建Connection -->
  		<property name="minPoolSize">2</property>
  		<!-- 池中最大连接个数 -->
  		<property name="maxPoolSize">10</property>
  	</default-config>
  	<!-- 命名配置，new ComboPooledDataSource("oralce-config")时，使用的就是这个配置 -->
  	<named-config name="oracle-config"><!--配置信息是瞎写的-->
  		<property name="jdbcUrl">jdbc:mysql://localhost:3306/mydb1</property>
  		<property name="driverClass">com.mysql.jdbc.Driver</property>
  		<property name="user">root</property>
  		<property name="password">123</property>
  		<property name="acquireIncrement">3</property>
  		<property name="initialPoolSize">10</property>
  		<property name="minPoolSize">2</property>
  		<property name="maxPoolSize">10</property>
  	</named-config>
  </c3p0-config>
  ```

  * c3p0的配置文件中可以给每个配置起个名字，这样可以方便的通过配置名称来切换配置信息

  ```java
  //mysql
  public void fun2() throws PropertyVetoException, SQLException {
      ComboPooledDataSource ds = new ComboPooledDataSource();
      Connection con = ds.getConnection();
      System.out.println(con);
      con.close();
  }
  //oracle
  public void fun2() throws PropertyVetoException, SQLException {
      ComboPooledDataSource ds = new ComboPooledDataSource("orcale-config");
      Connection con = ds.getConnection();
      System.out.println(con);
      con.close();
  }
  ```


## 8.3 装饰者模式(Wrapper)

* 对象增强的手段：
  * **继承**：会使**类增多**

    * 特点：增强的内容是死的、被增强的对象也是死的

      ```java
      class 咖啡{}
      class 加奶咖啡 extends 咖啡类 {}
      class 加糖咖啡 extends 咖啡类 {}
      ...
      class 加糖加奶咖啡 extends 咖啡类 {}  
      ```
  * **装饰者模式**（不知被增强对象具体类型，”**是你还有你、一切拜托你**“）

    * 特点：增强的内容是死的、被增强的对象可以是任意的。如IO流

      ```java
      class 咖啡{}
      class 加奶咖啡类 extends 咖啡 {}
      class 加糖咖啡类 extends 咖啡 {}
      ...
      咖啡 a = new 咖啡();
      咖啡 b = new 加奶咖啡(a);//对a进行修饰，就是给a加奶
      咖啡 c = new 加糖咖啡(b);
      ```

      ```java
      class MyConnection implements Connection{//是你		//或extends
          private Connection con;//还有你				   //底层对象，被增强对象
          public MyConnection(Connection con){             //通过构造器传递底层对象
              this.con=con;
          }
          //一切拜托你
          public PreparedStatement preparedStatement(){	 //若是继承，则不用写
              return con.preparedStatement();
          }
          //增强点
          public void close(){
              归还给连接池；
          }
      }
      ```

  * 动态代理

    * 特点：增强的内容可以任意（事务处理）、被增强的对象也是任意的（Service）

# 9 事务(transaction)

## * 9.1 事务的四大特性（ACID）

- **原子性**（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。
- ***一致性**（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。
- **隔离性**（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。
- **持久性**（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。

## 9.2 MySQL中操作事务

- 开启事务：**start transaction**
- 结束事务：**commit**或**rollback**

## 9.3 JDBC中操作事务

- 在JDBC中处理事务，都是通过**Connection**完成。同一事务中所有的操作，都在使用<span style="color:red;font-weight:bold">**同一个Connection对象**</span>

- **Connection**的三个方法与事务相关：

  - **setAutoCommit**(boolean)：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置**false**，那么就相当于开启了事务了；
  - **commit**()：提交事务
  - **rollback**()：回滚事务

  ```java
  try {
    con.setAutoCommit(false);//开启事务…
    ….
    …
    con.commit();//try的最后提交事务
  } catch() {
    con.rollback();//回滚事务
  }
  ```

## 9.4 事务的隔离级别

- 并发事务**问题**

  - **脏读**：读到另一个事务的**未提交更新数据**，即读取到了脏数据
  - **不可重复读**：对同一记录的两次读取不一致，因为另一事务对该记录做了修改
  - **幻读**（虚读）：对同一张表的两次查询不一致，因为另一事务插入了一条记录

- **四大隔离级别**

  - SERIALIZABLE（**串行化**）
    - 不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的；
    - 性能最差；
  - REPEATABLE READ（**可重复读**）（**MySQL**）
    - 防止脏读和不可重复读，不能处理幻读问题；
    - 性能比SERIALIZABLE好
  - READ COMMITTED（**读已提交数据**）（**Oracle**）
    - 防止脏读，没有处理不可重复读，也没有处理幻读；
    - 性能比REPEATABLE READ好
  - READ UNCOMMITTED（**读未提交数据**）
    - 可能出现任何事务并发问题
    - 性能最好

- JDBC设置隔离级别(con. setTransactionIsolation(int level))

  - 参数可选值如下：

    Connection.TRANSACTION_READ_UNCOMMITTED；

    Connection.TRANSACTION_READ_COMMITTED；

    Connection.TRANSACTION_REPEATABLE_READ；

    Connection.TRANSACTION_SERIALIZABLE。

## 9.5 ThreadLocal

- ThreadLocal内部其实是个**Map**来保存数据。虽然在使用ThreadLocal时只给出了值，没有给出键，其实它内部使用了**当前线程做为键**
- **通常用在一个类的成员上**，**多个线程访问时每个线程都有自己的副本**，互不干扰
- 三个方法
  - void set(T value)：保存值；
  - T get()：获取值；
  - void remove()：移除值。



# 10 其他

## 10.1 common-dbutils.jar

* Apache提供的用于简化JDBC的代码

* **QueryRunner(对数据库的增删改查)查询多一个参数比较麻烦**

  * **update方法：**

    * **int update(String sql, Object... params)** -->  可执行增、删、改语句
    * int update(**Connection con**, String sql, Object... parmas) --> 需要调用者提供Connection，这说明本方法不再管理Connection了。**支持事务**!

  * **query方法：**

    * **T query(String sql, ResultSetHandler rsh, Object... params)** --> 可执行查询

      它会先通过其他俩参数得到ResultSet，然后调用rsh的handle()把rs转换成需要的类型！

    * T query(**Connection con**, String sql, ResultSetHadler rsh, Object... params)，**支持事务**

* **ResultSetHandler接口的实现类（结果集处理器）：**

  * **BeanHandler**(单行) --> 构造器需要一个Class类型的参数，用来把一行结果转换成指定类型的javaBean对象

    ```java
    QueryRunner qr = new QueryRunner(JdbcUtils.getDataSource());
    String sql = "select * from t_stu where sid=?";
    Object[] params = {1001};
    Stu stu = qr.query(sql, new BeanHandler<Stu>(Stu.class), params);
    System.out.println(stu);
    ```

  * **BeanListHandler**(多行) --> 构造器也是需要一个Class类型的参数，用来把一行结果集转换成一个javabean，那么多行就是转换成List对象，一堆javabean

    ```java
    QueryRunner qr = new QueryRunner(JdbcUtils.getDataSource());
    String sql = "select * from t_stu";
    List<Stu> stuList = qr.query(sql, new BeanListHandler<Stu>(Stu.class));
    System.out.println(stuList);
    ```

  * **MapHandler**(单行) --> 把一行结果集转换Map对象

    ```java
    QueryRunner qr = new QueryRunner(JdbcUtils.getDataSource());
    String sql = "select * from t_stu where sid=?";
    Object[] params = {1001};
    Map map = qr.query(sql, new MapHandler(), params);
    System.out.println(map);
    ```

  * **MapListHandler**(多行) --> 把一行记录转换成一个Map，多行就是多个Map，即List< Map>！

    ```java
    QueryRunner qr = new QueryRunner(JdbcUtils.getDataSource());
    String sql = "select * from t_stu";
    List<Map<String,Object>> mapList = qr.query(sql, new MapListHandler());
    System.out.println(mapList);
    ```

  * **ScalarHandler**(单行单列) --> 通常用与select count(*) from t_stu语句！结果集是单行单列的！它返回一个Object

    ```java
    QueryRunner qr = new QueryRunner(JdbcUtils.getDataSource());
    String sql = "select count(*) from t_stu";
    //版本等原因类型可能为Long、Integer、BigInteger，Number是他们父类，或用Object类接收
    Number cnt = (Number)qr.query(sql, new ScalarHandler());
    long c = cnt.longValue();
    System.out.println(c);
    ```



## 10.2 BaseServlet

* 缘由：
  * 我们希望在**一个Servlet中可以有多个请求处理方法**！

  * 客户端发送请求时，必须**多给出一个参数，用来说明要调用的方法**
    请求处理方法的签名必须与service相同，即返回值和参数，以及声明的异常都相同！

    **客户端必须传递名为method的参数**！

  ```java
  public class BaseServlet extends HttpServlet {
  	@Override
  	public void service(HttpServletRequest request, HttpServletResponse response)
  			throws ServletException, IOException {
  		response.setContentType("text/html;charset=UTF-8");//处理响应编码
  		request.setCharacterEncoding("UTF-8");//处理请求编码
  		
  		//1. 获取客户端发送的method参数，它是用户想调用的方法 
  		String methodName = request.getParameter("method");
  		Method method = null;
  		//2. 通过方法名称获取Method对象(反射)
  		try {
  			method = this.getClass().getMethod(methodName,
  					HttpServletRequest.class, HttpServletResponse.class);
  		} catch (Exception e) {
  			throw new RuntimeException("您要调用的方法："+methodName + "它不存在！", e);
  		}
  		//3. 通过method对象来调用它
  		try {
              //根据方法的返回值来决定转发、重定向、下载等等操作
  			String result = (String)method.invoke(this, request, response);
  			if(result != null && !result.trim().isEmpty()) {//如果请求处理方法返回不为空
  				int index = result.indexOf(":");//获取第一个冒号的位置
  				if(index == -1) {//如果没有冒号，使用转发
  					request.getRequestDispatcher(result).forward(request, response);
  				} else {//如果存在冒号
  					String start = result.substring(0, index);//分割出前缀
  					String path = result.substring(index + 1);//分割出路径
  					if(start.equals("f")) {//前缀为f表示转发
  					  request.getRequestDispatcher(path).forward(request, response);
  					} else if(start.equals("r")) {//前缀为r表示重定向（需要项目名）
  				      response.sendRedirect(request.getContextPath() + path);
  					}
  				}
  			}
  		} catch (Exception e) {
  			throw new RuntimeException(e);
  		}
  	}
  }
  ```




## 10.3 Service事务

* **发展：**

  1. **DAO中不是处理事务的地方**，因为DAO中的每个方法都是对数据库的一次操作
  2. **Service中的方法才是对应一个业务逻辑**。也就是说我们需要在Service中的一方法中调用DAO的多个方法，而这些方法应该在一起事务中
  3. 处理**事务应该使用同一个Connection对象**，怎么让DAO的多个方法使用相同Connection呢？方法不能自己来获得Connection，而是由外界传递进去。通过JdbcUtils的getConnection()来获取传递即可，但是Service中不应该出现Connection，它应该只在DAO中出现
  4. 我们把**对事务的开启和关闭放到JdbcUtils**中，在**Service中调用JdbcUtils的方法来完成事务的处理**，但在Service中就不会再出现Connection这一“禁忌”了。添加`beginTransaction()`和`rollbackTransaction()`以及`commitTransaction()`方法
  5. DAO中的方法不用再让Service来传递Connection了。**DAO会主动从JdbcUtils中获取Connection对象**，这样，JdbcUtils成为了DAO和Service的中介！
  6. 让JdbcUtils可以**多线程**环境下被使用的最好方法是为每个线程提供一个Connection，这样每个线程都可以开启自己的事务了（利用**ThreadLocal**类）（学习Spring事务打基础）

* 示例：

  * TxQueryRunner这个类可以自己来处理连接的问题，无需外界传递！　
    * 通过JdbcUtils.getConnection()得到连接！有可能是事务连接，也可能是普通的连接！

    * JdbcUtils.releaseConnection()完成对连接的释放！如果是普通连接，关闭之！

  * 或使用QueryRunner

  ```java
  public class AccountDao {
  	public void updateBalance(String name, double balance) throws SQLException {
  		String sql = "update account set balance=balance+? where name=?";
  		Connection con = JdbcUtils.getConnection();
  		QueryRunner qr = new QueryRunner();
  		qr.update(con, sql, balance, name);
  	}
  }
  
  public class AccountService {
  	private AccountDao dao = new AccountDao();
  	
  	public void transfer(String from, String to, double balance) {
  		try {
  			JdbcUtils.beginTranscation();
  			dao.updateBalance(from, -balance);
  			dao.updateBalance(to, balance);
  			JdbcUtils.commitTransaction();
  		} catch(Exception e) {
  			try {
  				JdbcUtils.rollbackTransaction();
  			} catch (SQLException e1) {
  				throw new RuntimeException(e);
  ...
  //main
  AccountService as = new AccountService();
  as.transfer("zs", "ls", 100);
  ```

* **JdbcUtils3.0**

  ```java
  public class JdbcUtils {
  	private static DataSource ds = new ComboPooledDataSource();// 饿汉式
  	//它为null表示没有事务；它不为null表示有事务
  	//当开启事务时，需要给它赋值，让dao方法共享这个Connection；当结束事务时，需要给它赋值为null
      private static ThreadLocal<Connection> tl = new ThreadLocal<Connection>();
  	
      public static DataSource getDataSource() {return ds;}
  	
  	//dao使用本方法来获取连接
  	public static Connection getConnection() throws SQLException {
  		Connection con = tl.get();
  		if(con != null) return con;//当前线程有事务连接，则返回
  		return ds.getConnection();//当前线程没有事务连接，则返回连接池新的con
  	}
  	
  	//开启事务
  	public static void beginTransaction() throws SQLException {
  		Connection con = tl.get();//获取当前线程的事务连接
  		if(con != null) throw new SQLException("已经开启了事务，不能重复开启！");
  		con = ds.getConnection();//给con赋值，表示开启了事务
  		con.setAutoCommit(false);//设置为手动提交
  		tl.set(con);//把当前事务连接放到tl中
  	}
  	
  	//提交事务
  	public static void commitTransaction() throws SQLException {
  		Connection con = tl.get();//获取当前线程的事务连接
  		if(con == null) throw new SQLException("没有事务不能提交！");
  		con.commit();//提交事务
  		con.close();//关闭连接
  		con = null;//表示事务结束！
  		tl.remove();
  	}
  	
  	//回滚事务
  	public static void rollbackTransaction() throws SQLException {
  		Connection con = tl.get();//获取当前线程的事务连接
  		if(con == null) throw new SQLException("没有事务不能回滚！");
  		con.rollback();
  		con.close();
  		con = null;
  		tl.remove();
  	}
  	
  	//释放Connection
  	public static void releaseConnection(Connection connection) throws SQLException{
  		Connection con = tl.get();//获取当前线程的事务连接
  		if(connection != con) {//如果参数连接与当前事务连接不同，说明这不是当前事务，可以关闭
  			if(connection != null &&!connection.isClosed()) {//参数连接没有关闭则关闭之
  				connection.close();
  	...
  ```





# 11 分页

* 分页的优点：只查询一页，不用查询所有页！

  ```latex
  第N页/共M页　首页 上一页 1 2 3 4 5 6 7 8 9 10　下一页 尾页 [ ] go
  ```

## 11.1 分页数据

* **页面的数据都是由Servlet传递来的！**

  * **当前页**：currentPage(**cp**)；

    * pc：如果页面没有传递当前页码，那么Servlet默认是第一页，或者按页面传递的来准！

  * **总页数**：totalPages(**tp**)：总记录数/每页记录数

    * **总记录数**：totalRecored(**tr**)：dao来获取，SELECT COUNT(*) FROM t_customer;

    * **每页记录数**：page size(**ps**)：业务数据或叫系统数据！（14中设置为10行）

  * **当前页数据**：**beanList**：dao来获取，SELECT * FROM t_customer LIMIT X,Y;

  * **url**

* **分页Bean的设计**

  * 这些分页数据总要在各层之间来回的传递，将其封装到一个javabean中，如PageBean.java

    ```java
    private int cp;//当前页码，current Page
    //private int tp;//总页数，total page；可以不需要set方法，只保留get方法通过计算得出
    private int tr;//总记录数，total record
    private int ps;//每页记录数，page size
    private List<T> beanList;//当前页记录
    ```

* **分页在各层中的处理**

  * **页面**：给出分页相关的链接们
    * 页面需要给Servlet提供：有可能传递**当前页码cp**
  * **Servlet**：**创建PageBean**对象并给属性赋初值，然后传递给页面
    * 需要给Dao传递**当前页码cp**、**每页记录数ps**
  * Service：略
  * **Dao**：
    * **tr**：SELECT COUNT(*) FROM t_customer;
    * **beanList**：SELECT * FROM t_customer LIMIE X,Y;

* **显示分页页码列表**

  * 首页/上一页/下一页/尾页

    ```jsp
    <a href="${pb.url }&pc=1">首页</a>
    <c:if test="${pb.pc > 1 }">
    	<a href="${pb.url }&pc=${pb.pc-1}">上一页</a>
    </c:if>
    <c:if test="${pb.pc < pb.tp }">
    	<a href="${pb.url }&pc=${pb.pc+1}">下一页</a>
    </c:if>
    <a href="${pb.url }&pc=${pb.tp}">尾页</a>
    ```

  * 11 12 13 14 15 (16) 17 18 19 20【最多显示10页】【当前页在页码中位置定为16(前-5后+4)】
    * 只需要**当前页码cp**即可确定页码列表，推算出**begin（cp-5）**和**end（cp+4）**即可
    * 计算流程：
      1. 如果总页数<=10（列表长度），那么begin=1，end=总页数
      2. 否则使用公式计算；begin=pc-5, end=pc + 4
        1. 头溢出：当begin<1时，让begin=1
        2. 尾溢出：当end>tp时，让end=tp

    ```jsp
    <c:choose>
    	<%-- 如果总页数不足10页，那么把所有的页数都显示出来！ --%>
    	<c:when test="${pb.tp <= 10 }">
    		<c:set var="begin" value="1" />
    		<c:set var="end" value="${pb.tp }" />
    	</c:when>
    	<c:otherwise>
    		<%-- 当总页数>10时，通过公式计算出begin和end --%>
    		<c:set var="begin" value="${pb.pc-5 }" />
    		<c:set var="end" value="${pb.pc+4 }" />	
    		<%-- 头溢出 --%>
    		<c:if test="${begin < 1 }">
    			<c:set var="begin" value="1" />
    			<c:set var="end" value="10" />
    		</c:if>	
    		<%-- 尾溢出 --%>
    		<c:if test="${end > pb.tp }">
    			<c:set var="begin" value="${pb.tp - 9 }" />
    			<c:set var="end" value="${pb.tp }" />
    		</c:if>	
    	</c:otherwise>
    </c:choose>
    <%-- 循环遍历页码列表 --%>
    <c:forEach var="i" begin="${begin }" end="${end }">
    	<c:choose>
    		<c:when test="${i eq pb.pc }">
    			[${i }]
    		</c:when>
    		<c:otherwise>
    			<a href="${pb.url }&pc=${i}">[${i }]</a>	
    		</c:otherwise>
    	</c:choose>
    </c:forEach>
    ```

* **在超链接中要保留参数**

  * 当使用多条件查询后，然后在点击第2 页时，这个第2页超链接没有条件了，所以会丢失条件，所以我们需要在页面上的所有链接都要保留条件
  * 把条件以一个字符串的形式保存到PageBean的**url**中！这个任务交给Servlet！
    * 表单请求改为GET，即可以在链接后带参数（记得设置请求编码）
    * 将请求获取的参数中带pc的截取掉，使用jsp链接自带的后缀pc

# 14 客户关系管理系统

## 14.1 架构的搭建

1. 导入原型（只有页面，没有功能）



## 14.2 编码中问题

1. 导入原型
   - jstl标签库导入后再运行查看页面
2. 创建包和类(按照公司名.项目名.domain/dao/service/web.servlet来创建)
   - domain中创建和数据库中字段一致的成员变量并提供get/set方法，默认构造可省略
   - dao中提供**TxQueryRunner对象**进行数据库的增删查改
     - 增删改需要提供 1.**SQL字符串模板**；2.**params数组设置(Object型)**；3.**qr执行update(*,*)**
     - 查询还需要提供 1.**返回值ResultSetHandler实现类**；2.**qr执行update(sql,实现类,params)**
     - **多条件组合查询：使用参数来拼凑SQL语句中WHERE 1=1语句**
       - 判断CNAME是否有值，在WHERE子句中添加一个AND条件（StringBuilder）
       - 同时，设置一个参数（ArrayList）
   - service中依赖dao对象，由于这个项目没有什么业务，只有传值的作用
   - Servlet中依赖service对象，**继承BaseServlet**(**注解配置**)，**请求处理方法**的签名必须**与service相同**
     - **提交参数转换为javabean对象**：利用CommonUtils.toBean(Map,Class)或BeanUtils.populate(Map,Class)
     - 添加主键值UUID
     - request域属性的保存
     - 返回String让BaseServlet来决定转发、重定向、下载等
   - JSP页面c标签中forEach运用(iteams、var)、if运用
     - input标签method的运用，来提供请求处理方法参数

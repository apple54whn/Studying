# 1 项目概述—CMS 接口开发

## 1 功能架构与技术架构

### 1.1 功能架构

当前市场的在线教育模式多种多样，包括：B2C、C2C、B2B2C等业务模式，**学成在线采用B2B2C业务模式**，即**向企业或个人提供在线教育平台提供教学服务**，老师和学生通过平台完成整个教学和学习的过程，市场上类似的平台有：网易云课堂、腾讯课堂等，学成在线的特点是IT职业课程在线教学。**项目架构**如下：

![](images/功能架构.jpg)

### 1.2 技术架构

学成在线采用当前流行的**前后端分离**架构开发，由用户层、UI层、微服务层、数据层等部分组成，为PC、App、H5等客户端用户提供服务。下图是系统的**技术架构**图：

![](images/技术架构.jpg)

用户层：描述了本系统所支持的用户类型包括：pc用户、app用户、h5用户

CDN：全称Content Delivery Network，即内容分发网络，本系统所有静态资源全部通过CDN加速来提高访问速度。

负载均衡：系统的CDN层、UI层、服务层及数据层均设置了负载均衡服务，上图仅在UI层前边标注了负载均衡。 每一层的负载均衡会根据系统的需求来确定负载均衡器的类型，系统支持4层负载均衡+7层负载均衡结合的方式，4层负载均衡是指在网络传输层进行流程转发，根据IP和端口进行转发，7层负载均衡完成HTTP协议负载均衡及反向代理的功能，根据url进行请求转发。

UI层：描述了系统向pc用户、app用户、h5用户提供的产品界面。

**微服务层**：将系统服务分类三类：前端服务、后端服务及系统服务。 **前端服务**：主要为学习用户提供学习服务。 **后端服务**：主要为管理用户提供教学管理服务。 **系统服务**：公共服务，为系统的所有微服务提供公共服务功能。 **服务网关**：提供服务路由、负载均衡、认证授权等服务。

**数据层**：描述了系统的数据存储的内容类型，持久化的业务数据使用MySQL和MongoDB保存，其中**MongoDB**中主要保存系统日志信息。 **消息队列**：存储系统服务间通信的消息，本身提供消息存取服务，与微服务层的系统服务连接。 **索引库**：存储课程信息的索引信息，本身提供索引维护及搜索的服务，与微服务层的系统服务连接。 **缓存**：作为系统的缓存服务，存储课程信息、分类信息、用户信息等，与微服务层的所有服务连接。**文件存储**：提供系统静态资源文件的分布式存储服务，文件存储服务器作为CDN服务器的数据来源，CDN上的静态资源将最终在文件存储服务器上保存多份。 **流媒体服务**：作为流媒体服务器，存储所有的流媒体文件。

外部系统接口：略

DevOps：Development和Operations的组合，是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。

------

重点了解微服务技术栈，学成在线服务端基于Spring Boot构建，采用Spring Cloud微服务框架。

* 持久层：MySQL、MongoDB、Redis、ElasticSearch、RabbitMQ、FastDFS等
* 数据访问层：Spring Data JPA 、Mybatis、Spring Data Mongodb、druid等
* 业务层：Spring IOC、Aop、Spring Task、Feign、Ribbon、Spring AMQP、Spring Data Redis、RabbitTemplate等
* 控制层：Spring MVC、FastJSON、RestTemplate、Spring Security Oauth2+JWT、swagger 等
* 微服务治理：Eureka、Zuul、Hystrix、Spring Cloud Config等



### 1.3 开发步骤

项目是基于前后端分离的架构进行开发，前后端分离架构总体上包括前端和服务端，通常是多人协作并行开发，开发步骤如下：

1. 需求分析：梳理用户的需求，分析业务流程
2. **接口定义**：根据需求分析定义接口
3. **服务端和前端并行开发**：依据接口进行服务端接口开发；前端开发用户操作界面，并请求服务端接口完成业务处理；
4. 前后端集成测试：最终前端调用服务端接口完成业务



## 2 CMS 开发

### 2.1 CMS 需求分析

#### 2.1.1 CMS 简介

**CMS （Content Management System）**即**内容管理系统**，不同的项目对CMS的定位不同，比如：一个在线教育网站，有些公司认为CMS系统是对所有的课程资源进行管理，而在早期网站刚开始盛行时很多公司的业务是网站制作，当时对CMS的定位是创建网站，即对网站的页面、图片等静态资源进行管理。

每个公司对每个项目的CMS定位不同，CMS基本上分为：针对后台数据内容的管理、针对前端页面的管理、针对样式风格的管理等 。比如：一个给企业做网站的公司，其CMS系统主要是网站页面管理及样式风格的管理。

本项目作为一个大型的在线教育平台，对CMS系统的定位是对各个网站（子站点）页面的管理，主要管理由于运营需要而**经常变动的页面**，从而实现根据运营需要快速进行页面开发、上线的需求。

#### 2.1.2 静态门户工程搭建

1. 安装Nginx，解压，双击nginx.exe即可运行。访问`http://localhost`

2. 导入门户工程到Webstorm或VSCode

3. 配置虚拟主机

   ```
   server{
           listen 80;
           server_name www.xuecheng.com;//需要映射IP
           
           ssi on;
           ssi_silent_errors on;
           location / {
               alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/;
               index index.html;
           }
       }
   ```

   `D:/Code-Workspace/Webstorm/xc-ui-pc-static-portal/`本目录为门户的主目录

4. 配置hosts文件`C:\Windows\System32\drivers\etc\hosts`，访问`http://www.xuecheng.com/`

   ```
   127.0.0.1       www.xuecheng.com
   ```

#### 2.1.3 SSI 服务端包含技术

本节分析首页的管理方案：

* 页面内容多如何管理？将页面**拆分**成一个一个的小页面，通过**cms去管理这些小页面**，只需要更改具体某个小页面即可。
* 页面拆出来怎么样通过web服务浏览呢？使用web服务(例如nginx)的**SSI技术**，将多个子页面合并渲染输出。

SSI 包含类似于jsp页面中的incluce指令（js，Thymeleaf、freemaker都有），**SSI 是在web服务端将include指定的页面包含在网页中**，**渲染**html网页响应给客户端 。nginx、apache等多数web容器都支持SSI指令。如下：

```html
<!‐‐#include virtual="/../....html"‐‐>
```

在HTML中看起来和注释一样，但是其实格式就是这样！

Nginx中SSI 配置参数如下：

* `ssi on`：开启ssi支持
* `ssi_silent_errors on`：默认为off，设置为on则在处理SSI文件出错时不输出错误信息
* `ssi_types`：默认为 `ssi_types text/html`，如果需要支持shtml（服务器执行脚本，类似于jsp）则需要设置为`ssi_types text/shtml`

#### 2.1.4 CMS 页面管理需求

1. **创建站点**：一个网站有很多子站点，比如：学成在线有主门户、学习中心。具体的哪个页面是归属于具体的站点，所以要管理页面，先要管理页面所属的站点。
2. **创建模板**：页面如何创建呢？比如电商网站的商品详情页面，每个页面的内容布局、板式是相同的，不同的只是内容，这个页面的布局、板式就是页面模板，模板+数据就组成一个完整的页面，最终要创建一个页面文件需要先定义此页面的模板，最终拿到页面的数据再结合模板就拼装成一个完整的页面。
3. **创建页面**：指填写页面的基本信息，如：页面的名称、页面的url地址等。
4. **页面预览**：是页面发布前的一项工作，页面预览使用静态化技术根据页面模板和数据生成页面内容，并通过浏览器预览页面。页面发布前进行页面预览的目是为了保证页面发布后的正确性。
5. **页面发布**：使用计算机技术将页面发送到页面所在站点的服务器，页面发布成功就可以通过浏览器来访问了

本项目要实现什么样的功能？

- 页面管理：管理员在后台添加、修改、删除页面信息
- 页面预览：管理员通过页面预览功能预览页面发布后的效果
- 页面发布：管理员通过页面发布功能将页面发布到远程门户服务器。

页面发布成功，用户即可在浏览器浏览到，整个页面添加、发布的过程由于**软件自动执行**，无需人工登录服务器操作。



### 2.2 CMS 服务端工程搭建

服务端工程代码复制到目录 `xcEdu/xcEduService`中（前端工程代码目录 `xcEdu/xcEduUI`）

导入基础工程（在IDEA中 project structure 的 Modules 中点击 Import Model 导入以下 maven 工程即可）

CMS及其它服务端工程基于maven进行构建，首先需要创建如下基础工程：

* **parent**工程：父工程，提供**依赖管理**。

* common工程：通用工程，提供各层封装

* **model**工程：模型工程，提供统一的模型类管理。类似domain

* utils工程：工具类工程，提供本项目所使用的工具类

* **Api**工程：**接口工程**，统一管理本项目的服务接口

![1550426898343](images/1550426898343.png)

------

MongoDB的入门及导入CMS数据库

导入集合到`xc_cms`数据库中，略



### 2.3 ==页面查询接口定义==

#### 2.3.1 定义模型

##### 1、需求分析

本次定义**页面查询接口**，本接口供前端请求查询页面列表，支持**分页**及**自定义条件查询**方式。具体**需求**如下：

* 分页查询MongoDB `cms_page`集合下的数据
* 根据站点Id、模板Id、页面别名查询页面信息
* 接口基于HTTP Get请求，响应Json数据

##### 2、模型类介绍

接口的定义离不开**数据模型**（类似domain），根据前边对需求的分析，整个页面管理模块的数据模型如下：

* CmsSite：站点模型
* CmsTemplate：页面模板
* CmsPage：页面信息，代码如下

> 分别对应MongoDB中集合cms_site, cms_template, cms_page。每个页面都有所属站点，并且页面可能使用的模板不一样

```java
@Data //Lombok提供注解，自动生成getter/setter，toString，equals，hashCode方法
@ToString //Lombok提供注解，自动生成tostring方法
@Document(collection = "cms_page")//Spring Data MongoDB提供的注解，映射MongoDB中集合
public class CmsPage {
    /**
     * 定义一个页面需要指定页面所属站点，一个站点包括多个页面，比如：学成在线的门户站点（网站）包括了多个页面。
     * 定义一个页面需要指定页面使用的模板，多个页面可以使用相同的模板，比如：商品信息模板，每个商品就是一个页面，所有商品使用同一个商品信息模板
     */

    //站点ID
    private String siteId;
    //页面ID
    @Id
    private String pageId;
    //页面名称
    private String pageName;
    //别名
    private String pageAliase;
    //访问地址
    private String pageWebPath;
    //参数
    private String pageParameter;
    //物理路径
    private String pagePhysicalPath;
    //类型（静态/动态）
    private String pageType;
    //页面模版
    private String pageTemplate;
    //页面静态化内容
    private String pageHtml;
    //状态
    private String pageStatus;
    //创建时间
    private Date pageCreateTime;
    //模版id
    private String templateId;
    //参数列表
    private List<CmsPageParam> pageParams;
    //模版文件Id
    //private String templateFileId;
    //静态文件Id
    private String htmlFileId;
    //数据Url
    private String dataUrl;

}
```

##### 3、Lombok

[Lombok](https://www.projectlombok.org/)是一个实用的java工具，使用它可以消除java代码的臃肿，Lombok提供一系列的注解，使用这些注解可以不用定义getter/setter、equals、构造方法等，它会在**编译时在字节码文件自动生成这些通用的方法**，简化开发人员的工作。用法：

1. Maven依赖，作用是项目在编译时根据Lombok注解生成通用方法。

   ```xml
   <dependency>
       <groupId>org.projectlombok</groupId>
       <artifactId>lombok</artifactId>
   </dependency>
   ```

2. 在IDEA开发工具中添加Lombok插件，作用是使用IDEA开发时根据Lombok注解生成通用方法，不报错。



#### 2.3.2 定义接口

##### 1、定义请求及响应类型

1. 定义请求模型`QueryPageRequest`，此模型作为查询条件类型。为后期扩展需求，请求类型统一继承RequestData类型（在common中，此类暂时没有内容）

   ```java
   @Data
   public class QueryPageRequest extends RequestData {
       //站点id
       private String siteId;
       //页面ID
       private String pageId;
       //页面名称
       private String pageName;
       //别名
       private String pageAliase;
       //模版id
       private String templateId;
   }
   ```

2. 响应结果类型，分页查询统一使用`QueryResponseResult`，其包含`QueryResult`属性，有数据列表和总记录数属性；并且它继承了`ResponseResult`含有success和message等属性信息

##### 2、定义接口

在**Api接口工程**专门定义接口，在Api工程单独定义接口的原因如下：

* 接口==**集中管理**==

* Api工程的接口将作为==**各微服务远程调用使用**==

  ```java
  //package com.xuecheng.api.cms
  public interface CmsPageControllerApi {
      //页面查询
      QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest);
  }
  ```




### 2.4 ==页面查询服务端开发==

#### 2.4.1 创建CMS服务工程

创建maven工程，使用Spring Boot(jar)， CMS工程的名称为 `xc-service-manage-cms`，父工程为`xc-framework-parent`。

创建基本包结构：`com.xuecheng.manage_cms.config/dao/service/controller`，config为配置类目录，数据库、MQ配置等

```xml
<dependencies>
    <dependency>
        <groupId>com.xuecheng</groupId>
        <artifactId>xc-framework-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.xuecheng</groupId>
        <artifactId>xc-service-api</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.xuecheng</groupId>
        <artifactId>xc-framework-model</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.xuecheng</groupId>
        <artifactId>xc-framework-utils</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-freemarker</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-mongodb</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>
    <dependency>
        <groupId>com.squareup.okhttp3</groupId>
        <artifactId>okhttp</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
    </dependency>
</dependencies>
```

配置`application.yml`

```yaml
server:
  port: 31001
spring:
  application:
    name: xc‐service‐manage‐cms
  data:
    mongodb:
      uri: mongodb://root:123@localhost:27017
      database: xc_cms
```

配置`logback-spring.xml`日志

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--定义日志文件的存储地址,使用绝对路径-->
    <property name="LOG_HOME" value="d:/logs"/>

    <!-- Console 输出设置 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>

    <!-- 按照每天生成日志文件 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名-->
            <fileNamePattern>${LOG_HOME}/xc.%d{yyyy-MM-dd}.log</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 异步输出 -->
    <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
        <queueSize>512</queueSize>
        <!-- 添加附加的appender,最多只能添加一个 -->
        <appender-ref ref="FILE"/>
    </appender>


    <logger name="org.apache.ibatis.cache.decorators.LoggingCache" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>
    <logger name="org.springframework.boot" level="DEBUG"/>
    <root level="info">
        <!--<appender-ref ref="ASYNC"/>-->
        <appender-ref ref="FILE"/>
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

启动类及包扫描配置

```java
@SpringBootApplication
@EntityScan("com.xuecheng.framework.domain.cms")//扫描实体类
@ComponentScan("com.xuecheng.api")//扫描接口
@ComponentScan("com.xuecheng.manage_cms")//扫描本项目下的所有类，可以不配置，默认扫描此类所在包及子包中的bean...
public class ManageCmsApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(ManageCmsApplication.class, args);
    }
}
```



#### 2.4.2 Repository

```java
package com.xuecheng.manage_cms.dao;

public interface CmsPageRepository extends MongoRepository<CmsPage,String> {
}
```



#### 2.4.3 Service

```java
@Service
public class CmsPageService {

    @Autowired
    private CmsPageRepository cmsPageRepository;
    /**
     * 分页条件查询
     * @param page，页码，从1开始
     * @param size，每页记录数
     * @param queryPageRequest，查询条件
     * @return
     */
    public QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest) {
        if (page <= 0) {
            page = 1;
        }
        if (size <= 0) {
            size = 10;
        }
        if (queryPageRequest==null){
            queryPageRequest = new QueryPageRequest();
        }
        //条件值对象
        CmsPage cmsPage = new CmsPage();
        if (!StringUtils.isEmpty(queryPageRequest.getSiteId())){ //org.springframework.util.StringUtils;
            cmsPage.setSiteId(queryPageRequest.getSiteId());//站点id
        }
        if (!StringUtils.isEmpty(queryPageRequest.getTemplateId())){
            cmsPage.setTemplateId(queryPageRequest.getTemplateId());//模板id
        }
        if (!StringUtils.isEmpty(queryPageRequest.getPageAliase())){
            cmsPage.setPageAliase(queryPageRequest.getPageAliase());//页面别名
        }
        //条件匹配器（多用于模糊查询等）
        ExampleMatcher matcher = ExampleMatcher.matching()
            .withMatcher("pageAliase",ExampleMatcher.GenericPropertyMatchers.contains());

        //条件对象
        Example<CmsPage> example = Example.of(cmsPage,matcher);
        Page<CmsPage> all = cmsPageRepository.findAll(example,PageRequest.of(page-1, size));

        QueryResult queryResult = new QueryResult();
        queryResult.setList(all.getContent());//数据列表
        queryResult.setTotal(all.getTotalElements());//数据总记录数
        QueryResponseResult queryResponseResult = new QueryResponseResult(CommonCode.SUCCESS, queryResult);
        return queryResponseResult;
    }
}
```



#### 2.4.4 Controller

```java
package com.xuecheng.manage_cms.controller;

@RestController
@RequestMapping("/cms/page")
public class CmsPageController implements CmsPageControllerApi {
    @Autowired
    private CmsPageService cmsPageService;

    @Override
    @GetMapping("/list/{page}/{size}")
    public QueryResponseResult findList(@PathVariable int page, @PathVariable int size, QueryPageRequest queryPageRequest) {
        return cmsPageService.findList(page,size,queryPageRequest);
    }
}
```



## 3 接口开发==规范==

### 3.1 Api请求及响应规范

为了严格按照接口进行开发，提高效率，对请求及响应格式进行规范化。

- Get 请求时，采用key/value格式请求，SpringMVC可采用**基本类型**（`@PathVariable`）的变量接收，也可以采用**对象接收**（`@RequestParam`，没有参数名一致方便）。
- Post 请求时，可以提交form表单数据（`application/x-www-form-urlencoded`）和JSON数据（`Content-
  Type=application/json`），文件等多部件类型（`multipart/form-data`）三种数据格式，SpringMVC接收JSON数据
  使用`@RequestBody`注解解析请求的json数据。
- 响应结果统一信息为：是否**成功**、操作**代码**、**提示信息**及**自定义数据**。
- 响应结果统一格式为JSON。



### 3.2 Api定义约束

Api定义使用SpringMVC来完成，由于此接口后期将作为**微服务远程调用**使用，在定义接口时有如下限制：

* `@PathVariable` 统一指定参数名称，如：@PathVariable("id")
* `@RequestParam` 统一指定参数名称，如：@RequestParam（"id"）



## 4 页面查询接口==测试==

上边的代码是基于服务端编写接口，如果前端人员等待服务端人员将接口开发完毕再去开发前端内容这样做效率是非常低下的，所以**当接口定义完成**，可以**使用工具生成接口文档**，前端人员查看接口文档即可进行前端开发，这样前端和服务人员并行开发，大大提高了生产效率。

### 4.1 Swagger

OpenAPI规范（OpenAPI Specification 简称OAS）是Linux基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程，目前版本是V3.0，并且已经发布并开源在[github](https://github.com/OAI/OpenAPI-Specification)上。

[Swagger](https://swagger.io/)是全球最大的OpenAPI规范（OAS）API开发工具框架，支持从设计和文档到测试和部署的整个API生命周期的开发。

Spring Boot 可以集成Swagger，生成Swagger接口。

Swagger接口生成工作原理：

1. 系统启动，扫描到api工程中的Swagger2Configuration类
2. 在此类中指定了包路径如`com.xuecheng`，找到在此包下及子包下标记有@RestController注解的controller类
3. 根据controller类中的Swagger注解生成接口文档（也会扫描该类所实现的接口）
4. 启动cms服务工程，查看接口文档，请求：http://localhost:31001/swagger-ui.html

```xml
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.7.0</version>
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.7.0</version>
</dependency>
```

Swagger配置类

```java
package com.xuecheng.api.config;

@Configuration
@EnableSwagger2//开启！
public class Swagger2Configuration {
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(apiInfo())
            .select()
            .apis(RequestHandlerSelectors.basePackage("com.xuecheng"))//扫描该包中所有@RestController注解类的所有方法
            .paths(PathSelectors.any())
            .build();
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
            .title("学成网api文档")
            .description("学成网api文档")
            //.termsOfServiceUrl("/")
            .version("1.0")
            .build();
    }
}
```





### 4.2 Swagger常用注解

在Java类中添加Swagger的注解即可生成Swagger接口，常用Swagger注解如下：

* @**Api**：用在请求的**类**上，表示对类的说明
  * value "说明该类的用途、作用。没用，不显示"
  *  description "说明该类的用途、作用。显示"

* @**ApiOperation**：用在请求的**方法**上，说明方法的用途、作用 
  * value="说明方法的用途、作用"
* @ApiParam：单个参数描述
* @ApiResponse：HTTP响应其中1个描述
* @ApiResponses：HTTP响应整体描述
* @ApiIgnore：使用该注解忽略这个API
* @ApiError ：发生错误返回的信息
* @**ApiImplicitParam**：一个请求参数
* @**ApiImplicitParams**：多个请求参数
* @ApiModel：用对象来接收参数，不显示
* @**ApiModelProperty**：用**对象接收参数**时，**描述对象的一个字段**

@ApiImplicitParam属性：

|     属性     |  取值  |                     作用                      |
| :----------: | :----: | :-------------------------------------------: |
|  paramType   |        |                 查询参数类型                  |
|              |  path  |             以地址的形式提交数据              |
|              | query  |          直接跟参数完成自动映射赋值           |
|              |  body  |           以流的形式提交 仅支持POST           |
|              | header |        参数在request headers 里边提交         |
|              |  form  |        以form表单的形式提交 仅支持POST        |
|   dataType   |        | 参数的数据类型 只作为标志说明，并没有实际验证 |
|              |  Long  |                                               |
|              | String |                                               |
|     name     |        |                  接收参数名                   |
|    value     |        |              接收参数的意义描述               |
|   required   |        |                 参数是否必填                  |
|              |  true  |                     必填                      |
|              | false  |                    非必填                     |
| defaultValue |        |                    默认值                     |

可以写在接口上，也可以写在实现类上（怎么选则？？？）

```java
package com.xuecheng.api.cms;

@Api(value="cms页面管理接口",description = "cms页面管理接口，提供页面的增、删、改、查")
public interface CmsPageControllerApi {
    //页面查询
    @ApiOperation("分页查询页面列表")
    @ApiImplicitParams({
        @ApiImplicitParam(name="page",value = "页码",required=true,paramType="path",dataType="int"),
        @ApiImplicitParam(name="size",value = "每页记录数",required=true,paramType="path",dataType="int")
    })
    QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest);
}
```

用对象接收参数时，写模型上

```java
@Data
//由于继承了RequestData，父类有@Data注解，所以在注解该类@Data时报警告。不写可以在swaggerui看到，但不知道是否有其他影响
@EqualsAndHashCode(callSuper = true)
public class QueryPageRequest extends RequestData {

    //站点id
    @ApiModelProperty("站点id")
    private String siteId;
    //页面ID
    @ApiModelProperty("页面ID")
    private String pageId;
    //页面名称
    @ApiModelProperty("页面名称")
    private String pageName;
    //页面别名
    @ApiModelProperty("页面别名")
    private String pageAliase;
    //模版id
    @ApiModelProperty("模版id")
    private String templateId;
}
```





# 2 CMS 前端开发

## 1 系统管理前端工程导入

> CMS系统使用Vue-cli脚手架创建， Vue-cli是Vue官方提供的快速构建单页应用的脚手架，[github地址](https://github.com/vuejs/vue-cli)（有兴趣的同学可以参考官方指导使用vue-cli创建前端工程），本项目对 Vue-cli 创建的工程进行二次封装，下边介绍CMS工程的情况。

------

> 基于Vue-Cli创建的工程进行开发还需要在它基础上作一些封装，导入课程资料中提供Vue-Cli封装工程。将课程资料中的xc-ui-pc-sysmanage.7z拷贝到UI工程目录中，并解压，用WebStorm打开xc-ui-pc-sysmanage目录。
>
> 导入成功后，`npm run dev`可能会报错
>
> Module build failed Error Node Sass does not yet support your current environment OS X 64-bit with Unsupported runtime 59。原因是本机安装的Node是10版本，导入项目的Sass是4.7.2，不支持Node10。需要重装：
>
> `npm uninstall node-sass -D`
>
>  `npm install node-sass -D`

- `index.html`是模板文件。

- `package.json`

  记录了工程所有依赖，及脚本命令。开发使用：`npm run dev`；打包使用：`npm run build`

- `build/webpack.base.conf.js`

  就是webpack的webpack.config.js配置文件，在此文件中配置了入口文件及各种Loader。

  目录下有开发/生产/测试等等的配置打包方式

  webpack是通过vue-load解析.vue文件，通过css-load打包css文件等。

- `static`：与src的平级目录，此目录存放静态资源

  它与assets的区别在于，static目录中的文件不被webpack打包处理，会原样拷贝到dist目录下。

![1550563904871](images/1550563904871.png)

* **src目录下存放页面及js代码**

  * `main.js`

    工程的入口文件，在此文件中加载了很多第三方组件，如：Element-UI、Base64、VueRouter等。

  * `assets`：存放一些静态文件，如图片。

  * **`base`**：存放**基础组件**

    * api：基础api接口
    * component：基础组件，被各各模块都使用的组件
    * router：总的路由配置，加载各模块的路由配置文件。

  * `common`：工具类

  * `component`：组件目录，本项目不用。

  * `mock`：存放前端单元测试方法。

  * **`module`**：存放**各业务模块的页面和api方法**。下级目录以模块名命名，下边以cms举例：

    * cms/api：cms模块的api接口
    * cms/component：cms模块的组件
    * cms/page： cms模块的页面
    * cms/router：cms模块的路由配置

  * `statics`：存放第三方组件的静态资源

  * `vuex`：存放vuex文件，本项目不使用

  

## 2 单页面应用

单页Web应用（single page web application，**SPA**），就是只有**一张Web页面的应用**。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说**模块化的开发和设计显得相当重要**。

优点：

* **用户操作体验好**，用户不用刷新页面，整个交互过程都是通过**Ajax**来操作
* **适合前后端分离开发**，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲染。

缺点：

* **首页加载慢**。单页面应用会将js、 css打包成一个文件，在加载页面显示的时候加载打包文件，如果打包文件较大或者网速慢则用户体验不好。可以压缩。
* **SEO**（Search Engine Optimization）不友好。搜索引擎对JS支持不好，所以将大大减少搜索引擎对网站的收录

> 本项目的门户、课程介绍不采用单页面应用架构去开发，对于需要用户登录的管理系统采用单页面开发。



## 3 CMS前端页面查询开发

在**model**目录创建 cms模块的目录结构：api/componets/page/router

### 3.1 api

`cms/api`目录定义`cms.js`，实现**http请求服务端**页面查询接口。

```js
//public是对axios的工具类封装，定义了http请求方法
import http from './../../../base/api/public';

let sysConfig = require('@/../config/sysConfig');
let apiUrl = sysConfig.xcApiUrlPre;
import querystring from 'querystring'

export const page_list = (page, size, params) => {
  //将json对象转成key/value对
  let query = querystring.stringify(params);
  return http.requestQuickGet(apiUrl + '/cms/page/list/' + page + '/' + size + '?' + query)
};
```

由于前端服务`http://localhost:11000/`调用后端服务`http://localhost:31001/`，跨域！！！浏览器中控制台：

`No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin
'http://localhost:11000' is therefore not allowed access.`

原因：浏览器的**同源策略**不允许跨域访问，所谓同源策略是指**协议**、**域名**、**端口**都相同

解决：采用**proxyTable**解决。

* **vue-cli提供**的解决vue开发环境下跨域问题的方法，proxyTable的底层使用了[http-proxymiddleware](https://github.com/chimurai/http-proxy-middleware)，它是http代理中间件，它依赖node.js，基本原理是**用服务端代理解决浏览器跨域**。**后台服务之间访问不存在跨域问题**！！！

* `config/index.js`，proxyTable拦截所有`/api/cms`请求，并替换为`/cms`，利用Node.js来发送请求

  ```js
  proxyTable: {
      '/api/cms': {
          target: 'http://localhost:31001',
          pathRewrite: {
          	'^/api': ''
      	}
      }
  }
  ```



### 3.2 page

`.vue`文件结构如下

```vue
<template>
  <!--编写页码静态部分，即View部分。必须有个根元素否则vue报错-->
  <div></div>
</template>

<script>
  /*编写页面静态部分，即model及vm部分。*/
</script>

<style>
  /*编写页面样式，不是必须*/
</style>
```

本项目使用[Element-UI](http://element.eleme.io/#/zh-CN/component/installation)来构建界面，Element是一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。

新建`page_list.vue`

```vue
<template>
  <!--编写页码静态部分，即View部分。必须有个根元素否则vue报错-->
  <div>
    <!--下拉选择器，自定义查询-->
      <el-select v-model="params.siteId" placeholder="请选择站点">
        <el-option
          v-for="item in siteList"
          :key="item.siteId"
          :label="item.siteName"
          :value="item.siteId">
        </el-option>
      </el-select>
      页面别名：<el-input v-model="params.pageAliase"  style="width: 100px"></el-input>
    <el-button type="primary" size="small" @click="query">查询</el-button>
    <el-table
      :data="list"
      stripe
      style="width: 100%">
      <el-table-column type="index" width="60">
      </el-table-column>
      <el-table-column prop="pageName" label="页面名称" width="120">
      </el-table-column>
      <el-table-column prop="pageAliase" label="别名" width="120">
      </el-table-column>
      <el-table-column prop="pageType" label="页面类型" width="150">
      </el-table-column>
      <el-table-column prop="pageWebPath" label="访问路径" width="250">
      </el-table-column>
      <el-table-column prop="pagePhysicalPath" label="物理路径" width="250">
      </el-table-column>
      <el-table-column prop="pageCreateTime" label="创建时间" width="180">
      </el-table-column>
    </el-table>
    <el-pagination
      layout="prev, pager, next"
      :total="total"
      :page-size="params.size"
      :current-page="params.page"
      v-on:current-change="changePage"
      style="float:right">
    </el-pagination>
  </div>
</template>

<script>
  /*编写页面静态部分，即model及vm部分。*/
  import * as cmsApi from '../api/cms';

  export default {
    data() {
      return {
        list: [],
        siteList:[],
        total: 50,
        params: {
          page: 1,
          size: 10,
          siteId:'',
          pageAliase:''
        }
      }
    },
    methods: {
      query: function () {
        cmsApi.page_list(this.params.page, this.params.size,this.params)
          .then((response) => {
          this.total = response.queryResult.total;
          this.list = response.queryResult.list;
        })
      },
      changePage: function (page) {
        this.params.page = page;
        this.query()
      }
    },
    mounted: function () {
      this.query();
      //初始化站点列表。模拟数据，本应该请求后端来获取
      this.siteList = [
        {
          siteId:'5a751fab6abb5044e0d19ea1',
          siteName:'门户主站'
        },
        {
          siteId:'102',
          siteName:'测试站'
        }
      ]
    }

  }
</script>
<style>
  /*编写页面样式，不是必须*/
</style>
```

通常使用最多的是created和mounted两个钩子：

* **created**：vue实例已创建但是DOM元素还没有渲染生成。
* **mounted**：DOM元素渲染生成完成后调用。

### 3.3 router

创建`cms/router/index.js`，实现url访问到页面

```js
import Home from '@/module/home/page/home.vue';
import page_list from '@/module/cms/page/page_list.vue';

export default [{
    path: '/cms',
    component: Home,
    name: 'CMS内容管理',
    hidden: false,
    children: [{
        path: '/cms/page/list',
        component: page_list,
        name: '页面列表',
        hidden: false,
    }]
}]
```

在`base/router/index.js`导入cms模块的路由

```js
import Vue from 'vue';
import Router from 'vue-router';
Vue.use(Router);
// 定义路由配置
let routes = []
let concat = (router) => {
    routes = routes.concat(router)
}
//导入路由规则
import HomeRouter from '@/module/home/router';
import CmsRouter from '@/module/cms/router';
// 合并路由规则
concat(HomeRouter);
concat(CmsRouter);
export default routes;
```



## 4 前后端请求响应小节

![](images/前后端请求响应.png)



# 3 CMS 系统页面管理

## 1 自定义条件查询

在页面输入查询条件，查询符合条件的页面信息。查询条件如下：

* 站点Id：精确匹配
* 模板Id：精确匹配
* 页面别名：模糊匹配
* ......

Repository层不用变动，只需修改Service层。

### 1.1 Api

```java
@Api(value="cms页面管理接口",description = "cms页面管理接口，提供页面的增、删、改、查")
public interface CmsPageControllerApi {
    //页面查询
    @ApiOperation("分页查询页面列表")
    @ApiImplicitParams({
        @ApiImplicitParam(name="page",value = "页码",required=true,paramType="path",dataType="int"),
        @ApiImplicitParam(name="size",value = "每页记录数",required=true,paramType="path",dataType="int")
    })
    QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest);



    @ApiOperation("增加页面")
    CmsPageResult add(CmsPage cmsPage);//CmsPageResult包含CmsPage，和三个重要信息！

    @ApiOperation("根据id查询页面")
    CmsPage findById(String id);

    @ApiOperation("增加页面")
    CmsPageResult edit(String id,CmsPage cmsPage);//CmsPageResult包含CmsPage，和三个重要信息！
    
    @ApiOperation("删除页面")
    ResponseResult delete(String id);

}
```

### 1.2 Repository

```java
public interface CmsPageRepository extends MongoRepository<CmsPage,String> {

    //根据站点id、页面名称、页面访问路径查询
    CmsPage findBySiteIdAndPageNameAndPageWebPath(String siteId,String pageName,String pageWebPath);
}
```

### 1.3 Service

```java
@Service
public class CmsPageService {

    @Autowired
    private CmsPageRepository cmsPageRepository;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private CmsTemplateRepository cmsTemplateRepository;

    @Autowired
    private GridFsTemplate gridFsTemplate;

    @Autowired
    private GridFSBucket gridFSBucket;
    /**
     * 分页条件查询
     * @param page，页码，从1开始
     * @param size，每页记录数
     * @param queryPageRequest，查询条件
     * @return
     */
    public QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest) {
        if (page <= 0) {
            page = 1;
        }
        if (size <= 0) {
            size = 10;
        }
        if (queryPageRequest==null){
            queryPageRequest = new QueryPageRequest();
        }
        //条件值对象
        CmsPage cmsPage = new CmsPage();
        if (!StringUtils.isEmpty(queryPageRequest.getSiteId())){ //org.springframework.util.StringUtils;
            cmsPage.setSiteId(queryPageRequest.getSiteId());//站点id
        }
        if (!StringUtils.isEmpty(queryPageRequest.getTemplateId())){
            cmsPage.setTemplateId(queryPageRequest.getTemplateId());//模板id
        }
        if (!StringUtils.isEmpty(queryPageRequest.getPageAliase())){
            cmsPage.setPageAliase(queryPageRequest.getPageAliase());//页面别名
        }
        //条件匹配器（多用于模糊查询等）
        ExampleMatcher matcher = ExampleMatcher.matching()
            .withMatcher("pageAliase",ExampleMatcher.GenericPropertyMatchers.contains());

        //条件对象
        Example<CmsPage> example = Example.of(cmsPage,matcher);
        Page<CmsPage> all = cmsPageRepository.findAll(example,PageRequest.of(page-1, size));

        QueryResult queryResult = new QueryResult();
        queryResult.setList(all.getContent());//数据列表
        queryResult.setTotal(all.getTotalElements());//数据总记录数
        QueryResponseResult queryResponseResult = new QueryResponseResult(CommonCode.SUCCESS, queryResult);
        return queryResponseResult;
    }


    public CmsPageResult add(CmsPage cmsPage) {
        //校验页面是否存在，根据页面名称、站点Id、页面webpath查询
        CmsPage page = cmsPageRepository.findBySiteIdAndPageNameAndPageWebPath(cmsPage.getSiteId(), cmsPage.getPageName(), cmsPage.getPageWebPath());
        //先处理异常
        if (page != null) {
            ExceptionCast.cast(CmsCode.CMS_ADDPAGE_EXISTSNAME);//页面已存在
        }
        //再进行业务操作
        cmsPage.setPageId(null);//为了让id自增
        cmsPageRepository.save(cmsPage);
        return new CmsPageResult(CommonCode.SUCCESS, cmsPage);
    }


    //根据id查询页面
    public CmsPage findById(String id){
        Optional<CmsPage> optional = cmsPageRepository.findById(id);
        return optional.orElse(null);//if...else简写
    }

    //编辑页面
    public CmsPageResult edit(String id, CmsPage cmsPage) {
        CmsPage page = this.findById(id);
        if (page != null) {
            //更新所属站点
            page.setSiteId(cmsPage.getSiteId());
            //更新模板id
            page.setTemplateId(cmsPage.getTemplateId());
            //更新页面别名
            page.setPageAliase(cmsPage.getPageAliase());
            //更新页面名称
            page.setPageName(cmsPage.getPageName());
            //更新访问路径
            page.setPageWebPath(cmsPage.getPageWebPath());
            //更新物理路径
            page.setPagePhysicalPath(cmsPage.getPagePhysicalPath());
            //DataUrl
            page.setDataUrl(cmsPage.getDataUrl());
            //页面类型
            page.setPageType(cmsPage.getPageType());

            CmsPage save = cmsPageRepository.save(page);
            return new CmsPageResult(CommonCode.SUCCESS, save);

        }
        return new CmsPageResult(CommonCode.FAIL, null);
    }

    //删除页面
    public ResponseResult delete(String id){
        Optional<CmsPage> optional = cmsPageRepository.findById(id);
        if (optional.isPresent()){
            cmsPageRepository.deleteById(id);
            return new ResponseResult(CommonCode.SUCCESS);
        } else {
            return new ResponseResult(CommonCode.FAIL);
        }
    }

    //页面静态化方法，返回html内容
    public String getPageHtml(String pageId){
        //静态化程序远程请求DataUrl获取数据模型。
        Map model = getModelByPageId(pageId);
        if (model==null){
            //数据模型获取不到
            ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_DATAISNULL);
        }
        //静态化程序获取页面的模板信息
        String templateContent = getTemplateByPageId(pageId);
        if (StringUtils.isEmpty(templateContent)){
            //页面模板为空
            ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL);
        }
        //执行页面静态化
        String html = generateHtml(templateContent, model);
        return html;
    }

    private String generateHtml(String templateContent,Map model){
        //创建配置对象
        Configuration configuration = new Configuration(Configuration.getVersion());
        //创建模板加载器
        StringTemplateLoader stringTemplateLoader = new StringTemplateLoader();
        stringTemplateLoader.putTemplate("template",templateContent);
        //向configuration配置模板加载器
        configuration.setTemplateLoader(stringTemplateLoader);
        try {
            Template template = configuration.getTemplate("template");
            String html = FreeMarkerTemplateUtils.processTemplateIntoString(template, model);
            return html;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }


    private String getTemplateByPageId(String pageId) {
        //取出页面的信息
        CmsPage cmsPage = this.findById(pageId);
        if (cmsPage==null){
            //页面不存在
            ExceptionCast.cast(CommonCode.CMS_PAGE_NOTEXISTS);
        }
        //获取页面的模板id
        String templateId = cmsPage.getTemplateId();
        if (StringUtils.isEmpty(templateId)){
            //页面模板为空
            ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL);
        }
        //查询模板信息
        Optional<CmsTemplate> optional = cmsTemplateRepository.findById(templateId);
        if (optional.isPresent()){
            CmsTemplate cmsTemplate = optional.get();
            //获取模板文件id
            String templateFileId = cmsTemplate.getTemplateFileId();
            //从GridFS中取模板文件内容
            //根据文件id查询文件
            GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(templateFileId)));

            //打开一个下载流对象
            GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
            //创建GridFsResource对象，获取流
            GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream);
            //从流中取数据
            try {
                String content = IOUtils.toString(gridFsResource.getInputStream(), "UTF-8");
                return content;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }

    private Map getModelByPageId(String pageId){
        //取出页面的信息
        CmsPage cmsPage = this.findById(pageId);
        if (cmsPage==null){
            //页面不存在
            ExceptionCast.cast(CommonCode.CMS_PAGE_NOTEXISTS);
        }
        //取出页面的dataUrl
        String dataUrl = cmsPage.getDataUrl();
        if (StringUtils.isEmpty(dataUrl)){
            //页面dataUrl为空
            ExceptionCast.cast(CommonCode.CMS_GENERATEHTML_DATAURLISNULL);
        }
        //通过restTemplate请求dataUrl获取数据
        ResponseEntity<Map> entity = restTemplate.getForEntity(dataUrl, Map.class);
        return entity.getBody();
    }
}
```



### 1.4 Controller

```java
@RestController
@RequestMapping("/cms/page")
public class CmsPageController implements CmsPageControllerApi {
    @Autowired
    private CmsPageService cmsPageService;

    @Override
    @GetMapping("/list/{page}/{size}")
    public QueryResponseResult findList(@PathVariable("page") int page, @PathVariable("size") int size, QueryPageRequest queryPageRequest) {
        return cmsPageService.findList(page,size,queryPageRequest);
    }

    @Override
    @PostMapping("/add")
    public CmsPageResult add(@RequestBody CmsPage cmsPage) {
        return cmsPageService.add(cmsPage);
    }

    @Override
    @GetMapping("/get/{id}")
    public CmsPage findById(@PathVariable String id) {
        return cmsPageService.findById(id);
    }

    @Override
    @PutMapping("/edit/{id}")
    public CmsPageResult edit(@PathVariable String id, @RequestBody CmsPage cmsPage) {
        return cmsPageService.edit(id,cmsPage);
    }
    
    
}
```



### 1.5 前端

#### 1.5.1 page

page_list.vue

```vue
<template>
  <!--编写页码静态部分，即View部分。必须有个根元素否则vue报错-->
  <div>
    <!--查询表单-->
    <el-select v-model="params.siteId" placeholder="请选择站点">
      <el-option
        v-for="item in siteList"
        :key="item.siteId"
        :label="item.siteName"
        :value="item.siteId">
      </el-option>
    </el-select>
    页面别名：
    <el-input v-model="params.pageAliase" style="width: 100px"></el-input>
    <el-button type="primary" size="small" @click="query">查询</el-button>
    <!--router-link时vue提供的路由功能，用于在页面生成路由链接，最终在html渲染后就是a标签，
    to表示目标路由地址；其中path为路由地址，query为url后的参数-->
    <router-link class="mui-tab-item" :to="{
    path:'/cms/page/add/',
    query:{
      page:this.params.page,
      siteId:this.params.siteId
    }}">
      <el-button type="primary" size="small">添加</el-button>
    </router-link>
    <el-table
      :data="list"
      stripe
      style="width: 100%">
      <el-table-column type="index" width="60">
      </el-table-column>
      <el-table-column prop="pageName" label="页面名称" width="120">
      </el-table-column>
      <el-table-column prop="pageAliase" label="别名" width="80">
      </el-table-column>
      <el-table-column prop="pageType" label="页面类型" width="80">
      </el-table-column>
      <el-table-column prop="pageWebPath" label="访问路径" width="250">
      </el-table-column>
      <el-table-column prop="pagePhysicalPath" label="物理路径" width="250">
      </el-table-column>
      <el-table-column prop="pageCreateTime" label="创建时间" width="180">
      </el-table-column>
      <el-table-column label="操作" width="200">
        <template slot-scope="page">
          <el-button size="small" type="text" @click="edit(page.row.pageId)">编辑</el-button>
          <el-button size="small" type="text" @click="del(page.row.pageId)">删除</el-button>
          <el-button @click="preview(page.row.pageId)" type="text" size="small">页面预览</el-button>
        </template>
      </el-table-column>
    </el-table>
    <el-pagination
      layout="prev, pager, next"
      :total="total"
      :page-size="params.size"
      :current-page="params.page"
      v-on:current-change="changePage"
      style="float:right">
    </el-pagination>
  </div>
</template>

<script>
  /*编写页面静态部分，即model及vm部分。*/
  import * as cmsApi from '../api/cms';

  export default {
    data() {
      return {
        list: [],
        siteList: [],
        total: 50,
        params: {
          page: 1,
          size: 10,
          siteId: '',
          pageAliase: ''
        }
      }
    },
    methods: {
      query() {
        cmsApi.page_list(this.params.page, this.params.size, this.params)
          .then((response) => {
            this.total = response.queryResult.total;
            this.list = response.queryResult.list;
          })
      },
      changePage(page) {
        this.params.page = page;
        this.query()
      },
      //query只是为了返回传值，用户体验
      edit(pageId) {
        this.$router.push({
          path: '/cms/page/edit/' + pageId, query: {
            page: this.params.page,
            siteId: this.params.siteId
          }
        })
      },
      del(pageId) {
        this.$confirm('确认删除吗？', '提示', {}).then(() => {
          cmsApi.page_del(pageId).then(res => {
            if (res.success) {
              this.$message.success("删除成功");
              this.query();//刷新页面
            } else {
              this.$message.success("删除失败");

            }
          })
        })
      },
      preview(pageId){
        window.open('http://www.xuecheng.com/cms/preview/'+pageId);
      }
    },
    created() {
      //取出路由中参数，赋值给数据对象。由于URL中是字符串，需转换
      this.params.page = JSON.parse(this.$route.query.page || 1); //没值默认为1！！！
      this.params.siteId = this.$route.query.siteId || '';

    },
    mounted() {
      this.query();
      //初始化站点列表。模拟数据，本应该请求后端来获取
      this.siteList = [
        {
          siteId: '5a751fab6abb5044e0d19ea1',
          siteName: '门户主站'
        },
        {
          siteId: '102',
          siteName: '测试站'
        }
      ]
    }

  }
</script>

<style>
  /*编写页面样式，不是必须*/
</style>

```

page_add.vue

```vue
<template>
  <div>
    <!--element表单校验，:rules指定规则；ref表单校验判断引用-->
    <el-form   :model="pageForm" label-width="80px" :rules="pageFormRules" ref="pageForm" >
      <el-form-item label="所属站点" prop="siteId">
        <el-select v-model="pageForm.siteId" placeholder="请选择站点">
          <el-option
            v-for="item in siteList"
            :key="item.siteId"
            :label="item.siteName"
            :value="item.siteId">
          </el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="选择模版" prop="templateId">
        <el-select v-model="pageForm.templateId" placeholder="请选择">
          <el-option
            v-for="item in templateList"
            :key="item.templateId"
            :label="item.templateName"
            :value="item.templateId">
          </el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="页面名称" prop="pageName">
        <el-input v-model="pageForm.pageName" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="别名" prop="pageAliase">
        <el-input v-model="pageForm.pageAliase" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="访问路径" prop="pageWebPath">
        <el-input v-model="pageForm.pageWebPath" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="物理路径" prop="pagePhysicalPath">
        <el-input v-model="pageForm.pagePhysicalPath" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="数据Url" prop="dataUrl">
        <el-input v-model="pageForm.dataUrl" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="类型">
        <el-radio-group v-model="pageForm.pageType">
          <el-radio class="radio" label="0">静态</el-radio>
          <el-radio class="radio" label="1">动态</el-radio>
        </el-radio-group>
      </el-form-item>
      <el-form-item label="创建时间">
        <el-date-picker type="datetime" placeholder="创建时间" v-model="pageForm.pageCreateTime"></el-date-picker>
      </el-form-item>

    </el-form>
    <div slot="footer" class="dialog-footer">
      <el-button @click="go_back">返回</el-button>
      <el-button type="primary" @click.native="addSubmit" :loading="addLoading">提交</el-button>
    </div>
  </div>
</template>
<script>
  import * as cmsApi from '../api/cms'
  export default{
    data(){
      return {
        //模版列表
        templateList:[],
        addLoading: false,//加载效果标记
        //新增界面数据
        pageForm: {
          siteId:'',
          templateId:'',
          pageName: '',
          pageAliase: '',
          pageWebPath: '',
          dataUrl:'',
          pageParameter:'',
          pagePhysicalPath:'',
          pageType:'',
          pageCreateTime: new Date()
        },
        pageFormRules: {
          siteId:[
            {required: true, message: '请选择站点', trigger: 'blur'}
          ],
          templateId:[
            {required: true, message: '请选择模版', trigger: 'blur'}
          ],
          pageName: [
            {required: true, message: '请输入页面名称', trigger: 'blur'}
          ],
          pageWebPath: [
            {required: true, message: '请输入访问路径', trigger: 'blur'}
          ],
          pagePhysicalPath: [
            {required: true, message: '请输入物理路径', trigger: 'blur'}
          ]
        },
        siteList:[],
        goback_params: {
          page: this.$route.query.page,
          siteId:this.$route.query.siteId,
        }
      }
    },
    methods:{
      go_back(){
        //this当前实例，$route路由
        this.$router.push({
          path: '/cms/page/list', query: {
            page: this.$route.query.page,
            siteId:this.$route.query.siteId
          }
        })
      },
      addSubmit(){
        //利用element的表单校验，先检查是否都通过
        this.$refs.pageForm.validate((valid) => {
          if (valid) {
            //利用element提交确认弹框
            this.$confirm('确认提交吗？', '提示', {}).then(() => {
              this.addLoading = true;
              cmsApi.page_add(this.pageForm).then(res => {
                //解析后端返回的JSON数据
                if(res.success){
                  this.addLoading = false;
                  //element提供提示信息组件
                  this.$message({
                    message: '提交成功',
                    type: 'success'
                  });
                  //利用element提交成功后重置表单数据
                  this.$refs['pageForm'].resetFields();//.调用也可以

                }else if(res.message){
                  this.addLoading = false;
                  this.$message.error(res.message);
                }else{
                  this.addLoading = false;
                  this.$message.error('提交失败');
                }
              });
            });
          }
        });
      }
    },
    created() {
    },
    mounted(){

      //初始化站点列表。模拟数据，本应该从后端获取
      this.siteList = [
        {
          siteId:'5a751fab6abb5044e0d19ea1',
          siteName:'门户主站'
        },
        {
          siteId:'102',
          siteName:'测试站'
        }
      ];
      //模板列表
      this.templateList = [
        {
          templateId:'5a962b52b00ffc514038faf7',
          templateName:'首页'
        },
        {
          templateId:'5a962bf8b00ffc514038fafa',
          templateName:'轮播图'
        }
      ];
    }
  }
</script>
<style>

</style>
```

page_edit.vue

```vue
<template>
  <div>
    <el-form :model="pageForm" label-width="80px" :rules="pageFormRules" ref="pageForm" >
      <el-form-item label="所属站点" prop="siteId">
        <el-select v-model="pageForm.siteId" placeholder="请选择站点">
          <el-option
            v-for="item in siteList"
            :key="item.siteId"
            :label="item.siteName"
            :value="item.siteId">
          </el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="选择模版" prop="templateId">
        <el-select v-model="pageForm.templateId" placeholder="请选择">
          <el-option
            v-for="item in templateList"
            :key="item.templateId"
            :label="item.templateName"
            :value="item.templateId">
          </el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="页面名称" prop="pageName">
        <el-input v-model="pageForm.pageName" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="别名" prop="pageAliase">
        <el-input v-model="pageForm.pageAliase" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="访问路径" prop="pageWebPath">
        <el-input v-model="pageForm.pageWebPath" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="物理路径" prop="pagePhysicalPath">
        <el-input v-model="pageForm.pagePhysicalPath" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="数据Url" prop="dataUrl">
        <el-input v-model="pageForm.dataUrl" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="类型">
        <el-radio-group v-model="pageForm.pageType">
          <el-radio class="radio" label="0">静态</el-radio>
          <el-radio class="radio" label="1">动态</el-radio>
        </el-radio-group>
      </el-form-item>
      <el-form-item label="创建时间">
        <el-date-picker type="datetime" placeholder="创建时间" v-model="pageForm.pageCreateTime"></el-date-picker>
      </el-form-item>

    </el-form>
    <div slot="footer" class="dialog-footer">
      <el-button @click="go_back">返回</el-button>
      <el-button type="primary" @click.native="editSubmit" :loading="addLoading">提交</el-button>
    </div>
  </div>
</template>
<script>
  import * as cmsApi from '../api/cms'
  export default{
    data(){
      return {
        //页面id
        pageId:'',
        //模版列表
        templateList:[],
        addLoading: false,//加载效果标记
        //新增界面数据
        pageForm: {
          siteId:'',
          templateId:'',
          pageName: '',
          pageAliase: '',
          pageWebPath: '',
          dataUrl:'',
          pageParameter:'',
          pagePhysicalPath:'',
          pageType:'',
          pageCreateTime: new Date()
        },
        pageFormRules: {
          siteId:[
            {required: true, message: '请选择站点', trigger: 'blur'}
          ],
          templateId:[
            {required: true, message: '请选择模版', trigger: 'blur'}
          ],
          pageName: [
            {required: true, message: '请输入页面名称', trigger: 'blur'}
          ],
          pageWebPath: [
            {required: true, message: '请输入访问路径', trigger: 'blur'}
          ],
          pagePhysicalPath: [
            {required: true, message: '请输入物理路径', trigger: 'blur'}
          ]
        },
        siteList:[]
      }
    },
    methods:{
      go_back(){
        this.$router.push({
          path: '/cms/page/list', query: {
            page: this.$route.query.page,
            siteId:this.$route.query.siteId
          }
        })
      },
      editSubmit(){
        this.$refs.pageForm.validate((valid) => {
          if (valid) {
            this.$confirm('确认提交吗？', '提示', {}).then(() => {
              this.addLoading = true;
              cmsApi.page_edit(this.pageId,this.pageForm).then((res) => {
                  console.log(res);
                if(res.success){
                  this.addLoading = false;
                  this.$message({
                    message: '提交成功',
                    type: 'success'
                  });
                  //返回
                  this.go_back();

                }else{
                  this.addLoading = false;
                  this.$message.error('提交失败');
                }
              });
            });
          }
        });
      }

    },
    created: function () {
      //页面参数通过路由传入，这里通过this.$route.params来获取
      this.pageId=this.$route.params.pageId;
      //根据主键查询页面信息
      cmsApi.page_get(this.pageId).then((res) => {
        console.log(res);
        if(res){
          this.pageForm = res;
        }
      });
    },
    mounted:function(){

      //初始化站点列表
      this.siteList = [
        {
          siteId:'5a751fab6abb5044e0d19ea1',
          siteName:'门户主站'
        },
        {
          siteId:'102',
          siteName:'测试站'
        }
      ]
      //模板列表
      this.templateList = [
        {
          templateId:'5a962b52b00ffc514038faf7',
          templateName:'首页'
        },
        {
          templateId:'5a962bf8b00ffc514038fafa',
          templateName:'轮播图'
        }
      ]
    }
  }
</script>
<style>

</style>
```







#### 1.5.2 router

创建`cms/router/index.js`，实现url访问到页面

```js
import Home from '@/module/home/page/home.vue';
import page_list from '@/module/cms/page/page_list.vue';
import page_add from "@/module/cms/page/page_add";
import page_edit from "@/module/cms/page/page_edit";

export default [{
    path: '/cms',
    component: Home,
    name: 'CMS内容管理',
    hidden: false,
    children: [{path: '/cms/page/list',component: page_list,name: '页面列表',hidden: false},
               {path: '/cms/page/add',component: page_add,name: '添加页面',hidden: true},
               {path: '/cms/page/edit/:pageId',component: page_edit,name: '修改页面',hidden: true}
              ]
}]
```

在`base/router/index.js`导入cms模块的路由

```js
import Vue from 'vue';
import Router from 'vue-router';
Vue.use(Router);
// 定义路由配置
let routes = []
let concat = (router) => {
    routes = routes.concat(router)
}
//导入路由规则
import HomeRouter from '@/module/home/router';
import CmsRouter from '@/module/cms/router';
// 合并路由规则
concat(HomeRouter);
concat(CmsRouter);
export default routes;
```



#### 1.5.3 api

```js
//public是对axios的工具类封装，定义了http请求方法
import http from './../../../base/api/public';

let sysConfig = require('@/../config/sysConfig');
let apiUrl = sysConfig.xcApiUrlPre;
import querystring from 'querystring'

//分页条件查询
export const page_list = (page, size, params) => {
  //将json对象转成key/value对
  let query = querystring.stringify(params);
  return http.requestQuickGet(apiUrl + '/cms/page/list/' + page + '/' + size + '?' + query)
};

//添加页面
export const page_add = params =>http.requestPost(apiUrl+'/cms/page/add',params);
//根据id查找页面
export const page_get = id=>  http.requestQuickGet(apiUrl+'/cms/page/get/'+id);
//修改页面
export const page_edit = (id,params)=>http.requestPut(apiUrl+'/cms/page/edit/'+id,params);
//删除页面
export const page_del = id=>http.requestDelete(apiUrl+'/cms/page/del/'+id);
```







## 2 添加页面

前后端代码查看第3章

路由到add页面，并为了返回体验，传递当前页和查询条件。在add页返回参数并路由到list页。。。

`$route.query.xxx`获取`?`后的参数

`$route.params.xxx`获取path中参数

`$route`和`​$router`区别！！！



## 3 修改页面



## 4 删除页面



## 5 异常处理

### 5.1 异常处理的问题分析

分析如下代码

```java
public CmsPageResult add(CmsPage cmsPage){
    //校验页面是否存在，根据页面名称、站点Id、页面webpath查询
    CmsPage page = cmsPageRepository.findBySiteIdAndPageNameAndPageWebPath(cmsPage.getSiteId(), cmsPage.getPageName(), cmsPage.getPageWebPath());
    if (page==null){
        cmsPage.setPageId(null);//为了让id自增
        cmsPageRepository.save(cmsPage);
        return new CmsPageResult(CommonCode.SUCCESS,cmsPage);
    } else {
        return new CmsPageResult(CommonCode.FAIL,null);
    }
}
```

问题：

- 只要操作不成功仅向用户返回“错误代码：11111，失败信息：操作失败”，无法区别具体的错误信息。
- service方法在执行过程出现异常在哪捕获？在service中需要都加try/catch，如果在controller也需要添加try/catch，代码冗余严重且不易维护。

解决方案：

* 在Service方法中的编码顺序是**先校验判断**，有问题则抛出具体的异常信息，**最后执行具体的业务操作**，返回成功信息。
* 在**统一异常处理类**中去**捕获**异常，无需controller捕获异常，**向用户返回统一规范的响应信息**



### 5.2 异常处理流程

系统对异常的处理使用统一的异常处理流程：

* **自定义异常类型**，继承RuntimeException
* 自定义**错误代码及错误信息**。
* 对于**可预知的异常由程序员在代码中主动抛出**，由SpringMVC统一捕获。
  可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较
  齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。
* 对于**不可预知的异常（运行时异常）**由**SpringMVC统一捕获**Exception类型的异常。
  不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为
  RuntimeException类型（运行时异常）。
* 可预知的异常及不可预知的运行时异常**最终会采用统一的信息格式**（错误代码+错误信息）来表示，最终也会随
  请求响应为JSON给客户端。

异常抛出及处理流程：

![1550681223850](images/1550681223850.png)

1. 在**controller、service、dao中程序员抛出自定义异常**；springMVC框架抛出框架异常类型
2. 统一由**异常捕获类捕获异常**，并进行处理
3. 捕获到自定义异常则直接取出错误代码及错误信息，响应给用户。
4. 捕获到非自定义异常类型首先从Map中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误信息并响应给用户，如果从Map中找不到异常类型所对应的错误代码则统一为99999错误代码并响应给用户。
5. 将错误代码及错误信息**以JSON格式响应给用户**



### 5.3 可预知异常处理

#### 5.3.1 自定义异常类

在common工程定义异常类型

```java
public class CustomException extends RuntimeException {

    private ResultCode resultCode;

    //由构造方法传入
    public CustomException(ResultCode resultCode) {
        this.resultCode = resultCode;
    }

    //提供get方法获取具体信息

    public ResultCode getResultCode() {
        return resultCode;
    }
}
```



#### 5.3.2 异常抛出类

只是封装了`throw new xxx`

```java
public class ExceptionCast {
    
    public static void cast(ResultCode resultCode){
        throw new CustomException(resultCode);
    }
}
```



#### 5.3.3 异常捕获类

```java
@ControllerAdvice//控制器增强
public class ExceptionCatch {

    private static final Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch.class);

    //使用EXCEPTIONS存放异常类型和错误代码的映射，ImmutableMap的特点的一旦创建不可改变，并且线程安全
    private static ImmutableMap<Class<? extends Throwable>, ResultCode> EXCEPTIONS;
    //使用builder来构建一个异常类型和错误代码的异常
    protected static ImmutableMap.Builder<Class<? extends Throwable>, ResultCode> builder =
        ImmutableMap.builder();

    //在这里加入一些基础的异常类型判断。这里只添加了一个示例
    static {
        builder.put(HttpMessageNotReadableException.class, CommonCode.INVALID_PARAM);
    }

    @ExceptionHandler(CustomException.class)//捕获 CustomException异常
    @ResponseBody//返回JSON数据
    public ResponseResult customException(CustomException e) {
        LOGGER.error("catch exception:\n" + e.getMessage(), e);//catch到异常记录日志
        return new ResponseResult(e.getResultCode());
    }

    @ExceptionHandler(Exception.class)//捕获 Exception异常
    @ResponseBody//返回JSON数据
    public ResponseResult exception(Exception e) {
        LOGGER.error("catch exception:\n" + e.getMessage(), e);//catch到异常记录日志
        if (EXCEPTIONS == null) {
            EXCEPTIONS = builder.build();
        }
        ResponseResult responseResult;
        ResultCode resultCode = EXCEPTIONS.get(e.getClass());
        if (resultCode != null) {
            responseResult = new ResponseResult(resultCode);
        } else {
            responseResult = new ResponseResult(CommonCode.SERVER_ERROR);//99999异常
        }
        return responseResult;
    }
}
```



还需再启动类上注解要扫描异常类所在包

```java
@ComponentScan("com.xuecheng.framework")//扫描common工程下的类，包括异常类
```



#### 5.3.4 测试

后端代码如service/controller/dao修改查看3.1



### 5.4 不可预知异常处理

#### 5.4.1 定义异常捕获方法

使用postman测试后端添加页面方法，不输入cmsPost信息，提交，报错信息如下：`org.springframework.http.converter.HttpMessageNotReadableException`

此异常是springMVC在进行参数转换时报的错误。响应状态码400等信息在客户端是无法解析的

在异常捕获类中添加对Exception类的捕获。代码查看上面的



#### 5.4.2 异常捕获方法

针对上边的问题其解决方案是：

1. 我们在map中配置HttpMessageNotReadableException和错误代码。
2. 在异常捕获类中对Exception异常进行捕获，并从map中获取异常类型对应的错误代码，如果存在错误代码则返回此错误，否则统一返回99999错误。

具体的开发实现如下：

1. 在通用错误代码类CommCode中配置非法参数异常。用于添加到map集合中

   ```java
   INVALID_PARAM(false,10003,"非法参数！"),
   ```

2. 在异常捕获类中配置 HttpMessageNotReadableException 为非法参数异常。代码查看上面的5.3.3





# 4 页面静态化—页面仅预览

## 1 页面静态化需求

1. 为什么要进行页面管理？

   本项目cms系统的功能就是根据运营需要，对门户等子系统的部分页面进行管理，从而实现快速根据用户需求修改页面内容并上线的需求

2. 如何修改页面的内容？

   在开发中修改页面内容是需要人工编写html及JS文件，**CMS系统是通过程序自动化的对页面内容进行修改**，通过页面静态化技术生成html页面

3. 如何对页面进行静态化？

   一个页面等于模板加数据，在添加页面的时候我们选择了页面的模板。页面静态化就是将页面模板和数据通过技术手段将二者合二为一，生成一个html网页文件

业务**流程**如下：

1. 获取**模型数据**
2. **制作模板**
3. 对页面进行**静态化**
4. 将静态化生成的html页面存放**文件系统**中
5. 将存放在文件系统的html文件**发布到服务器**



## 2 页面静态化

### 2.1 页面静态化流程

如何获取页面的数据模型？

CMS管理了各种页面，CMS对页面进行静态化时需要数据模型，但是CMS并不知道每个页面的数据模型的具体内容，它只管执行静态化程序便可对页面进行静态化，所以CMS静态化程序需要通过一种通用的方法来获取数据模型。

在编辑页面信息时指定一个DataUrl，此**DataUrl**便是获取数据模型的Url，它基于Http方式，CMS对页面进行静态化时会从页面信息中读取DataUrl，通过Http远程调用的方法请求DataUrl获取数据模型。若此页面是轮播图页面，它的DataUrl由开发轮播图管理的程序员提供。同理精品课程推荐页面、课程详情页面也一样。

![1550754095049](images/1550754095049.png)

### 2.2 数据模型

#### 2.2.1 轮播图DataUrl接口

##### 1、需求分析

CMS中有轮播图管理、精品课程推荐的功能，以轮播图管理为例说明：轮播图管理是通过可视化的操作界面由管理员指定轮播图片地址，最后将轮播图图片地址保存在**cms_config**集合中。针对首页的轮播图信息、精品推荐等信息的获取统一提供一个Url供静态化程序调用，这样我们就知道了轮播图页面、精品课程推荐页面的DataUrl，管理在页面配置中将此Url配置在页面信息中。

本小节开发一个查询轮播图、精品推荐信息的接口，此接口**供静态化程序调用获取数据模型**

##### 2、接口定义

轮播图信息、精品推荐等信息存储在MongoDB的**cms_config**集合中。

**cms_config有固定的数据结构如下：**

```java
@Data
@Document(collection = "cms_config")
public class CmsConfig {
    @Id
    private String id;//主键
    private String name;//数据模型的名称
    private List<CmsConfigModel> model;//数据模型项目
}
```

其中数据模型项目内容如下：

```java
@Data
public class CmsConfigModel {
    private String key;//主键
    private String name;//项目名称
    private String url;//项目url
    private Map mapValue;//项目复杂值
    private String value;//项目简单值
}
```

**根据ID查询配置信息**，定义接口如下：

```java
@Api(value="cms配置管理接口",description = "cms配置管理接口，提供数据模型的管理、查询接口")
public interface CmsConfigControllerApi {

    @ApiOperation("根据id查询CMS配置信息")
    CmsConfig getModel(String id);
}
```

##### 3、Dao

```java
public interface CmsConfigRepository extends MongoRepository<CmsConfig,String> {
}
```

##### 4、service

```java
@Service
public class CmsConfigService {

    @Autowired
    private CmsConfigRepository cmsConfigRepository;

    public CmsConfig getModel(String id){
        Optional<CmsConfig> optional = cmsConfigRepository.findById(id);
        return optional.orElse(null);//简写形式
    }
}
```

##### 5、controller

```java
@RestController
@RequestMapping("/cms/config")
public class CmsConfigController implements CmsConfigControllerApi {

    @Autowired
    private CmsConfigService cmsConfigService;

    @Override
    @GetMapping("/getmodel/{id}")
    public CmsConfig getModel(@PathVariable String id) {
        return cmsConfigService.getModel(id);
    }
}
```

利用Swagger或PostMan测试成功http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f



#### 2.2.2 远程请求接口RestTemplate

SpringMVC提供 **RestTemplate请求http接口**，RestTemplate的底层可以使用第三方的http客户端工具实现http 的请求，常用的http客户端工具有Apache HttpClient、**OkHttpClient**等，本项目使用OkHttpClient完成http请求，原因也是因为它的性能比较出众。

依赖

```xml
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
</dependency>
```

配置RestTemplate。可以在启动类中配置

```java
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
}
```

测试RestTemplate。根据url获取数据，并转为map格式。

```java
@Autowired
private RestTemplate restTemplate;
@Test
public void testRestTemplate(){
    ResponseEntity<Map> forEntity =
        restTemplate.getForEntity("http://localhost:31001/cms/config/get/5a791725dd573c3574ee333f",Map.class);
    System.out.println(forEntity);
}
```

> 需要修改cms_config集合中图片的地址用nginx中静态页面的图片替代，否则查看不到

### 2.3 模板管理（手动\^_^）

#### 2.3.1 模板管理业务流程

CMS提供模板管理功能，业务流程如下：

![1550759950705](images/1550759950705.png)

1. 要增加新模板首先需要制作模板，模板的内容就是Freemarker ftl模板内容。

2. 通过模板管理模块功能新增模板、修改模板、删除模板。

3. 模板信息存储在MongoDB数据库，其中**模板信息**存储在**cms_template**集合中，模板文件存储在**GridFS**文件系统中。

   templateFileId是模板文件的ID，此ID对应GridFS文件系统中文件ID

#### 2.3.2 模板制作

##### 1、编写模板文件

在门户的静态工程目录有**轮播图的静态页面**，路径是：`/include/index_banner.html`，只需改为ftl，并遍历图片即可

##### 2、模板测试RestTemplate

```java
@RequestMapping("/test2")
public String freemarker2(Map<String, Object> map) {
    ResponseEntity<Map> entity = restTemplate.getForEntity("http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f", Map.class);
    System.out.println(entity.getBody());
    map.putAll(entity.getBody());
    return "index_banner";
}
```

RestTemplate获取的数据结构截取如下：

```json
"name"  : "xxx"
"model" : [
    {
        "key" : "banner1", 
        "name" : "轮播图1地址", 
        "value" : "http://www.xuecheng.com/img/widget-bannerB.jpg"
    },
```



#### 2.3.3 GridFS研究

[GridFS](https://docs.mongodb.com/manual/core/gridfs/)是MongoDB提供的用于持久化存储文件的模块，CMS使用MongoDB存储数据，使用GridFS可以快速集成开发。

它的工作原理是：在GridFS存储文件是将文件分块存储，文件会按照256KB的大小分割成多个块进行存储，GridFS使用两个集合
（collection）存储文件，一个集合是`chunks`, 用于存储文件的**二进制数据**；一个集合是`files`，用于存储文件的**元数据**信息（文件名称、块大小、上传时间等信息）。从GridFS中读取文件要对文件的各各块进行组装、合并。

##### 1、GridFS存文件测试

向测试程序注入GridFsTemplate（直接使用！不用配置Bean）

```java
//存文件
@Test
public void testStore() throws FileNotFoundException {
    //定义file
    File file =new File("d:/index_banner.ftl");
    //定义fileInputStream
    FileInputStream fileInputStream = new FileInputStream(file);
    ObjectId objectId = gridFsTemplate.store(fileInputStream, "index_banner.ftl");
    System.out.println(objectId);
}
```

存储原理说明：

文件存储成功得到一个文件id，是`fs.files`集合中的主键。可以通过文件id查询`fs.chunks`表中的记录，得到文件的内容。



##### 2、GridFS读文件测试

在config包中定义Mongodb的配置类，GridFSBucket用于打开下载流对象，如下：

```java
@Configuration
public class MongoConfig {
    @Value("${spring.data.mongodb.database}")
    String db;
    @Bean
    public GridFSBucket getGridFSBucket(MongoClient mongoClient){
        MongoDatabase database = mongoClient.getDatabase(db);
        GridFSBucket bucket = GridFSBuckets.create(database);
        return bucket;
    }
}
```

测试代码如下

```java
@Autowired
GridFSBucket gridFSBucket;

//取文件
@Test
public void queryFile() throws IOException {
    //根据文件id查询文件
    GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is("5c6ec434eca668357c802175")));
    //打开一个下载流对象
    GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
    //创建GridFsResource对象，获取流
    GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream);
    //从流中取数据
    String content = IOUtils.toString(gridFsResource.getInputStream(), "utf-8");
    System.out.println(content);

}
```



##### 3、GridFS删除文件测试

```java
//删除文件
@Test
public void testDelFile() throws IOException {
    //根据文件id删除fs.files和fs.chunks中的记录
    gridFsTemplate.delete(Query.query(Criteria.where("_id").is("5c6ec434eca668357c802175")));
}
```



#### 2.3.4 模板存储（手动\^_^）

根据模板管理的流程，最终将模板信息存储到MongoDB的cms_template中，将模板文件存储到GridFS中。

模板管理功能在课堂中不再讲解，教学中手动向cms_template及GridFS中存储模板

添加模板：使用GridFS测试代码存储模板文件到GridFS，并得到文件id。向cms_template添加记录

删除模板：使用GridFS测试代码根据文件id删除模板文件，根据模板id删除cms_template中的记录

修改模板信息：使用Studio 3T修改cms_template中的记录

修改模板文件：通过Studio 3T修改模板文件(`fs.chunks`，此方法限文件小于256K)，先找到模板文件，再导入进去



### 2.4 静态化测试（*）

上边章节完成了数据模型和模板管理的测试，下边测试整个页面静态化的流程，流程如下：

1、填写页面DataUrl，将此字段保存到cms_page集合中。

2、静态化程序获取页面的DataUrl

3、静态化程序远程请求DataUrl获取数据模型。

4、静态化程序获取页面的模板信息

5、执行页面静态化

静态化程序。如下代码应放入3.1中service

```java
//页面静态化方法，返回html内容
public String getPageHtml(String pageId){
    //静态化程序远程请求DataUrl获取数据模型。
    Map model = getModelByPageId(pageId);
    if (model==null){
        //数据模型获取不到
        ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_DATAISNULL);
    }
    //静态化程序获取页面的模板信息
    String templateContent = getTemplateByPageId(pageId);
    if (StringUtils.isEmpty(templateContent)){
        //页面模板为空
        ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL);
    }
    //执行页面静态化
    String html = generateHtml(templateContent, model);
    return html;
}

private String generateHtml(String templateContent,Map model){
    //创建配置对象
    Configuration configuration = new Configuration(Configuration.getVersion());
    //创建模板加载器
    StringTemplateLoader stringTemplateLoader = new StringTemplateLoader();
    stringTemplateLoader.putTemplate("template",templateContent);
    //向configuration配置模板加载器
    configuration.setTemplateLoader(stringTemplateLoader);
    try {
        Template template = configuration.getTemplate("template");
        String html = FreeMarkerTemplateUtils.processTemplateIntoString(template, model);
        return html;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}


private String getTemplateByPageId(String pageId) {
    //取出页面的信息
    CmsPage cmsPage = this.findById(pageId);
    if (cmsPage==null){
        //页面不存在
        ExceptionCast.cast(CommonCode.CMS_PAGE_NOTEXISTS);
    }
    //获取页面的模板id
    String templateId = cmsPage.getTemplateId();
    if (StringUtils.isEmpty(templateId)){
        //页面模板为空
        ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL);
    }
    //查询模板信息
    Optional<CmsTemplate> optional = cmsTemplateRepository.findById(templateId);
    if (optional.isPresent()){
        CmsTemplate cmsTemplate = optional.get();
        //获取模板文件id
        String templateFileId = cmsTemplate.getTemplateFileId();
        //从GridFS中取模板文件内容
        //根据文件id查询文件
        GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(templateFileId)));
        //打开一个下载流对象
        GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
        //创建GridFsResource对象，获取流
        GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream);
        //从流中取数据
        try {
            String content = IOUtils.toString(gridFsResource.getInputStream(), "UTF-8");
            return content;
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}

private Map getModelByPageId(String pageId){
    //取出页面的信息
    CmsPage cmsPage = this.findById(pageId);
    if (cmsPage==null){
        //页面不存在
        ExceptionCast.cast(CommonCode.CMS_PAGE_NOTEXISTS);
    }
    //取出页面的dataUrl
    String dataUrl = cmsPage.getDataUrl();
    if (StringUtils.isEmpty(dataUrl)){
        //页面dataUrl为空
        ExceptionCast.cast(CommonCode.CMS_GENERATEHTML_DATAURLISNULL);
    }
    //通过restTemplate请求dataUrl获取数据
    ResponseEntity<Map> entity = restTemplate.getForEntity(dataUrl, Map.class);
    return entity.getBody();
}
```







## 3 页面预览

### 3.1 页面预览开发

#### 3.1.1 需求分析

页面在发布前增加页面预览的步骤，方便用户检查页面内容是否正确。（内部就是执行页面静态化，返回html代码）：

1、用户进入cms前端，点击“页面预览”在浏览器请求cms页面预览链接。

2、cms根据页面id查询DataUrl并远程请求DataUrl获取数据模型。

3、cms根据页面id查询页面模板内容

4、cms执行页面静态化。

5、cms将静态化内容响应给浏览器。

6、在浏览器展示页面内容，实现页面预览的功能。



#### 3.1.2 搭建环境

在CMS服务中加入freemarker的依赖，并配置

```yaml
spring:
  freemarker:
    cache: false #关闭模板缓存，方便测试
    settings:
      template_update_delay: 0
```



#### 3.1.3 Controller

调用service的静态化方法，将静态化内容通过**response**输出到浏览器显示

```java
@Controller//需要Response输出
public class CmsPagePreviewController extends BaseController {

    @Autowired
    private CmsPageService cmsPageService;

    //根据页面id来生成静态页面内容
    @GetMapping("/cms/preview/{pageId}")
    public void preview(@PathVariable("pageId") String pageId) {
        String pageHtml = cmsPageService.getPageHtml(pageId);
        if (!StringUtils.isEmpty(pageHtml)){
            try {
                response.getOutputStream().write(pageHtml.getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

访问http://localhost:31001/cms/preview/5a795ac7dd573c04508f3a56即可看到轮播图

### 3.2 页面预览测试

#### 3.2.1 配置Nginx代理

为了通过nginx请求静态资源（css、图片等），通过nginx代理进行页面预览。

在www.xuecheng.com虚拟主机配置：

```
#后端nginx集群cms页面预览
location /cms/preview/ {
	proxy_pass http://cms_server_pool/cms/preview/;
}
```

配置cms_server_pool将请求转发到cms

```
#后端nginx集群cms页面预览
upstream cms_server_pool{
	server 127.0.0.1:31001 weight=10;
}
```

访问http://www.xuecheng.com/cms/preview/5a795ac7dd573c04508f3a56即可看到轮播图



#### 3.2.2 添加“页面预览”链接

修改page_list.vue，添加preview方法。利用`window.open('url')`实现预览。代码查看3.1





# 5 消息队列—RabbitMQ

## 1 页面发布

![1550825377029](images/1550825377029.png)

业务流程如下：

1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。

2、cms页面发布接口执行页面静态化，并将静态化页面(html文件)存储至GridFS中。

3、静态化成功后，向消息队列发送页面发布的消息。页面发布的最终目标是将页面发布到服务器。**通过消息队列将页面发布的消息发送给各个服务器**。

3、消息队列负责将消息发送给各个服务器上部署的Cms Client(Cms客户端)。在服务器上部署Cms Client(Cms客户端)，客户端接收消息队列的通知。

4、每个接收到页面发布消息的Cms Client从GridFS获取Html页面文件，并**将Html文件存储在本地服务器**。CmsClient根据页面发布消息的内容请求GridFS获取页面文件，存储在本地服务器。



## 2 RabbitMQ

> 查看Spring Boot中笔记



# 6 页面真发布—课程管理

## 1 页面发布

### 1.1 技术方案

本项目使用MQ实现页面发布的技术方案如下：

![1550989837755](images/1550989837755.png)

技术**方案**说明：

1、平台包括**多个站点**，页面归属不同的站点。

2、发布一个页面应将该页面**发布到所属站点的服务器**上。

3、每个站点服务器部署**cms client**程序，并与**交换机绑定**，绑定时指定**站点Id**为**routingKey**，就可以实现cms client只能接收到所属站点的页面发布消息。

4、页面发布程序向MQ发布消息时指定页面所属站点Id为routingKey，将该页面发布到它所在服务器上的cms client。

------

页面发布流程图如下：

![1550994071959](images/1550994071959.png)





### 1.2 页面发布生产方

#### 1.2.1 需求分析

管理员通过 cms系统发布“页面发布”的消费，cms系统作为页面发布的生产方。需求如下：

1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。

2、cms页面发布接口执行页面静态化，并将静态化页面存储至GridFS中。

3、静态化成功后，向消息队列发送页面发布的消息。

​	1） 获取页面的信息及页面所属站点ID。

​	2） 设置消息内容为页面ID。（采用json格式，方便日后扩展）

​	3） 发送消息给ex_cms_postpage交换机，并将**站点ID**作为**routingKey**。



#### 1.2.2 RabbitMQ配置

amqp的起步依赖

在application.yml中配置Rabbitmq的连接参数

```yaml
rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
    virtualHost: /
```

RabbitMQConfig配置：

由于cms作为页面发布方要面对很多不同站点的服务器，面对很多页面发布队列，所以这里不再配置队列，只需要配置交换机即可

```java
@Configuration
public class RabbitMQConfig {

    //交换机的名称
    public static final String EX_ROUTING_CMS_POSTPAGE="ex_routing_cms_postpage";

    //交换机配置使用direct类型，routing。durable为持久化，重启不删除
    @Bean(EX_ROUTING_CMS_POSTPAGE)
    public Exchange EXCHANGE_TOPICS_INFORM() {
        return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build();
    }
}
```



#### 1.2.3 Api接口

```java
@ApiOperation("页面发布")
ResponseResult post(String id);
```



#### 1.2.4 Service

CmsPageService中添加代码：

```java
//页面发布
public ResponseResult post(String pageId){
    //执行页面静态化
    String content = this.getPageHtml(pageId);
    //将HTML页面存储到GridFS中
    CmsPage cmsPage = this.saveHtml(pageId, content);
    //向MQ发消息
    this.sendPostPage(pageId);
    return new ResponseResult(CommonCode.SUCCESS);

}

//向mq 发送消息
private void sendPostPage(String pageId){
    //创建消息对象并转为JSON字符串
    Map<String,Object> map = new HashMap();
    map.put("pageId",pageId);
    String jsonString = JSON.toJSONString(map);
    //发送MQ
    CmsPage cmsPage = this.findById(pageId);//先得到页面信息
    if (cmsPage == null){
        ExceptionCast.cast(CommonCode.INVALID_PARAM);
    }
    String siteId = cmsPage.getSiteId();//站点id座位routingKey
    rabbitTemplate.convertAndSend(RabbitMQConfig.EX_ROUTING_CMS_POSTPAGE,siteId,jsonString);

}

//保存HTML到GridFS中
private CmsPage saveHtml(String pageId,String content){
    CmsPage cmsPage = this.findById(pageId);//先得到页面信息
    if (cmsPage == null){
        ExceptionCast.cast(CommonCode.INVALID_PARAM);
    }
    InputStream inputStream = null;
    ObjectId objectId = null;
    try {
        //将htmlContent内容转成输入流
        inputStream = IOUtils.toInputStream(content, "UTF-8");
        //将html文件内容保存到GridFS
        objectId = gridFsTemplate.store(inputStream, this.findById(pageId).getPageName());

    } catch (IOException e) {
        e.printStackTrace();
    }
    //将HTML文件id更新到cmspage中
    if (objectId != null){
        cmsPage.setHtmlFileId(objectId.toHexString());
        cmsPageRepository.save(cmsPage);
    }
    return cmsPage;
}
```

#### 1.2.5 Controller

CmsPageController中实现api接口，接收页面请求，调用service执行页面发布

```java
@Override
@PostMapping("/postPage/{pageId}")
public ResponseResult post(@PathVariable String pageId) {
    return cmsPageService.post(pageId);
}
```





### 1.3 页面发布消费方

#### 1.3.1 需求分析

创建**Cms Client工程**作为页面发布消费方，将Cms Client部署在**多个服务器上**，它负责接收到页面发布的消息后从GridFS中下载文件在本地保存。

需求如下：

1、将cms Client部署在服务器，配置**队列名称和站点ID**。

2、cms Client连接RabbitMQ并监听各自的“页面发布队列”

3、cms Client接收页面发布队列的消息

4、根据消息中的**页面id**从mongodb数据库下载页面到本地

5、调用dao查询页面信息，获取到页面的物理路径，调用dao查询站点信息，得到站点的物理路径
页面物理路径=**站点物理路径**+**页面物理路径**+**页面名称**。从GridFS查询静态文件内容，将静态文件内容保存到页面物理路径下。



#### 1.3.2 创建Cms Client工程

`xc-service-manage-cms-client`的依赖如下：

```xml
<!--Spring Boot 继承amqp-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-io</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
</dependency>
<dependency>
    <groupId>com.xuecheng</groupId>
    <artifactId>xc-framework-model</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

启动类

```java
@SpringBootApplication
@EntityScan("com.xuecheng.framework.domain.cms")//扫描实体类
@ComponentScan(basePackages={"com.xuecheng.framework"})//扫描common包下的类
@ComponentScan(basePackages={"com.xuecheng.manage_cms_client"})//扫描本项目下的所有类
public class XcServiceManageCmsClientApplication {

    public static void main(String[] args) {
        SpringApplication.run(XcServiceManageCmsClientApplication.class, args);
    }
}
```



#### 1.3.3 RabbitMQ配置

application.yml和logback-spring.xml（略）配置文件如下：

```yaml
server:
  port: 31000
spring:
  application:
    name: xc-service-manage-cms-client
  data:
    mongodb:
      uri:  mongodb://root:123@localhost:27017
      database: xc_cms
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
    virtualHost: /
xuecheng:
  mq:
    #cms客户端监控的队列名称（不同的客户端监控的队列不能重复，有的为了集群，有的是因为不同站点的服务器）
    queue: queue_cms_postpage_01
    routingKey: 5a751fab6abb5044e0d19ea1	#此routingKey为门户站点ID
```

消息队列设置如下：

1、创建“ex_cms_postpage”交换机

2、每个Cms Client创建一个队列与交换机绑定

3、每个Cms Client程序配置队列名称和routingKey，将站点ID作为routingKey。

```java
@Configuration
public class RabbitMQConfig {

    //队列bean的名称
    public static final String QUEUE_CMS_POSTPAGE = "queue_cms_postpage";
    //交换机的名称
    public static final String EX_ROUTING_CMS_POSTPAGE="ex_routing_cms_postpage";
    //队列的名称
    @Value("${xuecheng.mq.queue}")
    public  String queue_cms_postpage_name;
    //routingKey 即站点Id
    @Value("${xuecheng.mq.routingKey}")
    public  String routingKey;

    //交换机配置使用direct类型，routing。durable为持久化，重启不删除
    @Bean(EX_ROUTING_CMS_POSTPAGE)
    public Exchange EXCHANGE_TOPICS_INFORM() {
        return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build();
    }

    //声明队列
    @Bean(QUEUE_CMS_POSTPAGE)
    public Queue QUEUE_CMS_POSTPAGE() {
        return new Queue(queue_cms_postpage_name);
    }

    //绑定队列到交换机
    @Bean
    public Binding BINDING_QUEUE_INFORM_SMS(@Qualifier(QUEUE_CMS_POSTPAGE) Queue queue, @Qualifier(EX_ROUTING_CMS_POSTPAGE) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(routingKey).noargs();
    }
}
```

```java
//用于下载MongoDB中文件
@Configuration
public class MongoConfig {
    @Value("${spring.data.mongodb.database}")
    String db;

    @Bean
    public GridFSBucket getGridFSBucket(MongoClient mongoClient){
        MongoDatabase database = mongoClient.getDatabase(db);
        return GridFSBuckets.create(database);
    }
}
```



#### 1.3.4 定义消息格式

消息内容采用json格式存储数，**方便后期扩展**，如下：

```json
{
    "pageId":"" //页面id：发布页面的id
}
```



#### 1.3.4 Dao

查询页面信息，获取页面路径和页面名称

```java
public interface CmsPageRepository extends MongoRepository<CmsPage,String> {
}
```

查询站点信息，主要获取站点物理路径

```java
public interface CmsSiteRepository extends MongoRepository<CmsSite,String > {
}
```



#### 1.3.5 Service

定义保存页面静态文件到服务器物理路径方法

```java
@Service
public class PageService {

    private static final Logger LOGGER = LoggerFactory.getLogger(PageService.class);

    @Autowired
    private CmsPageRepository cmsPageRepository;

    @Autowired
    private CmsSiteRepository cmsSiteRepository;

    @Autowired
    private GridFsTemplate gridFsTemplate;//由于依赖了MongoDB所以直接注入即可使用

    @Autowired
    private GridFSBucket gridFSBucket;//需要配置类

    //将页面html保存到页面物理路径
    public void savePageToServerPath(String pageId) {
        //根据pageId查询cmsPage
        CmsPage cmsPage = this.findCmsPageById(pageId);
        //得到html的文件id，即从cmsPage中获取htmlFileId内容
        String htmlFileId = cmsPage.getHtmlFileId();
        //从gridFS中查询html文件的输入流
        InputStream inputStream = this.getFileById(htmlFileId);
        if (inputStream == null) {
            LOGGER.error("getFileById InputStream is null ,htmlFileId:{}", htmlFileId);//记录错误日志
            return;
        }

        //得到站点的信息
        String siteId = cmsPage.getSiteId();
        CmsSite cmsSite = this.findCmsSiteById(siteId);
        //得到站点的物理路径
        String sitePhysicalPath = cmsSite.getSitePhysicalPath();//这个模型该Field未定义，需定义

        //最终要存入的路径
        String path = sitePhysicalPath + cmsPage.getPagePhysicalPath() + cmsPage.getPageName();

        //通过输入流和文件名称保存到该服务器中。利用common.io
        FileOutputStream fileOutputStream = null;
        try {
            fileOutputStream = new FileOutputStream(new File(path));
            IOUtils.copy(inputStream, fileOutputStream);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                inputStream.close();
                if (fileOutputStream != null) {
                    fileOutputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

    //根据文件id从GridFS中查询文件内容，返回输入流
    public InputStream getFileById(String htmlFileId) {
        //获取文件对象
        GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(htmlFileId)));
        //打开下载流
        GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
        //定义GridFsResource
        GridFsResource gridFsResource = new GridFsResource(gridFSFile, gridFSDownloadStream);
        try {
            return gridFsResource.getInputStream();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    //根据页面id查询页面信息
    public CmsPage findCmsPageById(String pageId) {
        Optional<CmsPage> optional = cmsPageRepository.findById(pageId);
        return optional.orElse(null);
    }

    //根据站点id查询站点信息
    public CmsSite findCmsSiteById(String siteId) {
        Optional<CmsSite> optional = cmsSiteRepository.findById(siteId);
        return optional.orElse(null);
    }
}
```

#### 1.3.6 Consumer

在cms client工程的mq包下创建ConsumerPostPage类，ConsumerPostPage作为发布页面的消费客户端，监听页面发布队列的消息，收到消息后从mongodb下载文件，保存在本地。

```java
@Component
public class ConsumerPostPage {
    private static final Logger LOGGER = LoggerFactory.getLogger(ConsumerPostPage.class);

    @Autowired
    private PageService pageService;

    @RabbitListener(queues = {"${xuecheng.mq.queue}"})
    public void postPage(String message){
        //解析消息
        Map map = JSON.parseObject(message, Map.class);
        //得到页面id，JSON中定义的消息格式
        String pageId = (String) map.get("pageId");

        //校验该pageId是否不存在
        CmsPage cmsPage = pageService.findCmsPageById(pageId);
        if (cmsPage == null){
            LOGGER.error("receive postpage message,cmsPage is null,pageId:{}",pageId);
            return;
        }
        //调用service中方法，下载HTML文件到服务器
        pageService.savePageToServerPath(pageId);
    }
}
```

在RabbitMQ的web监控页面即可看到交换机和队列都创建好了，并且还有routingKey为站点id



利用swagger测试，可能需要修改站点和页面的物理地址（给的有问题），还需要启动Nginx，最后在最终路径看到页面即可



### 1.4 页面发布前端

用户操作流程：

1、用户进入cms页面列表。

2、点击“发布”请求服务端接口，发布页面。

3、提示“发布成功”，或发布失败。

#### 1.4.1 page

修改page_list.vue，添加发布按钮

```vue
<el-button size="small" type="primary" plain @click="postPage(page.row.pageId)">发布</el-button>
```

添加页面发布事件：

```js
postPage(pageId) {
    this.$confirm('确认发布该页面吗?', '提示', {})
        .then(() => {
        cmsApi.page_postPage(pageId).then((res) => {
            if (res.success) {
                console.log('发布页面id=' + pageId);
                this.$message.success('发布成功，请稍后查看结果');
            } else {
                this.$message.error('发布失败');
            }
        });
    }).catch(() => {});
}
```



#### 1.4.2 api

cms.js的api文件中添加如下

```js
//发布页面
export const page_postPage= id =>  http.requestPost(apiUrl+'/cms/page/postPage/'+id);
```

测试后会发现，在前端`D:\Code-Workspace\_Project\xcEdu\xcEduUI\xc-ui-pc-static-portal\include`中会出现生成的静态页面



### 1.5 思考

1、如果发布到服务器的页面内容不正确怎么办？

2、一个页面需要发布很多服务器，点击“发布”后如何知道详细的发布结果？

3、一个页面发布到多个服务器，其中有一个服务器发布失败时怎么办？

可以通过RPC模式来使用RabbitMQ？



## 2 课程管理

在线教育平台的课程信息相当于电商平台的商品。课程管理是后台管理功能中最重要的模块。本项目为教学机构提供课程管理功能，教学机构可以添加属于自己的课程，供学生在线学习。课程管理包括如下功能需求：

1、分类管理

2、新增课程

3、修改课程

4、预览课程

5、发布课程

用户的操作流程如下：

1、进入我的课程

2、点击“添加课程”，进入添加课程界面

3、输入课程基本信息，点击提交

4、课程基本信息提交成功，自动进入“管理课程”界面，点击“管理课程”也可以进入“管理课程”界面

> 课程计划功能采用全程教学，我的课程、新增课程、修改课程、课程营销四个功能采用实战方式。

## 3 课程计划功能

### 3.1 环境搭建

课程管理使用MySQL数据库，创建课程管理数据库：xc_course

导入课程管理服务工程：

* 课程管理服务使用MySQL数据库存储课程信息，持久层技术如下：
  * spring data jpa：用于表的基本CRUD（也可以继承另一个类实现复制查询）
  * mybatis：用于复杂的查询操作
  * druid：使用阿里巴巴提供的spring boot 整合druid包`druid-spring-boot-starter`管理连接池。

导入后端和前端工程即可，前端问题参考2.1中解决办法，后端测试两个数据库即可



### 3.2 需求分析

课程计划定义了课程的章节内容，学生通过课程计划进行在线学习。功能包括：添加课程计划、删除课程计划、修改课程计划等



### 3.3 课程教学计划查询

课程计划查询是将某个课程的课程计划内容完整的显示出来

#### 3.3.1 页面原型

本功能使用element-ui 的**tree组件**来完成

在course_plan.vue文件中添加tree组件的代码

```vue
<el‐tree
         :data="data"
         show‐checkbox
         node‐key="id"
         default‐expand‐all
         :expand‐on‐click‐node="false"
         :render‐content="renderContent">
</el‐tree>
```

```js
let id = 1000;
export default {
    data() {
        return {
            data : [{
                id: 1,
                label: '一级 1',
                children: [{
                    id: 4,
                    label: '二级 1‐1',
                    children: [{
                        id: 9,
                        label: '三级 1‐1‐1'
                    }, {
                        id: 10,
                        label: '三级 1‐1‐2'
                    }]
                }]
            }]
        }
    }
}
```

本组件用到了**JSX**语法

JSX 是Javascript和XML结合的一种格式，它是React的核心组成部分，JSX和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式。遇到 HTML 标签（以 < 开头），就用 HTML 规则解析；遇到代码块（以 { 开头？？？），就用 JavaScript 规则解析。

Webstorm设置如下：

* Javascript version 选择 React JSX （如果没有就选择JSX Harmony）。2018.3版自动就是这个设置
* HTML 类型文件中增加vue。2018.3版能解析，不用设置
  * preferences -> Editor -> File Types 中找到上边框中HTML 在下边加一个 *.vue
  * 如果已经在vue.js template 中已存在.vue 则把它改为.vue2（因为要在Html中添加.vue）

#### 3.3.2 API接口

数据模型：teachpaln表

模型类：课程计划为树型结构，由树根（课程）和树枝（章节）组成，为了保证系统的可扩展性，在系统设计时将课程计划设置为树型结构。

TeachplanNode继承了Teachplan，所以拥有Teachplan属性和自己的childrenList属性

```java
@Data
@Entity
@Table(name="teachplan")
@GenericGenerator(name = "jpa-uuid", strategy = "uuid")
public class Teachplan implements Serializable {
    private static final long serialVersionUID = -916357110051689485L;
    @Id
    @GeneratedValue(generator = "jpa-uuid")
    @Column(length = 32)
    private String id;
    private String pname;
    private String parentid;
    private String grade;
    private String ptype;
    private String description;
    private String courseid;
    private String status;
    private Integer orderby;
    private Double timelength;
    private String trylearn;
}
```

自定义模型类

```java
@Data
public class TeachplanNode extends Teachplan {

    List<TeachplanNode> children;
}
```

根据课程id查询课程的计划接口如下，在api工程创建course包，创建CourseControllerApi接口类并定义接口方法：

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {

    @ApiOperation("课程计划查询")
    TeachplanNode findTeachplanList(String courseId);
}
```



#### 3.3.3 课程管理服务

##### 1、Sql

采用外连接

```sql
SELECT
	a.id one_id,
	a.pname one_pname,
	b.id two_id,
	b.pname two_pname,
	c.id three_id,
	c.pname three_pname 
FROM
	teachplan a
	LEFT JOIN teachplan b ON a.id = b.parentid
	LEFT JOIN teachplan c ON b.id = c.parentid 
WHERE
	a.parentid = '0' 
	AND a.courseid = '4028e581617f945f01617f9dabc40000' 
ORDER BY
	a.orderby,
	b.orderby,
	c.orderby
```

##### 2、Dao 

```java
@Repository//不加这个注解也行，只是会在测试时提示找不到bean，但运行时不会有此问题
@Mapper
public interface TeachplanMapper {

    //课程计划查询
    TeachplanNode selectList(String courseId);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.xuecheng.manage_course.dao.TeachplanMapper">

    <!--课程计划查询，可以不用设置parameterType，会根据接口自动补-->
    <select id="selectList" parameterType="java.lang.String" resultMap="teachplanMap">
        SELECT a.id    one_id,
               a.pname one_pname,
               b.id    two_id,
               b.pname two_pname,
               c.id    three_id,
               c.pname three_pname
        FROM teachplan a
                 LEFT JOIN teachplan b ON a.id = b.parentid
                 LEFT JOIN teachplan c ON b.id = c.parentid
        WHERE a.parentid = '0'
          <if test="_parameter!=null and _parameter !='' ">
              AND a.courseid = #{courseId}/*courseId变量名随便起*/
          </if>
        ORDER BY a.orderby,
                 b.orderby,
                 c.orderby
    </select>

    <!--三层树结构-->
    <resultMap id="teachplanMap" type="com.xuecheng.framework.domain.course.ext.TeachplanNode">
        <id property="id" column="one_id" />
        <result property="pname" column="one_pname" />
        <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
            <id property="id" column="two_id"/>
            <result property="pname" column="two_pname"/>
            <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
                <id property="id" column="three_id"/>
                <result property="pname" column="three_pname"/>
            </collection>
        </collection>
    </resultMap>
</mapper>
```



##### 3、Service

```java
@Service
public class CourseService {

    @Autowired
    private TeachplanMapper teachplanMapper;

    //课程计划查询
    public TeachplanNode findTeachplanList(String courseId){
        return teachplanMapper.selectList(courseId);
    }
}
```



##### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Autowired
    private CourseService courseService;

    @Override
    @GetMapping("/teachplan/list/{courseId}")
    public TeachplanNode findTeachplanList(@PathVariable String courseId) {
        return courseService.findTeachplanList(courseId);
    }
}
```



利用swagger测试（配置类在api工程中）



### 3.4 添加课程教学计划

用户操作流程：

1、进入课程计划页面，点击“添加课程计划”

2、打开添加课程计划页面，输入课程计划信息

上级结点说明：

不选择上级结点表示**当前课程计划**为该课程的一级结点。当添加该课程在课程计划中还**没有节点**时要**自动添加课程的根结点**。

后端查看3.3中代码



#### 3.4.1 API接口

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    /*......省略了3.3.2中api接口*/
    @ApiOperation("添加教学计划")
    ResponseResult addTeachplan(Teachplan teachplan);
}
```



#### 3.4.2 课程管理服务

##### 1、Dao

```java
@Repository//这个只是为了test测试时防止报错，可以删掉！
@Mapper
public interface TeachplanRepository extends JpaRepository<Teachplan,String> {

    //定义方法根据课程id和父结点id查询出结点列表，可以使用此方法实现查询根结点
    List<Teachplan> findByCourseidAndParentid(String courseId,String parentId);
}
```

##### 2、Service

```java
@Service
public class CourseService {
    @Autowired
    private TeachplanRepository teachplanRepository;

    @Autowired
    private CourseBaseRepository courseBaseRepository;

    /*省略了3.3中代码*/

    //添加课程教学计划
    @Transactional
    public ResponseResult addTeachplan(Teachplan teachplan) {
        if (teachplan == null || StringUtils.isEmpty(teachplan.getCourseid()) || StringUtils.isEmpty(teachplan.getPname())) {
            ExceptionCast.cast(CommonCode.INVALID_PARAM);
        }
        //课程id
        String courseid = teachplan.getCourseid();
        //页面传入的parentId
        String parentid = teachplan.getParentid();
        if (StringUtils.isEmpty(parentid)) {
            //若父节点为空，则获取该课程的根节点id（不是parentId）
            parentid = this.getTeachplanRoot(courseid);
        }
        //新节点，不用new直接使用也行
        Teachplan teachplanNew = new Teachplan();
        BeanUtils.copyProperties(teachplan, teachplanNew);//BeanUtils方法赋值
        teachplanNew.setParentid(parentid);//设置父结点
        teachplanNew.setCourseid(courseid);//设置课程id
        //根据父结点级别设置新节点的级别（这个参数parentId其实是根节点的id，不是字面意思！）
        Optional<Teachplan> optional = teachplanRepository.findById(parentid);
        if (!optional.isPresent()) {
            ExceptionCast.cast(CommonCode.INVALID_PARAM);
        }
        Teachplan parentNode = optional.get();
        if ("1".equals(parentNode.getGrade())) {
            teachplanNew.setGrade("2");
        } else {
            teachplanNew.setGrade("3");
        }
        teachplanRepository.save(teachplanNew);
        return new ResponseResult(CommonCode.SUCCESS);

    }

    //取出该课程的根节点id，若查询不到需要自动添加根节点（保存时自动生成）
    private String getTeachplanRoot(String courseId) {
        //取出课程信息
        Optional<CourseBase> optional = courseBaseRepository.findById(courseId);
        if (!optional.isPresent()) {
            return null;
        }
        CourseBase courseBase = optional.get();
        //查询课程的根节点。其实传入courseId后最多只有一个符合
        List<Teachplan> teachplanList = teachplanRepository.findByCourseidAndParentid(courseId, "0");
        if (teachplanList == null || teachplanList.size() <= 0) {
            Teachplan teachplan = new Teachplan();
            teachplan.setParentid("0");
            teachplan.setPname(courseBase.getName());
            teachplan.setParentid("0");
            teachplan.setGrade("1");//1级
            teachplan.setStatus("0");//未发布
            teachplanRepository.save(teachplan);
            return teachplan.getId();

        }
        return teachplanList.get(0).getId();
    }
}
```

##### 3、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Autowired
    private CourseService courseService;
    
    /*省略了3.3中代码*/

    @Override
    @PostMapping("/teachplan/add")
    public ResponseResult addTeachplan(@RequestBody Teachplan teachplan) {
        return courseService.addTeachplan(teachplan);
    }
}
```

swagger测试

#### 3.4.3 前端

##### 1、Api

```js
/*添加课程计划*/
export const addTeachplan = teachplah => http.requestPost(apiUrl+'/course/teachplan/add',teachplah);
```

##### 2、page

```js
//提交课程计划
addTeachplan(){
    //校验表单
    this.$refs.teachplanForm.validate((valid) => {
        if (valid) {
            //调用api方法
            //将课程id设置到teachplanActive
            this.teachplanActive.courseid = this.courseid
            courseApi.addTeachplan(this.teachplanActive).then(res=>{
                if(res.success){
                    this.$message.success("添加成功")
                    //刷新树
                    this.findTeachplan()
                }else{
                    this.$message.error(res.message)
                }

            })
        }
    })
}
```

添加课程计划采用弹出窗口组件**Dialog**。利用`:visible.sync="teachplayFormVisible"`实现打开关闭弹窗效果





### 3.5 我的课程（自己实现）

课程添加完成后可通过我的课程进入课程修改页面，此页面显示我的课程列表，如下图所示，可分页查询（图片暂不显示）。要实现分页、会存在多表关联查询，所以建议使用mybatis实现



#### 1、API

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    /*省略其他方法*/
    @ApiOperation("查询我的课程列表")
    QueryResponseResult findCourseList(int page,int size,CourseListRequest courseListRequest);
    
    
}
```

#### 2、Dao

返回的pojo中已经包括了另一张表的属性，并且不是pojo对象，可以不用写resultMap映射

```java
@Mapper
public interface CourseMapper {
    /*省略其他方法*/
    Page<CourseInfo> findCourseListPage(CourseListRequest courseListRequest);
}
```

```xml
<mapper namespace="com.xuecheng.manage_course.dao.CourseMapper">
    <select id="findCourseListPage" resultType="com.xuecheng.framework.domain.course.ext.CourseInfo">
        select b.*,p.pic
        from course_base b
        left join course_pic p on b.id = p.courseid
    </select>
</mapper>
```



#### 3、Service

```java
@Service
public class CourseService {
    /*省略其他方法*/
    public QueryResponseResult findCourseList(int page, int size, CourseListRequest courseListRequest){
        if (courseListRequest == null){
            courseListRequest = new CourseListRequest();
        }
        if (page<=0){
            page = 1;
        }
        if (size<=0){
            size = 10;
        }
        //分页参数，及Page对象。也可以使用PageInfo，但是需要构造
        PageHelper.startPage(page,size);
        Page<CourseInfo> courseListPage = courseMapper.findCourseListPage(courseListRequest);

        //返回值封装
        QueryResult<CourseInfo> queryResult = new QueryResult<>();
        queryResult.setList(courseListPage);
        queryResult.setTotal(courseListPage.getTotal());

        return new QueryResponseResult(CommonCode.SUCCESS,queryResult);
    }
}
```



#### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @GetMapping("/coursebase/list/{page}/{size}")
    public QueryResponseResult findCourseList(@PathVariable int page, @PathVariable int size, CourseListRequest courseListRequest) {
        return courseService.findCourseList(page,size,courseListRequest);
    }
}
```



#### 5、前端

我的课程列表使用element 的card组件。



### 3.6 新增课程

用户操作流程如下：

1、用户进入“我的课程”页面，点击“新增课程”，进入新增课程页面

2、填写课程信息，选择课程分类、课程等级、学习模式等

3、信息填写完毕，点击“提交”，课程添加成功或课程添加失败并提示失败原因

需要解决的是在新增页面上输入的信息：

1、**课程分类**。多级分类，需要方便用户去选择。**category表，一对多，3级**，但1级没用

2、**课程等级、学习模式**等这些选项建议是可以**配置**的。（利用MongoDB）



课程分类返回的数据实体类

```java
@Data
@Entity
@Table(name="category")
@GenericGenerator(name = "jpa-assigned", strategy = "assigned")
//@GenericGenerator(name = "jpa-uuid", strategy = "uuid")
public class Category implements Serializable {
    private static final long serialVersionUID = -906357110051689484L;
    @Id
    @GeneratedValue(generator = "jpa-assigned")
    @Column(length = 32)
    private String id;
    private String name;
    private String label;
    private String parentid;
    private String isshow;
    private Integer orderby;
    private String isleaf;

}
```

```java
@Data
public class CategoryNode extends Category {

    List<CategoryNode> children;
}
```



#### 3.6.1 课程分类

##### 1、API

```java
@Api(value = "课程分类管理",description = "课程分类管理",tags = {"课程分类管理"})
public interface CategoryControllerApi {

    @ApiOperation("查询分类")
    public CategoryNode findList();
}
```



##### 2、Dao

```java
@Mapper
public interface CategoryMapper {

    CategoryNode findList();
}
```

```java
<mapper namespace="com.xuecheng.manage_course.dao.CategoryMapper">
    <select id="findList" resultMap="CategoryNodeMap">
        SELECT
            a.id one_id,
            a.NAME one_name,
            a.label one_label,
            a.isshow one_isshow,
            a.isleaf one_isleaf,
            a.orderby one_orderby,
            a.parentid one_parentid,
            b.id two_id,
            b.NAME two_name,
            b.label two_label,
            b.isshow two_isshow,
            b.isleaf two_isleaf,
            b.orderby two_orderby,
            b.parentid two_parentid,
            c.id three_id,
            c.NAME three_name,
            c.label three_label,
            c.isshow three_isshow,
            c.isleaf three_isleaf,
            c.orderby three_orderby,
            c.parentid three_parentid
        FROM
            category a
                LEFT JOIN category b ON a.id = b.parentid
                LEFT JOIN category c ON b.id = c.parentid
        WHERE
            a.parentid = '0'
        ORDER BY
            a.orderby,
            b.orderby,
            c.orderby
    </select>
    <resultMap id="CategoryNodeMap" type="com.xuecheng.framework.domain.course.ext.CategoryNode">
        <id property="id" column="one_id"/>
        <result property="name" column="one_name"/>
        <result property="label" column="one_label"/>
        <result property="isshow" column="one_isshow"/>
        <result property="isleaf" column="one_isleaf"/>
        <result property="orderby" column="one_orderby"/>
        <result property="parentid" column="one_parentid"/>
        <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.CategoryNode">
            <id property="id" column="two_id"/>
            <result property="name" column="two_name"/>
            <result property="label" column="two_label"/>
            <result property="isshow" column="two_isshow"/>
            <result property="isleaf" column="two_isleaf"/>
            <result property="orderby" column="two_orderby"/>
            <result property="parentid" column="two_parentid"/>
            <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.CategoryNode">
                <id property="id" column="three_id"/>
                <result property="name" column="three_name"/>
                <result property="label" column="three_label"/>
                <result property="isshow" column="three_isshow"/>
                <result property="isleaf" column="three_isleaf"/>
                <result property="orderby" column="three_orderby"/>
                <result property="parentid" column="three_parentid"/>
            </collection>
        </collection>
    </resultMap>
</mapper>
```



##### 3、Service

```java
@Service
public class CategoryService {
    @Autowired
    private CategoryMapper categoryMapper;

    public CategoryNode findList(){
        return categoryMapper.findList();
    }
}
```



##### 4、Controller

```java
@RestController
@RequestMapping("/category")
public class CategoryController {

    @Autowired
    private CategoryService categoryService;

    @GetMapping("/list")
    public CategoryNode findList(){
        return categoryService.findList();
    }
}
```



##### 5、前端

采用element UI的Cascader级联选择器

用户选择课程分类后，所选分类ID绑定到categoryActive（数组）中，选择了一级、二级分类，分别存储在categoryActive数组的第一个、第二个元素中。



#### 3.6.2 课程等级、学习模式

在新增课程界面需要选择课程等级、课程状态等，这些信息统一采用**数据字典管理**的方式。

数据字典对系统的业务分类进行统一管理，并且也可以解决硬编码问题，比如添加课程时选择课程等级，下拉框中的课程等级信息如果在页面硬编码将造成不易修改维护的问题，所以从数据字典表中获取，如果要修改名称则在数据字典修改即可，提高系统的可维护性。

##### 1、数据模型

在mongodb中创建数据字典表sys_dictionary，内容如下：

```json
{
    "_id" : ObjectId("5a7e8d2dd019f15418fa2b71"),
    "d_name" : "课程等级", //字典名称
    "d_type" : "200", //字典分类
    "d_value" : [ //字典数据
        {
            "sd_name" : "低级", //项目名称
            "sd_id" : "200001", //项目id
            "sd_status" : "1" //项目状态（1：可用，0不可用）
        },
        {
            "sd_name" : "中级",
            "sd_id" : "200002",
            "sd_status" : "1"
        },
        {
            "sd_name" : "高级",
            "sd_id" : "200003",
            "sd_status" : "1"
        }
    ]
}
```

数据模型类

```java
@Data
@Document(collection = "sys_dictionary")
public class SysDictionary {

    @Id
    private String id;

    @Field("d_name")
    private String dName;

    @Field("d_type")
    private String dType;

    @Field("d_value")
    private List<SysDictionaryValue> dValue;
}
```

```java
@Data
public class SysDictionaryValue {

    @Field("sd_id")
    private String sdId;

    @Field("sd_name")
    private String sdName;

    @Field("sd_status")
    private String sdStatus;
}
```

##### 2、API

可以其他微服务远程调用！

```java
@Api(value = "数据字典接口",description = "提供数据字典接口的管理、查询功能")
public interface SysDictionaryControllerApi {

    //数据字典
    @ApiOperation(value="数据字典查询接口")
    SysDictionary getByType(String type);
}
```

##### 3、Dao

> 之后的都在cms微服务中创建

```java
public interface SysDictionaryRepository extends MongoRepository<SysDictionary,String> {

    //根据字典分类查询字典信息
    SysDictionary findByDType(String dType);
}
```

##### 4、Service

```java
@Service
public class CmsDictionaryService {

    @Autowired
    private SysDictionaryRepository sysDictionaryRepository;

    //根据字典分类type查询字典信息
    public SysDictionary findByDType(String type){
        return sysDictionaryRepository.findByDType(type);
    }
}
```

##### 5、Controller

```java
@RestController
@RequestMapping("/sys/dictionary")
public class CmsDictionaryController implements SysDictionaryControllerApi {

    @Autowired
    private CmsDictionaryService cmsDictionaryService;

    @Override
    @GetMapping("/get/{type}")
    public SysDictionary getByType(@PathVariable String type) {
        return cmsDictionaryService.findByDType(type);
    }
}
```



##### 6、前端

采用element UI的el-radio

#### 3.6.3 新增课程

##### 1、API

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
	/*省略其他方法*/

    @ApiOperation("添加课程基础信息")
    AddCourseResult addCourse(CourseBase courseBase);
}
```

##### 2、Dao

```java
public interface CourseBaseRepository extends JpaRepository<CourseBase,String> {
}
```

##### 3、Service

```java
@Service
public class CourseService {
    @Transactional
    public AddCourseResult addCourse(CourseBase courseBase){
        courseBase.setStatus("200201");
        CourseBase base = courseBaseRepository.save(courseBase);
        return new AddCourseResult(CommonCode.SUCCESS,base.getId());//并不能获取到添加后的id
    }
}
```

##### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi { 
    @Override
    @PostMapping("/coursebase/add")
    public AddCourseResult addCourse(@RequestBody CourseBase courseBase) {
        return courseService.addCourse(courseBase);
    }
}
```



### 3.7 课程信息修改

课程添加成功进入课程管理页面，通过课程管理页面修改课程的基本信息、编辑课程图片、编辑课程营销信息等。

导航效果使用Element-UI的NavMenu组件实现

#### 1、Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {

    @ApiOperation("根据课程id查询课程")
    CourseBase getCourseBaseById(String courseId);

    @ApiOperation("根据课程id修改或添加课程")
    ResponseResult updateCourseBase(String courseId,CourseBase courseBase);
}
```



#### 2、Dao

```java
public interface CourseBaseRepository extends JpaRepository<CourseBase,String> {
}
```



#### 3、Service

```java
@Service
public class CourseService {
    public CourseBase getCourseBaseById(String courseId){
        Optional<CourseBase> optional = courseBaseRepository.findById(courseId);
        return optional.orElse(null);
    }

    @Transactional
    public ResponseResult updateCourseBase(String courseId,CourseBase courseBase){
        CourseBase newCourseBase = this.getCourseBaseById(courseId);
        //不存在
        if (newCourseBase == null){
            newCourseBase = new CourseBase();
        }

        BeanUtils.copyProperties(courseBase,newCourseBase);
        courseBaseRepository.save(newCourseBase);
        return new ResponseResult(CommonCode.SUCCESS);

    }
}
```



#### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {   
    @Override
    @GetMapping("/coursebase/get/{courseId}")
    public CourseBase getCourseBaseById(@PathVariable String courseId) {
        return courseService.getCourseBaseById(courseId);
    }

    @Override
    @PutMapping("/coursebase/update/{courseId}")
    public ResponseResult updateCourseBase(@PathVariable String courseId, @RequestBody CourseBase courseBase) {
        return courseService.updateCourseBase(courseId,courseBase);
    }
}
```



### 3.8 课程营销

课程营销信息包括课程价格、课程有效期等信息。

课程营销信息使用course_market表存储，数据模型如下：

```java
@Data
@Entity
@Table(name="course_market")
@GenericGenerator(name = "jpa-assigned", strategy = "assigned")
public class CourseMarket implements Serializable {
    private static final long serialVersionUID = -916357110051689486L;
    @Id
    @GeneratedValue(generator = "jpa-assigned")
    @Column(length = 32)
    private String id;
    private String charge;
    private String valid;
    private String qq;
    private Float price;
    private Float price_old;
    //private Date expires;
    @Column(name = "start_time")
    private Date startTime;
    @Column(name = "end_time")
    private Date endTime;
}
```



#### 1、Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {   
    @ApiOperation("根据课程id获取课程营销信息")
    CourseMarket getCourseMarketById(String courseId);

    @ApiOperation("根据课程id更新课程营销信息")
    ResponseResult updateCourseMarket(String courseId,CourseBase courseBase);
}
```



#### 2、Dao

```java
public interface CourseMarketRepository extends JpaRepository<CourseMarket,String> {
}
```



#### 3、Service

```java
@Service
public class CourseMarketService {

    @Autowired
    private CourseMarketRepository courseMarketRepository;

    public CourseMarket getCourseMarketById(String courseId){
        Optional<CourseMarket> optional = courseMarketRepository.findById(courseId);
        return optional.orElse(null);
    }


    public ResponseResult updateCourseMarket(String courseId,CourseMarket courseMarket){
        CourseMarket newCourseMarket = this.getCourseMarketById(courseId);
        //有则更新，无则添加
        if (newCourseMarket == null){
            newCourseMarket = new CourseMarket();
        }
        BeanUtils.copyProperties(courseMarket,newCourseMarket);
        courseMarketRepository.save(newCourseMarket);
        return new ResponseResult(CommonCode.SUCCESS);
    }
}
```



#### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @GetMapping("/coursemarket/get/{courseId}")
    public CourseMarket getCourseMarketById(@PathVariable String courseId) {
        return courseMarketService.getCourseMarketById(courseId);
    }

    @Override
    @PutMapping("/coursemarket/update/{courseId}")
    public ResponseResult updateCourseMarket(@PathVariable String courseId, @RequestBody CourseMarket courseMarket) {
        return courseMarketService.updateCourseMarket(courseId,courseMarket);
    }
}
```



# 8 课程图片管理—FastDFS

## 1 分布式文件系统

### 1.1 简介

**文件系统**：负责**管理和存储**文件的系统软件，它是操作系统和硬件驱动之间的桥梁，操作系统通过文件系统提供的接口去存取文件，用户通过操作系统访问磁盘上的文件。常见的文件系统：FAT16/FAT32、NTFS、HFS、UFS、APFS、XFS、Ext4等

**分布式文件系统**：将多个地点的文件系统通过**网络连接**起来，组成一个文件系统网络，结点之间通过网络进行通信，一台文件系统的存储和传输能力有限，我们让文件在多台计算机上存储，通过多台计算共同传输。==解决了海量文件**存储**及**传输访问**的瓶颈问题，对海量视频的管理、对海量图片的管理等。==

分布式文件系统**好处**：

* 一台计算机的文件系统处理能力扩充到**多台计算机同时处理**。
* 一台计算机挂了还有另外**副本**计算机提供数据。
* 每台计算机可以放在不同的地域，这样用户就可以**就近访问**，提高访问速度。



### 1.2 主流的分布式文件系统

* NFS，网络文件系统

  1）在客户端上映射NFS服务器的驱动器。

  2）客户端通过网络访问NFS服务器的硬盘完全透明。

* GFS（GoogleFS），是可扩展的分布式文件系统

  ![1551251705300](images/1551251705300.png)

  1）GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver组成。

  2）master存储了数据文件的元数据，一个文件被分成了若干**块**存储在多个chunkserver中。

  3）用户从master中获取数据元信息，从chunkserver存储数据。

* HDSF（Hadoop分布式文件系统），大数据中用的多

  ![1551251822644](images/1551251822644.png)

  1）HDFS采用主从结构，一个HDFS集群由一个名称结点和若干数据结点组成。名称结点存储数据的元信息，一个完整的数据文件分成若干块存储在数据结点。

  2）客户端从名称结点获取数据的元信息及数据分块的信息，得到信息客户端即可从数据块来存取数据。

  

  ### 1.3 分布式文件服务提供商

  * 阿里的OSS
  * 七牛云存储
  * 百度云存储

  

  

  

## 2 FastDFS

### 2.1 FastDFS工作原理

FastDFS是用 C 语言编写的一款开源的分布式文件系统，它是由淘宝资深架构师余庆编写并开源。FastDFS**专为互联网量身定制**，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。为什么要使用FastDFS呢？

上边介绍的NFS、GFS都是通用的分布式文件系统，通用的分布式文件系统的优点的是开发体验好，但是系统复杂性高、性能一般，而专用的分布式文件系统虽然开发体验性差，但是系统复杂性低并且性能高。FastDFS非常**适合存储图片等那些小文件**，FastDFS**不对文件进行分块**，所以它就没有分块合并的开销，fastDFS网络通信采用Socket，通信速度很快。

#### 2.1.1 FastDFS架构

FastDFS架构包括 Tracker server和Storage server。客户端请求Tracker server进行文件上传、下载，通过Tracker server调度最终由Storage server完成文件上传和下载。

最简单的 FastDFS 架构：6个服务器，其中2个Tracker、2个卷，每个卷中有2个Storager

![1551252781712](images/1551252781712.png)

* **Tracker**

  Tracker作用是**负载均衡和调度**，通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将Tracker 称为追踪服务器或调度服务器。

  FastDFS集群中的Tracker server可以有多台，Tracker server之间是相互平等关系同时提供服务，不存在单点故障。客户端请求Tracker server采用轮询方式，如果请求的Tracker 无法提供服务则换另一个Tracker。

* **Storage**

  Storage Server作用是**文件存储**，客户端上传的文件最终存储在Storage服务器上，Storage server没有实现自己的文件系统而是使用操作系统的文件系统来管理文件。可以将Storage称为存储服务器。

  Storage集群采用了分组存储方式。storage集群由一个或多个组（卷）构成，集群存储总容量为集群中所有组（卷）的存储容量之和。一个组（卷）由一台或多台存储服务器组成，组（卷）内的Storage server之间是平等关系，不同组（卷）的Storage server之间不会相互通信，同组（卷）内的Storage server之间会相互连接进行文件同步，从而保证同组（卷）内每个storage上的文件完全一致的。一个组（卷）的存储容量为该组（卷）内的存储服务器容量最小的那个，由此可见组（卷）内存储服务器的软硬件配置最好是一致的。

  采用分组（卷）存储方式的好处是灵活、可控性较强。比如上传文件时，可以由客户端直接指定上传到的组（卷）也可以由Tracker进行调度选择。一个分组（卷）的存储服务器访问压力较大时，可以在该组（卷）增加存储服务器来扩充服务能力（纵向扩容）。当系统容量不足时，可以增加组（卷）来扩充存储容量（横向扩容）。

* Storage**状态收集**

  Storage server会连接集群中所有的Tracker server，定时向他们报告自己的状态，包括磁盘剩余空间、文件同步状况、文件上传下载次数等统计信息。



#### 2.1.2 文件上传流程

![1551253620048](images/1551253620048.png)

客户端上传文件后存储服务器将**文件ID**返回给客户端，此文件ID**用于以后访问该文件的索引信息**。文件索引信息包括：**组名**，**虚拟磁盘路径**，**数据两级目录**，**文件名**。

![1551253731023](images/1551253731023.png)

* **组名**：文件上传后所在的storage组名称，在文件上传成功后由storage服务器返回，需要客户端自行保存。
* **虚拟磁盘路径**：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推。
* **数据两级目录**：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。
* **文件名**：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。



#### 2.1.3 文件下载流程

![1551253837704](images/1551253837704.png)

Tracker根据请求的文件路径即文件ID 来快速定义文件。比如请求下边的文件：

![1551253865754](images/1551253731023.png)

1. 通过组名Tracker能够很快的定位到客户端需要访问的存储服务器组是group1，并选择合适的存储服务器提供客户端访问。
2. 存储服务器根据“文件存储虚拟磁盘路径”和“数据文件两级目录”可以很快定位到文件所在目录，并根据文件名找到客户端需要访问的文件。

### 2.2 FastDFS入门

#### 2.2.1 FastDFS安装与配置

> 使用品优购的虚拟机，或自己安装，使用之前安装的Ubuntu18，但是Tracker可以正常启动，Storage GG了...

1. 启动`VMware NAT Service`服务！

2. 修改本机网络连接中VMnet8网卡（为NAT模式的网卡）的**IP地址**为101网段如`192.168.101.1`，子网掩码`255.255.255.0`

3. 修改虚拟机网络配置如VMnet8（NAT模式）的**子网IP**为`192.168.101.0`

4. DHCP配置开始IP为128，结束为254（默认就是这样）

5. FastDFS--tracker安装（分别安装两台，初次使用可以只安装一台）

   1. tracker和storage使用相同的安装包，[下载地址](https://github.com/happyfish100/FastDFS)。本教程下载：FastDFS_v5.05.tar.gz

   2. 安装FastDFS需要先将官网下载的源码进行编译，编译依赖gcc环境。Ubuntu18自带

   3. FastDFS依赖libevent库，`sudo apt-get install libevent-dev`

   4. 安装libfastcommon，包含了FastDFS运行所需要的一些基础库

      1. 将libfastcommonV1.0.7.tar.gz拷贝至/usr/local/下
      2. cd /usr/local
      3. tar -zxvf libfastcommonV1.0.7.tar.gz
      4. cd libfastcommon-1.0.7
      5. ./make.sh
      6. ./make.sh install
      7. libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib下。或者软连接（网上找）

   5. Tracker编译安装

      1. 将FastDFS_v5.05.tar.gz拷贝至/usr/local/下
      2. tar -zxvf FastDFS_v5.05.tar.gz
      3. cd FastDFS
      4. ./make.sh 编译
      5. ./make.sh install 安装
      6. 安装成功将安装目录下的conf下的文件拷贝到/etc/fdfs/下

   6. 配置

      1. 进入/etc/fdfs目录

      2. 拷贝一份新的tracker配置文件：cp tracker.conf.sample tracker.conf

      3. 修改tracker.conf的配置

         1. 端口：`port=22122`

         2. Tracker 基础目录：`base_path=/home/fastdfs`，tracker在运行时会向此目录存储storage的管理数据

            > 没有/home/fastdfs这个目录需要手动创建！后面的配置也是

         3. 存储策略：store_lookup=取值范围：0（轮询向storage存储文件）、1（指定具体的group）、2负载均衡，选择空闲的storage存储指定具体的group：store_group= 如果store_lookup设置为1则这里必须指定一个具体的group。

      4. 修改storage.conf的配置（实际应该在另一台机器中）

         1. 端口：`port=23000`

         2. Storage基础目录：`base_path=/home/fastdfs`

         3. 组名：`group_name=group1`

         4. 向Tracker心跳间隔（秒）：`heart_beat_interval=30`

         5. 磁盘存储目录，可定义多个store_path：`store_path0=/home/fastdfs/fdfs_storage `

            此目录下存储上传的文件在`/home/fastdfs/fdfs_storage/data`下

         6. 上报tracker的地址：`tracker_server=192.168.101.64:22122`，如果有多个tracker则配置多个tracker

   7. 启动停止

      1. fastDFS启动/停止脚本目录：

         1. fdfs_trackerd：tracker脚本，通过此脚本对 tracker进行启动和停止

            `/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart`

         2. fdfs_storaged：storage脚本，通过此脚本对 storage进行启动和停止

            `/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart`



#### 2.2.2 文件上传下载测试

这里我们使用javaApi测试文件的上传，java版本的[fastdfs-client地址](https://github.com/happyfish100/fastdfs-client-java)，参考此工程编写测试用例。

1. Maven依赖

   ```xml
   <!-- https://mvnrepository.com/artifact/net.oschina.zcx7878/fastdfs-client-java -->
   <dependency>
       <groupId>net.oschina.zcx7878</groupId>
       <artifactId>fastdfs-client-java</artifactId>
       <version>1.27.0.0</version>
   </dependency>
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-test</artifactId>
       <scope>test</scope>
   </dependency>
   <dependency>
       <groupId>org.apache.commons</groupId>
       <artifactId>commons-io</artifactId>
       <version>1.3.2</version>
   </dependency>
   ```

2. 在classpath:config下创建`fastdfs-client.properties`配置文件

   ```properties
   #http连接超时时间
   fastdfs.connect_timeout_in_seconds = 5
   #tracker与storage网络通信超时时间
   fastdfs.network_timeout_in_seconds = 30
   #字符编码
   fastdfs.charset = UTF-8
   #tracker服务器地址，多个地址中间用英文逗号分隔
   fastdfs.tracker_servers = 192.168.25.133:22122
   ```

3. 文件上传

   ```java
   //加载fastdfs-client.properties配置文件
   ClientGlobal.initByProperties("config/fastdfs-client.properties");
   //定义TrackerClient，用于请求TrackerServer
   TrackerClient trackerClient = new TrackerClient();
   //连接tracker
   TrackerServer trackerServer = trackerClient.getConnection();
   //获取Stroage
   StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
   //创建stroageClient
   StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer);
   
   //向stroage服务器上传文件
   String filePath = "D:/dog.jpg";//本地文件的路径
   String fileId = storageClient1.upload_file1(filePath, "jpg", null);//上传成功后拿到文件Id
   System.out.println(fileId);//group1/M00/00/00/wKgZhVx2q6yARolJAAGgU0NHZ6E212.jpg
   ```

   根据文件ID，M00为虚拟路径，是配置文件中的`store_path0=/home/fastdfs/fdfs_storage`，此目录下存储上传的文件在`/home/fastdfs/fdfs_storage/data`下，在该目录利用`ll /00/00/wKgZhVx2q6yARolJAAGgU0NHZ6E212.jpg`即可找到

4. 文件下载

   ```java
   //加载fastdfs-client.properties配置文件
   ClientGlobal.initByProperties("config/fastdfs-client.properties");
   //定义TrackerClient，用于请求TrackerServer
   TrackerClient trackerClient = new TrackerClient();
   //连接tracker
   TrackerServer trackerServer = trackerClient.getConnection();
   //获取Stroage
   StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
   //创建stroageClient
   StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer);
   
   //下载文件
   byte[] bytes = storageClient1.download_file1("group1/M00/00/00/wKgZhVx2q6yARolJAAGgU0NHZ6E212.jpg");
   IOUtils.write(bytes,new FileOutputStream("D:/cat.jpg"));//C盘有权限问题，不能存放
   ```

5. 文件查询

   ```java
   //加载fastdfs-client.properties配置文件
   ClientGlobal.initByProperties("config/fastdfs-client.properties");
   //定义TrackerClient，用于请求TrackerServer
   TrackerClient trackerClient = new TrackerClient();
   //连接tracker
   TrackerServer trackerServer = trackerClient.getConnection();
   //获取Stroage
   StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
   //创建stroageClient
   StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer);
   
   FileInfo fileInfo = storageClient.query_file_info("group1","M00/00/01/wKhlQFrKBSOAW5AWAALcAg10vf4862.png");
   System.out.println(fileInfo);
   //source_ip_addr = 192.168.25.133, file_size = 106579, create_timestamp = 2019-02-27 23:24:28, crc32 = 1128753057
   ```



#### 2.2.3 在Storage搭建图片虚拟主机

在 Storage server 上安装 nginx 的目的是**对外通过 http 访问 storage server 上的文件**。使用 nginx 的模块**FastDFS-nginx-module** 的作用是通过 http 方式访问 storage 中的文件，当 storage 本机**没有要找的文件时向源storage 主机代理请求文件**。

在storage上安装nginx（安装**FastDFS-nginx-module模块**，没安装，上面的失败了，这边暂时不自己做）

1. 将FastDFS-nginx-module_v1.16.tar.gz传至FastDFS的storage服务器的/usr/local/下

2. cd /usr/local

3. tar -zxvf FastDFS-nginx-module_v1.16.tar.gz

4. cd FastDFS-nginx-module/src

5. 修改config文件将/usr/local/路径改为/usr/（在CORE_INCS和CORE_LIBS）

6. 将FastDFS-nginx-module/src下的mod_FastDFS.conf拷贝至/etc/fdfs/下

7. cp mod_FastDFS.conf /etc/fdfs/

8. 修改mod_FastDFS.conf的内容：

   1. base_path=/home/FastDFS
   2. tracker_server=192.168.101.3:22122
   3. tracker_server=192.168.101.4:22122（有几台配置几台）
   4. url_have_group_name=true，url中包含group名称
   5. store_path0=/home/fastdfs/fdfs_storage，指定文件存储路径，有多个配置多个
   6. cp /usr/lib64/libfdfsclient.so /usr/lib/，将libfdfsclient.so拷贝至/usr/lib下（好像软连接过了）
   7. mkdir -p /var/temp/nginx/client，创建nginx/client目录

9. nginx安装

   1. 将nginx-1.8.0.tar.gz拷贝到/usr/local下

   2. 解压nginx-1.8.0.tar.gz

   3. 进入nginx-1.8.0目录，执行如下配置命令（最后一行表示添加FastDFS-nginx-module模块）：

      ```
      ./configure \ 
      --prefix=/usr/local/nginx \ 
      --pid-path=/var/run/nginx/nginx.pid \
      --lock-path=/var/lock/nginx.lock \ 
      --error-log-path=/var/log/nginx/error.log \ 
      --http-log-path=/var/log/nginx/access.log \ 
      --with-http_gzip_static_module \ 
      --http-client-body-temp-path=/var/temp/nginx/client \ 
      --http-proxy-temp-path=/var/temp/nginx/proxy \ 
      --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \ 
      --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \ 
      --http-scgi-temp-path=/var/temp/nginx/scgi \ 
      --add-module=/usr/local/FastDFS-nginx-module/src
      ```

   4. make

   5. make install

   6. nginx配置文件

      新建一个nginx配置文件nginx-fdfs.conf，添加虚拟主机

      ```
      server { 
      	listen 80;
      	server_name 192.168.101.65;
      	
      	location /group1/M00/{ 
      		root /home/FastDFS/fdfs_storage/data; 
      		ngx_FastDFS_module; 
          }
      }
      ```

      server_name指定本机ip

      location /group1/M00/：group1为nginx 服务FastDFS的分组名称，M00是FastDFS自动生成编号，对应store_path0=/home/FastDFS/fdfs_storage，如果FastDFS定义store_path1，这里就是M01

10. 安装完成启动storage上的nginx：`/usr/local/nginx/sbin/nginx ‐c /usr/local/nginx/conf/nginx‐fdfs.conf`

11. 上传文件后，访问Storage，如http://192.168.25.133/group1/M00/00/00/wKgZhVx2q6yARolJAAGgU0NHZ6E212.jpg

    若一组有两台Storage服务器，则那一台也可以访问到，因为文件互相同步。并且访问Tracker服务器也可以看到文件

**配置Nginx图片服务虚拟机主机**

图片服务虚拟主机的作用是负载均衡，将图片请求转发到storage server上。

![1551285265020](images/1551285265020.png)

在nginx图片代理服务上配置图片服务器**虚拟主机**（在本机和前端静态文件同一个Nginx，如下只是测试，具体自己配置）

```
#图片服务
upstream img_server_pool1{
	#server 192.168.101.64:80 weight=10;
	server 192.168.101.65:80 weight=10;
}
upstream img_server_pool2{
	#server 192.168.101.66:80 weight=10;
	server 192.168.101.67:80 weight=10;
}

#学成网图片服务
server {
	listen 80;
	server_name img.xuecheng.com;

	#个人中心
	location /group1 {
		proxy_pass http://img_server_pool1;
	}

	location /group2 {
		proxy_pass http://img_server_pool2;
	}
}
```

重启Nginx，`./nginx -s reload`，配置hosts`127.0.0.1 img.xuecheng.com`



## 3 上传图片开发

### 3.1 需求分析

在很多系统都有上传图片/上传文件的需求，比如：上传课程图片、上传课程资料、上传用户头像等，为了提供系统的**可重用性**专门设立**文件系统服务**承担图片/文件的管理，文件系统服务实现对文件的上传、删除、查询等功能进行管理。

下图是课程管理中上传图片处理流程：

![1551286536321](images/1551286536321.png)

执行流程如下：

1、管理员进入教学管理前端，点击上传图片

2、图片上传至文件系统服务，文件系统请求fastDFS上传文件

3、**文件系统将文件入库（FastDFS）**，存储到**文件系统服务数据库中（MongoDB）**

4、文件系统服务向前端返回文件上传结果，如果成功则包括文件的Url路径

5、课程管理前端请求课程管理进行保存课程图片信息到课程数据库

6、课程管理服务将课程图片信息**保存在课程数据库（MySQL）**



### 3.2 创建文件系统微服务工程

导入xc-service-base-filesystem.zip工程。Maven依赖就不给出了

配置文件：原测试程序中fastdfs-client.properties的配置信息统一放在application.yml

```yaml
server:
  port: 22100
spring:
  application:
    name: xc-service-base-filesystem
#mongo配置
  data:
    mongodb:
      database: xc_fs
      uri: mongodb://root:123@127.0.0.1:27017
#SpringMVC上传文件配置
  servlet:
    multipart:
      #默认支持文件上传.
      enabled: true
      #支持文件写入磁盘.
      file-size-threshold: 0
      # 上传文件的临时目录
      location:
      # 最大支持文件大小
      max-file-size: 1MB
      # 最大支持请求大小
      max-request-size: 30MB
xuecheng:
  fastdfs:
    connect_timeout_in_seconds: 5 #http连接超时时间
    network_timeout_in_seconds: 30 #tracker与storage网络通信超时时间
    charset: UTF-8 #字符编码
    tracker_servers: 192.168.25.133:22122 #tracker服务器地址，多个地址中间用英文逗号分隔
```





### 3.2 模型类

还需创建xc_fs的MongoDB数据库，其中集合和文档就不需要了，因为Spring Data MongoDB会根据模型类自动映射并创建

```java
@Data
@Document(collection = "filesystem")
public class FileSystem {

    @Id//自动生成的文档中列名为_id。fastDFS返回的文件ID
    private String fileId;
    //文件请求路径，和fileId一致，请求fastDFS浏览文件URL
    private String filePath;
    //文件大小
    private long fileSize;
    //文件名称
    private String fileName;
    //文件类型
    private String fileType;
    //图片宽度
    private int fileWidth;
    //图片高度
    private int fileHeight;
    //用户id，用于授权
    private String userId;
    
    //以下三个为其他业务可能要上传的图片相关信息，与上传的图片无关
    
    //文件系统服务为其它子系统提供的一个业务标识字段，各子系统根据自己的需求去使用，比如：课程管理会在此字段中存储课程id用于标识该图片属于哪个课程。
    private String businesskey;
    //文件标签，由于文件系统服务是公共服务，文件系统服务会为使用文件系统服务的子系统分配文件标签，用于标识此文件来自哪个系统。
    private String filetag;
    //文件元信息
    private Map metadata;

}
```



### 3.3 Api

```java
@Api(value="文件系统服务接口",description = "文件系统服务接口，提供文件的管理、查询等接口")
public interface FileSystemControllerApi {

    //传入的metadata是JSON字符串，需要转换为Map
    @ApiOperation("文件上传")
    UploadFileResult upload(MultipartFile file,String businesskey,String filetag,String metadata);
}
```



### 3.4 Dao

```java
public interface FileSystemRepository extends MongoRepository<FileSystem,String> {
}
```



### 3.5 Service

```java
@Service
public class FileSystemService {
    @Value("${xuecheng.fastdfs.connect_timeout_in_seconds}")
    private int connect_timeout_in_seconds;
    @Value("${xuecheng.fastdfs.network_timeout_in_seconds}")
    private int network_timeout_in_seconds;
    @Value("${xuecheng.fastdfs.tracker_servers}")
    private String tracker_servers;
    @Value("${xuecheng.fastdfs.charset}")
    private String charset;

    @Autowired
    private FileSystemRepository fileSystemRepository;

    public UploadFileResult upload(MultipartFile file, String businesskey, String filetag, String metadata) {
        if (file == null) {
            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_FILEISNULL);
        }

        //第一步：将文件上传到fastDFS中，得到一个文件id
        String fileId = fdfs_upload(file);
        if (StringUtils.isEmpty(fileId)) {
            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_SERVERFAIL);
        }
        //第二步：将文件id及其它文件信息存储到mongodb中
        FileSystem fileSystem = new FileSystem();
        fileSystem.setFileId(fileId);//文件id
        fileSystem.setFilePath(fileId);//文件在文件系统中的路径
        fileSystem.setFileName(file.getOriginalFilename());//名称
        fileSystem.setFileSize(file.getSize());//大小
        fileSystem.setFileType(file.getContentType());//文件类型
        fileSystem.setBusinesskey(businesskey);//业务标识
        fileSystem.setFiletag(filetag);//标签
        if (!StringUtils.isEmpty(metadata)) { //元数据
            Map map = JSON.parseObject(metadata, Map.class);
            fileSystem.setMetadata(map);
        }
        fileSystemRepository.save(fileSystem);
        return new UploadFileResult(CommonCode.SUCCESS, fileSystem);
    }

    //上传文件到FastDFS
    private String fdfs_upload(MultipartFile file) {
        //初始化fastDFS的环境
        initFastDFSConfig();
        //创建trackerClient
        TrackerClient trackerClient = new TrackerClient();
        try {
            //得到Tracker服务器
            TrackerServer trackerServer = trackerClient.getConnection();
            //得到storage服务器
            StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
            //创建storageClient来上传文件
            StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer);
            //得到文件扩展名
            String ext = Objects.requireNonNull(file.getOriginalFilename()).split(".")[1];
            //上传并返回文件ID
            return storageClient1.upload_file1(file.getBytes(), ext, null);
        } catch (IOException | MyException e) {
            e.printStackTrace();
            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_SERVERFAIL);
        }
        return null;

    }

    //FastDFS初始化（由于使用了yml，所以需要手动初始化）
    private void initFastDFSConfig() {
        try {
            ClientGlobal.initByTrackers(tracker_servers);//初始化tracker服务地址
            ClientGlobal.setG_connect_timeout(connect_timeout_in_seconds);
            ClientGlobal.setG_network_timeout(network_timeout_in_seconds);
            ClientGlobal.setG_charset(charset);
        } catch (IOException | MyException e) {
            e.printStackTrace();
            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_USERISNULL);
        }
    }
}
```

### 3.6 Controller

```java
@RestController
@RequestMapping("/filesystem")
public class FileSystemController implements FileSystemControllerApi {
    @Autowired
    private FileSystemService fileSystemService;

    @Override
    @PostMapping("/upload")
    public UploadFileResult upload(MultipartFile file, String businesskey, String filetag, String metadata) {
        return fileSystemService.upload(file, businesskey, filetag, metadata);
    }
}
```

【注意】前端上传文件的name必须和MultipartFile的变量名`file`一致，也可以修改为其他名称

利用Swagger测试时，无论后端中MultipartFile的变量名是什么都可以上传成功，但是前端就必须一致！！！

### 3.7 前端

点击“加号”上传图片，图片上传成功自动显示；点击“删除”将删除图片。

使用Element-UI的Upload上传组件实现上边的效果。

```vue
<el-upload
           action="/api/filesystem/upload"
           list-type="picture-card"
           :before-upload="setuploaddata"
           :on-success="handleSuccess"
           :file-list="fileList"
           :limit="picmax"
           :on-exceed="rejectupload"
           :before-remove="handleRemove"
           :data="uploadval"
           name="file">
    <i class="el-icon-plus"></i>
</el-upload>
```

action：必选参数，上传的地址
list-type：文件列表的类型（text/picture/picture-card）
before-upload：上传前执行钩子方法 ，function(file)
on-success：上传成功 执行的钩子方法 ，function(response, file, fileList)
on-error：上传失败的钩子方法，function(err, file, fileList)
on-remove：文件删除的钩子方法，function(file, fileList)
**file-list**：文件列表，此列表为上传成功的文件
limit：最大允许上传个数
on-exceed：文件超出个数限制时的钩子，方法为：function(files, fileList)
data：提交上传的额外参数，需要封装为json对象，最终提交给服务端为key/value串

**name**必须前后端一致！！！！





## 4 保存课程图片

图片上传到文件系统后，其它子系统如果想使用图片可以引用图片的地址，课程管理模块使用图片的方式是将图片地址保存到课程数据库course_pic中。当前系统只保存一张！

### 4.1 Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("添加课程图片与课程关联")
    ResponseResult addCoursePic(String courseId,String pic);
}
```

### 4.2 Dao

数据模型

```java
@Data
@Entity
@Table(name="course_pic")
@GenericGenerator(name = "jpa-assigned", strategy = "assigned")
public class CoursePic implements Serializable {
    private static final long serialVersionUID = -916357110051689486L;

    @Id
    @GeneratedValue(generator = "jpa-assigned")
    private String courseid;
    private String pic;
}
```

```java
public interface CoursePicRepository extends JpaRepository<CoursePic,String> {
}
```



### 4.3 Service

```java
@Transactional
public ResponseResult saveCoursePic(String courseId, String pic) {
    CoursePic coursePic = null;
    //查询课程图片
    Optional<CoursePic> optional = coursePicRepository.findById(courseId);
    if (optional.isPresent()) {
        coursePic = optional.get();
    }
    //没有课程图片则新建对象
    if (coursePic==null){
        coursePic = new CoursePic();
    }
    //保存课程图片
    coursePic.setCourseid(courseId);
    coursePic.setPic(pic);
    coursePicRepository.save(coursePic);
    return new ResponseResult(CommonCode.SUCCESS);
}
```



### 4.4 Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @PostMapping("/coursepic/add")
    public ResponseResult addCoursePic(String courseId, String pic) {
        return courseService.saveCoursePic(courseId,pic);
    }
}
```



### 4.5 前端

前端需要在上传图片成功后保存课程图片信息

利用element UI上传成功的钩子 :on-success="handleSuccess"



## 5 图片查询

课程图片上传成功，再次进入课程上传页面应该显示出来已上传的图片。



### 5.1 Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("获取课程图片信息")
    CoursePic findCoursePic(String courseId);
}
```



### 5.2 Dao

```java
public interface CoursePicRepository extends JpaRepository<CoursePic,String> {
}
```



### 5.3 Service

```java
@Service
public class CourseService {
    public CoursePic findCoursepic(String courseId){
        Optional<CoursePic> optional = coursePicRepository.findById(courseId);
        return optional.orElse(null);
    }
}
```



### 5.4 Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @GetMapping("/coursepic/list/{courseId}")
    public CoursePic findCoursePic(@PathVariable String courseId) {
        return courseService.findCoursepic(courseId);
    }
}
```



### 5.5 前端

在课程图片页面的mounted钩子方法 中查询课程图片信息，并将图片地址赋值给数据对象（拼接域名），放入file-list中



## 6 课程图片删除

课程图片上传成功后，可以重新上传，方法是先删除现有图片再上传新图片。

注意：此删除只删除课程数据库的课程图片信息，不去删除文件数据库的文件信息及文件系统服务器上的文件，由于课程图片来源于该用户的文件库，所以此图片可能存在多个地方共用的情况，所以要删除文件系统中的文件需要到图片库由用户确认后再删除。

### 6.1 Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("删除课程图片")
    ResponseResult deleteCoursePic(String courseId);
}
```



### 6.2 Dao

原有的删除方法没有返回值，需要自定义

```java
public interface CoursePicRepository extends JpaRepository<CoursePic,String> {
    //返回影响的行数
    long deleteByCourseid(String courseId);
}
```



### 6.3 Service

```java
@Service
public class CourseService {
    @Transactional
    public ResponseResult deleteCoursePic(String courseId) {
        long row = coursePicRepository.deleteByCourseid(courseId);
        if (row>0){
            return new ResponseResult(CommonCode.SUCCESS);
        }
        return new ResponseResult(CommonCode.FAIL);
    }
}
```



### 6.4 Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @DeleteMapping("/coursepic/delete")
    public ResponseResult deleteCoursePic(String courseId) {
        return courseService.deleteCoursePic(courseId);;
    }
}
```



### 6.5 前端

在upload组件的before-remove钩子方法中实现删除动作。before-remove说明：

==删除文件之前的钩子，参数为上传的文件和文件列表，若**返回 false** 或者**返回 Promise 且被reject**，则**停止删除**。==

```js
//删除图片
handleRemove(file, fileList) {
    console.log(file)
    // return true;
    //删除图片
    courseApi.deleteCoursePic('1').then((res) => {
        if(res.success){
            this.$message.success('删除成功');
            return true;
        }else{
            this.$message.error(res.message);
            return false;
        }
    });
},
```

before-remove钩子方法中若调用Axios（使用Promise编写的HTTP异步请求方法），由于后端有异常处理，无论什么都会有统一格式的返回，所以对before-remove钩子方法来说，返回总是Promise的resolve状态。由于异步！所以此时已经删除了，不会等待判断后端返回是true或false。所以方法应改写如下

```js
//删除图片
handleRemove(file, fileList) {
    console.log(file)
    return new Promise((resolve,reject)=>{
        //删除图片
        courseApi.deleteCoursePic(this.courseid).then((res) => {
            if(res.success){
                this.$message.success('删除成功');
                resolve()//通过
            }else{
                this.$message.error(res.message);
                reject()//拒绝
            }
        });
    })
}
```



# 9 Spring Cloud Eureka/Feign

> Eureka [jʊ'riːkə] 。vi：（因找到某物，尤指问题的答案而高兴）我发现了
>
> Feign [fen]。vt：假装，伪装；vi：假装； 装作



## 1 Eureka注册中心

在前后端分离架构中，服务层被拆分成了很多的微服务，Spring Cloud中提供服务注册中心来管理微服务信息。

为什么要用注册中心？

1、微服务数量众多，要进行**远程调用**就需要**知道**服务端的**ip地址和端口**，注册中心帮助我们管理这些服务的ip和端口。

2、微服务会实时上报自己的状态，**注册中心**统一**管理这些微服务的状态**，将存在问题的服务踢出服务列表，客户端获取到可用的服务进行调用。



### 1.1 Eureka介绍

Spring Cloud Eureka 是对**Netflix**公司的**Eureka的二次封装**，它实现了**服务治理**的功能，Spring Cloud Eureka提供服务端与客户端，**服务端即是Eureka服务注册中心**，**客户端完成微服务向Eureka服务的注册与发现**。服务端和客户端均采用Java语言编写。下图显示了Eureka Server与Eureka Client的关系：

![1551374469172](images/1551374469172.png)

1、Eureka Server是服务端，负责**管理各个微服务结点的信息和状态**。

2、在**微服务上部署Eureka Client程序**，**远程访问Eureka Server将自己注册在Eureka Server**。

3、微服务需要调用另一个微服务时**从Eureka Server中获取服务调用地址**，进行**远程调用**。



### 1.2 Eureka Server搭建

#### 1.2.1 单机环境搭建

1. 创建xc-govern-center工程，包结构：com.xuecheng.govern.center

2. 添加Spring Cloud依赖，在父工程添加（有了则不用重复添加）

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring‐cloud‐dependencies</artifactId>
       <version>Finchley.SR1</version>
       <type>pom</type>
       <scope>import</scope>
   </dependency>
   ```

   在Eureka Server工程添加：

   ```xml
   <dependencies>
       <!--导入Eureka服务的依赖-->
       <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
           </dependency>
   </dependencies>
   ```

3. Spring Boot 启动类

   ```java
   @EnableEurekaServer//标识这是一个Eureka服务
   @SpringBootApplication
   public class GovernCenterApplication {
       public static void main(String[] args) {
           SpringApplication.run(GovernCenterApplication.class, args);
       }
   }
   ```

   > Govern ['ɡʌvərn] ，v.治理；控制；管理；统治

   **`@EnableEurekaServer`**，标识此服务为Eureka服务

4. 从其它服务拷贝application.yml和logback-spring.xml

   ```yaml
   server:
     port: 50101 #服务端口
   spring:
     application:
       name: xc‐govern‐center #指定服务名
   eureka:
     server:
       enable-self-preservation: false #是否开启自我保护模式
       eviction-interval-timer-in-ms: 60000 #服务注册表清理间隔（单位毫秒，默认是60*1000）。这个时间段内如果没有收到该结点的上报则将结点从服务列表中剔除
     client:
       register-with-eureka: false #服务注册，是否将自己注册到Eureka服务中，被其它服务调用时需向Eureka注册
       fetch-registry: false #服务发现，是否从Eureka中获取注册信息，需要从Eureka中查找要调用的目标服务时需要设置为true
       serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方服务器的地址，单机状态配置自己（如果不配置则默认本机8761端口）
         defaultZone: http://localhost:50101/eureka/
   ```

5. 启动Eureka Server，浏览50101端口

   红色提示信息：`THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.`自我保护模式被关闭。在网络或其他问题的情况下可能不会保护实例失效。

   Eureka Server有一种自我保护模式，当微服务不再向Eureka Server上报状态，Eureka Server会从服务列表将此服务删除，如果出现网络异常情况（微服务正常），此时Eureka server进入自保护模式，不再将微服务从服务列表删除。在开发阶段建议关闭自保护模式。



#### 1.2.2 高可用环境搭建

Eureka Server 高可用环境需要部署两个Eureka server，它们**互相向对方注册**。如果在本机启动两个Eureka需要注意两个Eureka Server的端口要设置不一样，这里我们部署一个Eureka Server工程，将端口可配置，制作两个Eureka Server启动脚本，启动不同的端口，如下图：

![1551377211536](images/1551377211536.png)

1、在实际使用时Eureka Server至少部署两台服务器，实现高可用。

2、两台Eureka Server互相注册。

3、微服务需要连接两台Eureka Server注册，当其中一台Eureka死掉也不会影响服务的注册与发现。

4、微服务会定时向Eureka server发送心跳，报告自己的状态。

5、微服务从注册中心获取服务地址以RESTful方式发起远程调用。

配置如下：

1. 端口可配置

   ```yaml
   server:
     port: ${PORT:50101} #服务端口
   ```

2. Eureka客户端与Eureka服务端的交互地址可配置

   ```yaml
   eureka:
     client:
       register-with-eureka: false #服务注册，是否将自己注册到Eureka服务中，被其它服务调用时需向Eureka注册
       fetch-registry: false #服务发现，是否从Eureka中获取注册信息，需要从Eureka中查找要调用的目标服务时需要设置为true
       serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方服务器的地址，单机状态配置自己（如果不配置则默认本机8761端口）
         defaultZone: ${EUREKA_SERVER:http://eureka02:50102/eureka/}
   ```

3. 配置hostname

   Eureka 组成高可用，两个Eureka**互相向对方注册**，这里需要**通过域名或主机名访问**，这里我们设置两个Eureka服务的主机名分别为 eureka01、eureka02。完整的Eureka配置如下：

   ```yaml
   server:
     port: ${PORT:50101} #服务端口
   spring:
     application:
       name: xc‐govern‐center #指定服务名
   
   eureka:
     server:
       enable-self-preservation: false #是否开启自我保护模式
       eviction-interval-timer-in-ms: 60000 #服务注册表清理间隔（单位毫秒，默认是60*1000）。这个时间段内如果没有收到该结点的上报则将结点从服务列表中剔除
     client:
       register-with-eureka: false #服务注册，是否将自己注册到Eureka服务中，被其它服务调用时需向Eureka注册
       fetch-registry: false #服务发现，是否从Eureka中获取注册信息，需要从Eureka中查找要调用的目标服务时需要设置为true
       serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方服务器的地址，单机状态配置自己（如果不配置则默认本机8761端口）
         defaultZone: ${EUREKA_SERVER:http://eureka02:50102/eureka/}
     instance:
       hostname: ${EUREKA_DOMAIN:eureka01}
   ```

   还需配置hosts

   ```
   127.0.0.1 eureca01
   127.0.0.1 eureca02
   ```

4. 在IDEA中制作启动脚本，设置环境变量，在VM options中分别配置：

   - `-DPORT=50101 -DEUREKA_SERVER=http://eureka02:50102/eureka/ -DEUREKA_DOMAIN=eureka01`
   - `-DPORT=50102 -DEUREKA_SERVER=http://eureka01:50101/eureka/ -DEUREKA_DOMAIN=eureka02`

5. 运行两个启动脚本，分别浏览 http://localhost:50101/ 和 http://localhost:50102/

6. 以50101端口为例。DS Replicas为副本名称，Instances为注册在Eureka中的实例

   ![1551379518691](images/1551379518691.png)



### 1.3 Eureka Client服务注册

下边实现cms向Eureka Server注册

1. 在cms服务中添加依赖

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
   </dependency>
   ```

2. 在application.yml添加配置Eureka的信息

   ```yaml
   server:
     port: ${PORT:31001}
   spring:
     application:
       name: xc-service-manage-cms
         
   eureka:
     client:
       registerWithEureka: true #服务注册开关
       fetchRegistry: true #服务发现开关
       serviceUrl: #Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔
         defaultZone: ${EUREKA_SERVER:http://localhost:50101/eureka/,http://localhost:50102/eureka/}
     instance:
       prefer-ip-address:  true  #将自己的ip地址注册到Eureka服务中
       ip-address: ${IP_ADDRESS:127.0.0.1}
       instance-id: ${spring.application.name}:${server.port} #指定实例id
   ```

3. 在启动类上添加**注解`@EnableDiscoveryClient`**，表示它是一个Eureka的客户端，可以从Eureka远程调用服务。启动服务

4. 以Eureka Server的50101端口为例

   ![1551381678754](images/1551381678754.png)

   

> 同理将manage-course注册到Eureka Server



## 2 Feign远程调用

在前后端分离架构中，服务层被拆分成了很多的微服务，服务与服务之间难免发生交互，比如：课程发布需要调用CMS服务生成课程静态化页面，本节研究微服务远程调用所使用的技术。下图是课程管理服务远程调用CMS服务的流程图：

![1551381915725](images/1551381915725.png)

1、cms服务将自己注册到注册中心。

2、课程管理服务从注册中心获取cms服务的地址。

3、课程管理服务远程调用cms服务。

### 2.1 Ribbon

#### 2.1.1 Ribbon 简介

[Ribbon](https://github.com/Netflix/ribbon)是Netflix公司开源的一个负载均衡的项目，它是一个基于HTTP、TCP的==**客户端负载均衡器**==。

1、什么是负载均衡？

负载均衡是微服务架构中必须使用的技术，**通过负载均衡来实现系统的高可用、集群扩容等功能**。负载均衡可通过硬件设备及软件来实现，硬件比如：F5、Array等，软件比如：LVS、Nginx等。如下图是负载均衡的架构图：

![1551382033658](images/1551382033658.png)

用户请求先到达负载均衡器（也相当于一个服务），负载均衡器根据负载均衡算法将请求转发到微服务。负载均衡算法有：轮训、随机、加权轮训、加权随机、地址哈希等方法，负载均衡器维护一份服务列表，根据负载均衡算法将请求转发到相应的微服务上，所以负载均衡可以为微服务集群分担请求，降低系统的压力。

2、什么是**客户端负载均衡**？

上图是服务端负载均衡，客户端负载均衡与服务端负载均衡的区别在于**客户端要维护一份服务列表**，Ribbon从Eureka Server获取服务列表，Ribbon根据负载均衡算法直接请求到具体的微服务，中间省去了负载均衡服务。如下图是Ribbon负载均衡的流程图：

![1551382153266](images/1551382153266.png)

1、在消费微服务中使用Ribbon实现负载均衡，Ribbon先从EurekaServer中获取服务列表。

2、Ribbon根据负载均衡的算法去调用微服务。



#### 2.1.2 Ribbon测试

Spring Cloud引入Ribbon 配合 restTemplate 实现客户端负载均衡调用。Java中远程调用的技术有很多，如：webservice、socket、rmi、Apache HttpClient、OkHttp等，互联网项目使用基于http的客户端较多，本项目使用OkHttp。

1. 在**客户端**添加Ribbon依赖（这里在**课程管理服务**配置ribbon依赖，来请求**CMS**服务端），由于依赖了spring-cloud-starter-eureka-***，会自动添加spring-cloud-starter-ribbon依赖。只需额外配置okhttp依赖。

2. 配置Ribbon参数（这里在课程管理服务的application.yml中配置ribbon参数，不配置也可以（IDEA提示属性不能解析））

   ```yaml
   ribbon:
     MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试
     MaxAutoRetriesNextServer: 3 #切换实例的重试次数
     OkToRetryOnAllOperations: false  #对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false
     ConnectTimeout: 5000  #请求连接的超时时间
     ReadTimeout: 6000 #请求处理的超时时间
   ```

3. **负载均衡测试**

   1. 启动两个cms服务，注意端口要不一致（还是利用 VM options，参考之前的写法，如`${PORT:31001}`）

   2. 在课程管理服务的启动类中**配置RestTemplate**

      ```java
      @Bean
      @LoadBalanced//开启客户端负载均衡
      public RestTemplate restTemplate(){
          return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
      }
      ```

   3. 课程管理服务中测试类请求CMS服务

      ```java
      @SpringBootTest
      @RunWith(SpringRunner.class)
      public class TestRibbon {
          @Autowired
          private RestTemplate restTemplate;
      
          @Test
          public void testRibbon() {
              //确定要获取的服务名（实例id，大小写无所谓）
              String serviceId = "XC-SERVICE-MANAGE-CMS";
              for (int i = 0; i < 10; i++) {
                  //Ribbon客户端从EurekaServer中获取服务列表,根据服务名获取服务列表
                  ResponseEntity<Map> forEntity = restTemplate.getForEntity("http://" + serviceId + "/cms/page/get/5a754adf6abb500ad05688d9", Map.class);
                  Map body = forEntity.getBody();
                  System.out.println(body);
              }
          }
      }
      ```

   添加@LoadBalanced注解后，restTemplate会走LoadBalancerInterceptor拦截器，此拦截器中会通过
   **`RibbonLoadBalancerClient`**查询服务地址，在此类打断点观察每次调用的服务地址和端口，两个cms服务会轮流被调用

   ![1551430371106](images/1551430371106.png)

   




### 2.2 Feign

Feign是Netflix公司开源的轻量级**rest客户端**，使用Feign可以非常方便的实现Http 客户端。Spring Cloud引入**Feign并且集成了Ribbon实现客户端负载均衡调用**。

1. 在客户端添加依赖（课程管理服务添加下边的依赖）

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-openfeign</artifactId>
   </dependency>
   ```

2. 定义**`FeignClient`接口**，参考Swagger文档，注意接口的Url、请求参数类型、返回值类型与Swagger接口一致。

   本次实例在课程管理服务中创建client包，定义查询cms页面的客户端该用接口

   ```java
   @FeignClient("XC-SERVICE-MANAGE-CMS")//指定远程调用的服务名，不区分大小写
   public interface CmsPageClient {
   
       //根据页面id查询页面信息，远程调用cms请求数据
       @GetMapping("/cms/page/get/{id}")//用GetMapping标识远程调用的http的方法类型
       CmsPage findById(@PathVariable String id);
   
   }
   ```

3. Spring Boot 启动类上**添加`@EnableFeignClients`注解**

4. 远程调用测试

   ```java
   @SpringBootTest
   @RunWith(SpringRunner.class)
   public class TestFeign {
       @Autowired
       private CmsPageClient cmsPageClient; //接口代理对象，由Feign生成代理对象
   
       @Test
       public void testRibbon() {
           //发起远程调用
           CmsPage cmsPage = cmsPageClient.findById("5a754adf6abb500ad05688d9");
           System.out.println(cmsPage);
       }
   }
   ```

【注意】SpringCloud对Feign进行了增强兼容了SpringMVC的注解 ，我们在使用SpringMVC的注解时需要注意：

* feignClient接口 有参数在参数必须加@PathVariable("XXX")和@RequestParam("XXX")
* feignClient**返回值为复杂对象时其类型必须有无参构造函数**（利用lombok的`@NoArgsContructor`）







## 3 课程预览—页面静态化

### 3.1 技术方案

课程预览是为了保证课程发布后的正确性，通过课程预览可以直观的通过课程详情页面看到课程的信息是否正确，通过**课程预览**看到的页面内容和课程发布后的**页面详情内容**是**一致**的。

课程详情页面技术方案：

* 技术需求

  * 课程详情页面是向用户展示课程信息的窗口，课程相当于网站的商品，本页面的**访问量会非常大**。
  * **SEO**，要非常有利于爬虫抓取页面上信息，并且生成页面快照，利于用户通过搜索引擎搜索课程信息。

* 解决方案：

  对于不会频繁改变的信息可以采用**页面静态化**的技术，提前让页面生成html静态页面存储在nginx服务器，用户直接访问nginx即可，对于一些**动态信息可以访问服务端获取json数据**在页面渲染。

  ![1551437588132](images/1551437588132.png)

  * 优点：使用Nginx作为web服务器，并且直接访问html页面，性能出色。
  * 缺点：需要维护大量的静态页面，增加了维护的难度。

* 操作流程：

  1. 制作课程详情页面**模板**
  2. 开发课程详情页面**数据模型的查询接口**（为静态化提供数据）
  3. **调用cms课程预览接口**通过浏览器**浏览静态文件**

  



### 3.2 课程详情页面静态化

#### 3.2.1 页面内容组成及拆分

利用SSI技术进行页面拆分：

* 页头：include\header.html
* 页尾：include\footer.html
* 课程详情主页面：课程id.html（课程id动态变化）
* 教育机构页面：company_info_公司id.html（公司id动态变化）
* 老师信息页面：teacher_info_教师id.html（教师id动态变化）
* 课程统计页面：course_stat_课程id.**json**（课程id动态变化）
* 教育机构统计页面：company_stat_公司id.**json**（公司id动态变化）



#### 3.2.2 静态页面测试

##### 1、页面加载思路

- 我们需要在主页面中通过SSI加载：页头、页尾、教育机构、教师信息
- 异步加载课程统计与教育机构统计信息，都是JSON
- 用户点击“马上学习”会根据课程收费情况、课程购买情况执行下一步操作

##### 2、静态资源虚拟主机

1. 静态资源虚拟主机负责处理课程详情、公司信息、老师信息、统计信息等页面的请求

   将课程资料中的“静态页面目录”中的static目录拷贝到D:\Code-Workspace\_Project\xcEdu\xcEduUI目录下

   在nginx中配置静态虚拟主机如下（上面拷贝的static中资源，访问`localhost:91`时就访问该资源。单独配置好管理）：

   ```properties
   #学成网静态资源
   server {
   	listen 91;
   	server_name localhost;
   
   	#公司信息
   	location /static/company/ {
   		alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/static/company/;
   	}
   	#老师信息
   	location /static/teacher/ {
   		alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/static/teacher/;
   	}
   	#统计信息
   	location /static/stat/ {
   		alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/static/stat/;
   	}
   	location /course/detail/ {
   		alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/static/course/detail/;
   	}
   }
   ```

2. 由于课程页面需要通过SSI加载页头和页尾所以需要通过www.xuecheng.com虚拟主机转发到静态资源

   将通过访问www.xuecheng.com，映射到1中的静态资源

   ```properties
   #静态资源服务
   upstream static_server_pool{
   	server 127.0.0.1:91 weight=10;
   }
   
   server{
   	listen 80;
   	server_name www.xuecheng.com;
   	
   	ssi on;
   	ssi_silent_errors on;
   	
   	location /static/company/ {
   		proxy_pass http://static_server_pool;
   	}
   	location /static/teacher/ {
   		proxy_pass http://static_server_pool;
   	}
   	location /static/stat/ {
   		proxy_pass http://static_server_pool;
   	}
   	location /course/detail/ {
   		proxy_pass http://static_server_pool;
   	}
   }
   ```

##### 3、门户静态资源路径

门户中的一些图片、样式等静态资源统一通过/static路径对外提供服务，在www.xuecheng.com虚拟主机中配置如下：

添加在2的第2步骤中server

```properties
#静态资源，包括系统所需要的图片，js、css等静态资源
location /static/img/ {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/img/;
}
location /static/css/ {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/css/;
}
location /static/js/ {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/js/;
}
location /static/plugins/ {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/plugins/;
	add_header Access‐Control‐Allow‐Origin http://ucenter.xuecheng.com;
	add_header Access‐Control‐Allow‐Credentials true;
	add_header Access‐Control‐Allow‐Methods GET;
}
```

CORS跨域参数：

* Access-Control-Allow-Origin：允许跨域访问的外域地址。如果允许任何站点跨域访问则设置为*，通常这是不建议的。

* Access-Control-Allow-Credentials： 允许客户端携带证书访问

* Access-Control-Allow-Methods：允许客户端跨域访问的方法

##### 4、测试

请求：http://www.xuecheng.com/course/detail/course_main_template.html测试课程详情页面模板



##### 5、页面动态脚本

为了方便日后的维护，我们将javascript实现的动态部分单独编写一个 html 文件，在门户的include目录下定义course_detail_dynamic.html文件，此文件通过ssi包含在课程详情页面中。所有的课程公用一个 页面动态脚本。

在课程详情主页面下端添加如下代码，通过SSI技术包含课程详情页面动态脚本文件：

```html
<body>
	<!--省略...-->
    <script>var courseId = "template"</script>
    <!‐‐#include virtual="/include/course_detail_dynamic.html"‐‐>
</body>
```

请求的是当前域名即`协议:IP:端口`下的/include/course_detail_dynamic.html，会被之前做的如下配置映射

```properties
location / {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/;
	index index.html;
}
```



### 3.3 课程数据模型查询

#### 1、数据模型

```java
@Data
@NoArgsConstructor
public class CourseView implements Serializable {

    private CourseBase courseBase;//基础信息
    private CoursePic coursePic;//课程图片
    private CourseMarket courseMarket;//课程营销
    private TeachplanNode teachplanNode;//教学计划
}
```

#### 2、Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("课程视图查询")
    CourseView courseview(String id);
}
```

#### 3、Dao

略

#### 4、Service

```java
public CourseView getCourseView(String id) {
    CourseView courseView = new CourseView();
    //查询课程基本信息
    Optional<CourseBase> baseOptional = courseBaseRepository.findById(id);
    baseOptional.ifPresent(courseView::setCourseBase);//lambda中方法引用
    //查询课程图片信息
    Optional<CoursePic> picOptional = coursePicRepository.findById(id);
    picOptional.ifPresent(courseView::setCoursePic);
    //查询课程营销信息
    Optional<CourseMarket> marketOptional = courseMarketRepository.findById(id);
    marketOptional.ifPresent(courseView::setCourseMarket);
    //查询课程计划信息（使用MyBatis）
    TeachplanNode teachplanNode = teachplanMapper.selectList(id);
    courseView.setTeachplanNode(teachplanNode);
    return courseView;
}
```

#### 5、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @GetMapping("/courseview/{id}")
    public CourseView courseview(@PathVariable String id) {
        return courseService.getCourseView(id);
    }
}
```

swagger测试



### 3.4 课程信息模板设计

在确定了静态化所需要的数据模型之后，就可以编写页面模板了，课程详情页面由多个静态化页面组成，所以我们需要创建多个页面模板，本章节创建**课程详情页面的主模板**，**即课程信息模板**。（此处就不从HTML改写为ftl）

#### 3.4.1 模板测试

使用test-freemarker工程测试模板

将course.ftl拷贝到test-freemarker工程的resources/templates下，并在test-freemarker工程的controller中添加测试方法

```java
@RequestMapping("/courseview")
public String courseview(Map<String, Object> map) {
    ResponseEntity<Map> entity = restTemplate.getForEntity("http://localhost:31200/course/courseview/4028e581617f945f01617f9dabc40000", Map.class);
    map.putAll(entity.getBody());
    return "course";
}
```

注意：上边的测试页面不显示样式，原因是页面通过SSI包含了页面头，而使用test-freemarker工程使用Tomcat无法加载页头



#### 3.4.2 模板保存

> 模板的保存应该编写在CMS服务中，由CMS前端来管理保存。此处使用手动方式😁


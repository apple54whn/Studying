# 1 项目概述—CMS 接口开发

## 1 功能架构与技术架构

### 1.1 功能架构

当前市场的在线教育模式多种多样，包括：B2C、C2C、B2B2C等业务模式，**学成在线采用B2B2C业务模式**，即**向企业或个人提供在线教育平台提供教学服务**，老师和学生通过平台完成整个教学和学习的过程，市场上类似的平台有：网易云课堂、腾讯课堂等，学成在线的特点是IT职业课程在线教学。**项目架构**如下：

![](images/功能架构.jpg)

### 1.2 技术架构

学成在线采用当前流行的**前后端分离**架构开发，由用户层、UI层、微服务层、数据层等部分组成，为PC、App、H5等客户端用户提供服务。下图是系统的**技术架构**图：

![](images/技术架构.jpg)

用户层：描述了本系统所支持的用户类型包括：pc用户、app用户、h5用户

CDN：全称Content Delivery Network，即内容分发网络，本系统所有静态资源全部通过CDN加速来提高访问速度。

负载均衡：系统的CDN层、UI层、服务层及数据层均设置了负载均衡服务，上图仅在UI层前边标注了负载均衡。 每一层的负载均衡会根据系统的需求来确定负载均衡器的类型，系统支持4层负载均衡+7层负载均衡结合的方式，4层负载均衡是指在网络传输层进行流程转发，根据IP和端口进行转发，7层负载均衡完成HTTP协议负载均衡及反向代理的功能，根据url进行请求转发。

UI层：描述了系统向pc用户、app用户、h5用户提供的产品界面。

**微服务层**：将系统服务分类三类：前端服务、后端服务及系统服务。 **前端服务**：主要为学习用户提供学习服务。 **后端服务**：主要为管理用户提供教学管理服务。 **系统服务**：公共服务，为系统的所有微服务提供公共服务功能。 **服务网关**：提供服务路由、负载均衡、认证授权等服务。

**数据层**：描述了系统的数据存储的内容类型，持久化的业务数据使用MySQL和MongoDB保存，其中**MongoDB**中主要保存系统日志信息。 **消息队列**：存储系统服务间通信的消息，本身提供消息存取服务，与微服务层的系统服务连接。 **索引库**：存储课程信息的索引信息，本身提供索引维护及搜索的服务，与微服务层的系统服务连接。 **缓存**：作为系统的缓存服务，存储课程信息、分类信息、用户信息等，与微服务层的所有服务连接。**文件存储**：提供系统静态资源文件的分布式存储服务，文件存储服务器作为CDN服务器的数据来源，CDN上的静态资源将最终在文件存储服务器上保存多份。 **流媒体服务**：作为流媒体服务器，存储所有的流媒体文件。

外部系统接口：略

DevOps：Development和Operations的组合，是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。

------

重点了解微服务技术栈，学成在线服务端基于Spring Boot构建，采用Spring Cloud微服务框架。

* 持久层：MySQL、MongoDB、Redis、ElasticSearch、RabbitMQ、FastDFS等
* 数据访问层：Spring Data JPA 、Mybatis、Spring Data Mongodb、druid等
* 业务层：Spring IOC、Aop、Spring Task、Feign、Ribbon、Spring AMQP、Spring Data Redis、RabbitTemplate等
* 控制层：Spring MVC、FastJSON、RestTemplate、Spring Security Oauth2+JWT、swagger 等
* 微服务治理：Eureka、Zuul、Hystrix、Spring Cloud Config等



### 1.3 开发步骤

项目是基于前后端分离的架构进行开发，前后端分离架构总体上包括前端和服务端，通常是多人协作并行开发，开发步骤如下：

1. 需求分析：梳理用户的需求，分析业务流程
2. **接口定义**：根据需求分析定义接口
3. **服务端和前端并行开发**：依据接口进行服务端接口开发；前端开发用户操作界面，并请求服务端接口完成业务处理；
4. 前后端集成测试：最终前端调用服务端接口完成业务



## 2 CMS 开发

### 2.1 CMS 需求分析

#### 2.1.1 CMS 简介

**CMS （Content Management System）**即**内容管理系统**，不同的项目对CMS的定位不同，比如：一个在线教育网站，有些公司认为CMS系统是对所有的课程资源进行管理，而在早期网站刚开始盛行时很多公司的业务是网站制作，当时对CMS的定位是创建网站，即对网站的页面、图片等静态资源进行管理。

每个公司对每个项目的CMS定位不同，CMS基本上分为：针对后台数据内容的管理、针对前端页面的管理、针对样式风格的管理等 。比如：一个给企业做网站的公司，其CMS系统主要是网站页面管理及样式风格的管理。

本项目作为一个大型的在线教育平台，对CMS系统的定位是对各个网站（子站点）页面的管理，主要管理由于运营需要而**经常变动的页面**，从而实现根据运营需要快速进行页面开发、上线的需求。

#### 2.1.2 静态门户工程搭建

1. 安装Nginx，解压，双击nginx.exe即可运行。访问`http://localhost`

2. 导入门户工程到Webstorm或VSCode

3. 配置虚拟主机

   ```nginx
   server{
       listen 80;
       server_name www.xuecheng.com; # 需要映射IP
   
       ssi on;
       ssi_silent_errors on;
       location / {
           alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/;
           index index.html;
       }
   }
   ```

   `D:/Code-Workspace/Webstorm/xc-ui-pc-static-portal/`本目录为门户的主目录

4. 配置hosts文件`C:\Windows\System32\drivers\etc\hosts`，访问`http://www.xuecheng.com/`

   ```
   127.0.0.1       www.xuecheng.com
   ```

#### 2.1.3 SSI 服务端包含技术

本节分析首页的管理方案：

* 页面内容多如何管理？将页面**拆分**成一个一个的小页面，通过**cms去管理这些小页面**，只需要更改具体某个小页面即可。
* 页面拆出来怎么样通过web服务浏览呢？使用web服务(例如nginx)的**SSI技术**，将多个子页面合并渲染输出。

SSI 包含类似于jsp页面中的incluce指令（js，Thymeleaf、freemaker都有），**SSI 是在web服务端将include指定的页面包含在网页中**，**渲染**html网页响应给客户端 。nginx、apache等多数web容器都支持SSI指令。如下：

```html
<!‐‐#include virtual="/../....html"‐‐>
```

在HTML中看起来和注释一样，但是其实格式就是这样！

Nginx中SSI 配置参数如下：

* `ssi on`：开启ssi支持
* `ssi_silent_errors on`：默认为off，设置为on则在处理SSI文件出错时不输出错误信息
* `ssi_types`：默认为 `ssi_types text/html`，如果需要支持shtml（服务器执行脚本，类似于jsp）则需要设置为`ssi_types text/shtml`

#### 2.1.4 CMS 页面管理需求

1. **创建站点**：一个网站有很多子站点，比如：学成在线有主门户、学习中心。具体的哪个页面是归属于具体的站点，所以要管理页面，先要管理页面所属的站点。
2. **创建模板**：页面如何创建呢？比如电商网站的商品详情页面，每个页面的内容布局、板式是相同的，不同的只是内容，这个页面的布局、板式就是页面模板，模板+数据就组成一个完整的页面，最终要创建一个页面文件需要先定义此页面的模板，最终拿到页面的数据再结合模板就拼装成一个完整的页面。
3. **创建页面**：指填写页面的基本信息，如：页面的名称、页面的url地址等。
4. **页面预览**：是页面发布前的一项工作，页面预览使用静态化技术根据页面模板和数据生成页面内容，并通过浏览器预览页面。页面发布前进行页面预览的目是为了保证页面发布后的正确性。
5. **页面发布**：使用计算机技术将页面发送到页面所在站点的服务器，页面发布成功就可以通过浏览器来访问了

本项目要实现什么样的功能？

- 页面管理：管理员在后台添加、修改、删除页面信息
- 页面预览：管理员通过页面预览功能预览页面发布后的效果
- 页面发布：管理员通过页面发布功能将页面发布到远程门户服务器。

页面发布成功，用户即可在浏览器浏览到，整个页面添加、发布的过程由于**软件自动执行**，无需人工登录服务器操作。



### 2.2 CMS 服务端工程搭建

服务端工程代码复制到目录 `xcEdu/xcEduService`中（前端工程代码目录 `xcEdu/xcEduUI`）

导入基础工程（在IDEA中 project structure 的 Modules 中点击 Import Model 导入以下 maven 工程即可）

CMS及其它服务端工程基于maven进行构建，首先需要创建如下基础工程：

* **parent**工程：父工程，提供**依赖管理**。

* common工程：通用工程，提供各层封装

* **model**工程：模型工程，提供统一的模型类管理。类似domain

* utils工程：工具类工程，提供本项目所使用的工具类

* **Api**工程：**接口工程**，统一管理本项目的服务接口

![1550426898343](images/1550426898343.png)

------

MongoDB的入门及导入CMS数据库

导入集合到`xc_cms`数据库中，略



### 2.3 ==页面查询接口定义==

#### 2.3.1 定义模型

##### 1、需求分析

本次定义**页面查询接口**，本接口供前端请求查询页面列表，支持**分页**及**自定义条件查询**方式。具体**需求**如下：

* 分页查询MongoDB `cms_page`集合下的数据
* 根据站点Id、模板Id、页面别名查询页面信息
* 接口基于HTTP Get请求，响应Json数据

##### 2、模型类介绍

接口的定义离不开**数据模型**（类似domain），根据前边对需求的分析，整个页面管理模块的数据模型如下：

* CmsSite：站点模型
* CmsTemplate：页面模板
* CmsPage：页面信息，代码如下

> 分别对应MongoDB中集合cms_site, cms_template, cms_page。每个页面都有所属站点，并且页面可能使用的模板不一样

```java
@Data //Lombok提供注解，自动生成getter/setter，toString，equals，hashCode方法
@ToString //Lombok提供注解，自动生成tostring方法
@Document(collection = "cms_page")//Spring Data MongoDB提供的注解，映射MongoDB中集合
public class CmsPage {
    /**
     * 定义一个页面需要指定页面所属站点，一个站点包括多个页面，比如：学成在线的门户站点（网站）包括了多个页面。
     * 定义一个页面需要指定页面使用的模板，多个页面可以使用相同的模板，比如：商品信息模板，每个商品就是一个页面，所有商品使用同一个商品信息模板
     */

    //站点ID
    private String siteId;
    //页面ID
    @Id
    private String pageId;
    //页面名称
    private String pageName;
    //别名
    private String pageAliase;
    //访问地址
    private String pageWebPath;
    //参数
    private String pageParameter;
    //物理路径
    private String pagePhysicalPath;
    //类型（静态/动态）
    private String pageType;
    //页面模版
    private String pageTemplate;
    //页面静态化内容
    private String pageHtml;
    //状态
    private String pageStatus;
    //创建时间
    private Date pageCreateTime;
    //模版id
    private String templateId;
    //参数列表
    private List<CmsPageParam> pageParams;
    //模版文件Id
    //private String templateFileId;
    //静态文件Id
    private String htmlFileId;
    //数据Url
    private String dataUrl;

}
```

##### 3、Lombok

[Lombok](https://www.projectlombok.org/)是一个实用的java工具，使用它可以消除java代码的臃肿，Lombok提供一系列的注解，使用这些注解可以不用定义getter/setter、equals、构造方法等，它会在**编译时在字节码文件自动生成这些通用的方法**，简化开发人员的工作。用法：

1. Maven依赖，作用是项目在编译时根据Lombok注解生成通用方法。

   ```xml
   <dependency>
       <groupId>org.projectlombok</groupId>
       <artifactId>lombok</artifactId>
   </dependency>
   ```

2. 在IDEA开发工具中添加Lombok插件，作用是使用IDEA开发时根据Lombok注解生成通用方法，不报错。



#### 2.3.2 定义接口

##### 1、定义请求及响应类型

1. 定义请求模型`QueryPageRequest`，此模型作为查询条件类型。为后期扩展需求，请求类型统一继承RequestData类型（在common中，此类暂时没有内容）

   ```java
   @Data
   public class QueryPageRequest extends RequestData {
       //站点id
       private String siteId;
       //页面ID
       private String pageId;
       //页面名称
       private String pageName;
       //别名
       private String pageAliase;
       //模版id
       private String templateId;
   }
   ```

2. 响应结果类型，分页查询统一使用`QueryResponseResult`，其包含`QueryResult`属性，有数据列表和总记录数属性；并且它继承了`ResponseResult`含有success和message等属性信息

##### 2、定义接口

在**Api接口工程**专门定义接口，在Api工程单独定义接口的原因如下：

* 接口==**集中管理**==

* Api工程的接口将作为==**各微服务远程调用使用**==

  ```java
  //package com.xuecheng.api.cms
  public interface CmsPageControllerApi {
      //页面查询
      QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest);
  }
  ```




### 2.4 ==页面查询服务端开发==

#### 2.4.1 创建CMS服务工程

创建maven工程，使用Spring Boot(jar)， CMS工程的名称为 `xc-service-manage-cms`，父工程为`xc-framework-parent`。

创建基本包结构：`com.xuecheng.manage_cms.config/dao/service/controller`，config为配置类目录，数据库、MQ配置等

```xml
<dependencies>
    <dependency>
        <groupId>com.xuecheng</groupId>
        <artifactId>xc-framework-common</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.xuecheng</groupId>
        <artifactId>xc-service-api</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.xuecheng</groupId>
        <artifactId>xc-framework-model</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.xuecheng</groupId>
        <artifactId>xc-framework-utils</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-freemarker</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-mongodb</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>
    <dependency>
        <groupId>com.squareup.okhttp3</groupId>
        <artifactId>okhttp</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
    </dependency>
</dependencies>
```

配置`application.yml`

```yaml
server:
  port: 31001
spring:
  application:
    name: xc‐service‐manage‐cms
  data:
    mongodb:
      uri: mongodb://root:123@localhost:27017
      database: xc_cms
```

配置`logback-spring.xml`日志

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--定义日志文件的存储地址,使用绝对路径-->
    <property name="LOG_HOME" value="d:/logs"/>

    <!-- Console 输出设置 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>

    <!-- 按照每天生成日志文件 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名-->
            <fileNamePattern>${LOG_HOME}/xc.%d{yyyy-MM-dd}.log</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 异步输出 -->
    <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
        <queueSize>512</queueSize>
        <!-- 添加附加的appender,最多只能添加一个 -->
        <appender-ref ref="FILE"/>
    </appender>


    <logger name="org.apache.ibatis.cache.decorators.LoggingCache" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>
    <logger name="org.springframework.boot" level="DEBUG"/>
    <root level="info">
        <!--<appender-ref ref="ASYNC"/>-->
        <appender-ref ref="FILE"/>
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

启动类及包扫描配置

```java
@SpringBootApplication
@EntityScan("com.xuecheng.framework.domain.cms")//扫描实体类
@ComponentScan("com.xuecheng.api")//扫描接口
@ComponentScan("com.xuecheng.manage_cms")//扫描本项目下的所有类，可以不配置，默认扫描此类所在包及子包中的bean...
public class ManageCmsApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(ManageCmsApplication.class, args);
    }
}
```



#### 2.4.2 Repository

```java
package com.xuecheng.manage_cms.dao;

public interface CmsPageRepository extends MongoRepository<CmsPage,String> {
}
```



#### 2.4.3 Service

```java
@Service
public class CmsPageService {

    @Autowired
    private CmsPageRepository cmsPageRepository;
    /**
     * 分页条件查询
     * @param page，页码，从1开始
     * @param size，每页记录数
     * @param queryPageRequest，查询条件
     * @return
     */
    public QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest) {
        if (page <= 0) {
            page = 1;
        }
        if (size <= 0) {
            size = 10;
        }
        if (queryPageRequest==null){
            queryPageRequest = new QueryPageRequest();
        }
        //条件值对象
        CmsPage cmsPage = new CmsPage();
        if (!StringUtils.isEmpty(queryPageRequest.getSiteId())){ //org.springframework.util.StringUtils;
            cmsPage.setSiteId(queryPageRequest.getSiteId());//站点id
        }
        if (!StringUtils.isEmpty(queryPageRequest.getTemplateId())){
            cmsPage.setTemplateId(queryPageRequest.getTemplateId());//模板id
        }
        if (!StringUtils.isEmpty(queryPageRequest.getPageAliase())){
            cmsPage.setPageAliase(queryPageRequest.getPageAliase());//页面别名
        }
        //条件匹配器（多用于模糊查询等）
        ExampleMatcher matcher = ExampleMatcher.matching()
            .withMatcher("pageAliase",ExampleMatcher.GenericPropertyMatchers.contains());

        //条件对象
        Example<CmsPage> example = Example.of(cmsPage,matcher);
        Page<CmsPage> all = cmsPageRepository.findAll(example,PageRequest.of(page-1, size));

        QueryResult queryResult = new QueryResult();
        queryResult.setList(all.getContent());//数据列表
        queryResult.setTotal(all.getTotalElements());//数据总记录数
        QueryResponseResult queryResponseResult = new QueryResponseResult(CommonCode.SUCCESS, queryResult);
        return queryResponseResult;
    }
}
```



#### 2.4.4 Controller

```java
package com.xuecheng.manage_cms.controller;

@RestController
@RequestMapping("/cms/page")
public class CmsPageController implements CmsPageControllerApi {
    @Autowired
    private CmsPageService cmsPageService;

    @Override
    @GetMapping("/list/{page}/{size}")
    public QueryResponseResult findList(@PathVariable int page, @PathVariable int size, QueryPageRequest queryPageRequest) {
        return cmsPageService.findList(page,size,queryPageRequest);
    }
}
```



## 3 接口开发==规范==

### 3.1 Api请求及响应规范

为了严格按照接口进行开发，提高效率，对请求及响应格式进行规范化。

- Get 请求时，采用key/value格式请求，SpringMVC可采用**基本类型**（`@PathVariable`）的变量接收，也可以采用**对象接收**（`@RequestParam`，没有参数名一致方便）。
- Post 请求时，可以提交form表单数据（`application/x-www-form-urlencoded`）和JSON数据（`Content-
  Type=application/json`），文件等多部件类型（`multipart/form-data`）三种数据格式，SpringMVC接收JSON数据
  使用`@RequestBody`注解解析请求的json数据。
- 响应结果统一信息为：是否**成功**、操作**代码**、**提示信息**及**自定义数据**。
- 响应结果统一格式为JSON。



### 3.2 Api定义约束

Api定义使用SpringMVC来完成，由于此接口后期将作为**微服务远程调用**使用，在定义接口时有如下限制：

* `@PathVariable` 统一指定参数名称，如：@PathVariable("id")
* `@RequestParam` 统一指定参数名称，如：@RequestParam（"id"）



## 4 页面查询接口==测试==

上边的代码是基于服务端编写接口，如果前端人员等待服务端人员将接口开发完毕再去开发前端内容这样做效率是非常低下的，所以**当接口定义完成**，可以**使用工具生成接口文档**，前端人员查看接口文档即可进行前端开发，这样前端和服务人员并行开发，大大提高了生产效率。

### 4.1 Swagger

OpenAPI规范（OpenAPI Specification 简称OAS）是Linux基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程，目前版本是V3.0，并且已经发布并开源在[github](https://github.com/OAI/OpenAPI-Specification)上。

[Swagger](https://swagger.io/)是全球最大的OpenAPI规范（OAS）API开发工具框架，支持从设计和文档到测试和部署的整个API生命周期的开发。

Spring Boot 可以集成Swagger，生成Swagger接口。

Swagger接口生成工作原理：

1. 系统启动，扫描到api工程中的Swagger2Configuration类
2. 在此类中指定了包路径如`com.xuecheng`，找到在此包下及子包下标记有@RestController注解的controller类
3. 根据controller类中的Swagger注解生成接口文档（也会扫描该类所实现的接口）
4. 启动cms服务工程，查看接口文档，请求：http://localhost:31001/swagger-ui.html

```xml
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.7.0</version>
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.7.0</version>
</dependency>
```

Swagger配置类

```java
package com.xuecheng.api.config;

@Configuration
@EnableSwagger2//开启！
public class Swagger2Configuration {
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(apiInfo())
            .select()
            .apis(RequestHandlerSelectors.basePackage("com.xuecheng"))//扫描该包中所有@RestController注解类的所有方法
            .paths(PathSelectors.any())
            .build();
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
            .title("学成网api文档")
            .description("学成网api文档")
            //.termsOfServiceUrl("/")
            .version("1.0")
            .build();
    }
}
```





### 4.2 Swagger常用注解

在Java类中添加Swagger的注解即可生成Swagger接口，常用Swagger注解如下：

* @**Api**：用在请求的**类**上，表示对类的说明
  * value "说明该类的用途、作用。没用，不显示"
  *  description "说明该类的用途、作用。显示"

* @**ApiOperation**：用在请求的**方法**上，说明方法的用途、作用 
  * value="说明方法的用途、作用"
* @ApiParam：单个参数描述
* @ApiResponse：HTTP响应其中1个描述
* @ApiResponses：HTTP响应整体描述
* @ApiIgnore：使用该注解忽略这个API
* @ApiError ：发生错误返回的信息
* @**ApiImplicitParam**：一个请求参数
* @**ApiImplicitParams**：多个请求参数
* @ApiModel：用对象来接收参数，不显示
* @**ApiModelProperty**：用**对象接收参数**时，**描述对象的一个字段**

@ApiImplicitParam属性：

|     属性     |  取值  |                     作用                      |
| :----------: | :----: | :-------------------------------------------: |
|  paramType   |        |                 查询参数类型                  |
|              |  path  |             以地址的形式提交数据              |
|              | query  |          直接跟参数完成自动映射赋值           |
|              |  body  |           以流的形式提交 仅支持POST           |
|              | header |        参数在request headers 里边提交         |
|              |  form  |        以form表单的形式提交 仅支持POST        |
|   dataType   |        | 参数的数据类型 只作为标志说明，并没有实际验证 |
|              |  Long  |                                               |
|              | String |                                               |
|     name     |        |                  接收参数名                   |
|    value     |        |              接收参数的意义描述               |
|   required   |        |                 参数是否必填                  |
|              |  true  |                     必填                      |
|              | false  |                    非必填                     |
| defaultValue |        |                    默认值                     |

可以写在接口上，也可以写在实现类上（怎么选则？？？）

```java
package com.xuecheng.api.cms;

@Api(value="cms页面管理接口",description = "cms页面管理接口，提供页面的增、删、改、查")
public interface CmsPageControllerApi {
    //页面查询
    @ApiOperation("分页查询页面列表")
    @ApiImplicitParams({
        @ApiImplicitParam(name="page",value = "页码",required=true,paramType="path",dataType="int"),
        @ApiImplicitParam(name="size",value = "每页记录数",required=true,paramType="path",dataType="int")
    })
    QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest);
}
```

用对象接收参数时，写模型上

```java
@Data
//由于继承了RequestData，父类有@Data注解，所以在注解该类@Data时报警告。不写可以在swaggerui看到，但不知道是否有其他影响
@EqualsAndHashCode(callSuper = true)
public class QueryPageRequest extends RequestData {

    //站点id
    @ApiModelProperty("站点id")
    private String siteId;
    //页面ID
    @ApiModelProperty("页面ID")
    private String pageId;
    //页面名称
    @ApiModelProperty("页面名称")
    private String pageName;
    //页面别名
    @ApiModelProperty("页面别名")
    private String pageAliase;
    //模版id
    @ApiModelProperty("模版id")
    private String templateId;
}
```





# 2 CMS 前端开发

## 1 系统管理前端工程导入

> CMS系统使用Vue-cli脚手架创建， Vue-cli是Vue官方提供的快速构建单页应用的脚手架，[github地址](https://github.com/vuejs/vue-cli)（有兴趣的同学可以参考官方指导使用vue-cli创建前端工程），本项目对 Vue-cli 创建的工程进行二次封装，下边介绍CMS工程的情况。

------

> 基于Vue-Cli创建的工程进行开发还需要在它基础上作一些封装，导入课程资料中提供Vue-Cli封装工程。将课程资料中的xc-ui-pc-sysmanage.7z拷贝到UI工程目录中，并解压，用WebStorm打开xc-ui-pc-sysmanage目录。
>
> 导入成功后，`npm run dev`可能会报错
>
> Module build failed Error Node Sass does not yet support your current environment OS X 64-bit with Unsupported runtime 59。原因是本机安装的Node是10版本，导入项目的Sass是4.7.2，不支持Node10。需要重装：
>
> `npm uninstall node-sass -D`
>
>  `npm install node-sass -D`

- `index.html`是模板文件。

- `package.json`

  记录了工程所有依赖，及脚本命令。开发使用：`npm run dev`；打包使用：`npm run build`

- `build/webpack.base.conf.js`

  就是webpack的webpack.config.js配置文件，在此文件中配置了入口文件及各种Loader。

  目录下有开发/生产/测试等等的配置打包方式

  webpack是通过vue-load解析.vue文件，通过css-load打包css文件等。

- `static`：与src的平级目录，此目录存放静态资源

  它与assets的区别在于，static目录中的文件不被webpack打包处理，会原样拷贝到dist目录下。

![1550563904871](images/1550563904871.png)

* **src目录下存放页面及js代码**

  * `main.js`

    工程的入口文件，在此文件中加载了很多第三方组件，如：Element-UI、Base64、VueRouter等。

  * `assets`：存放一些静态文件，如图片。

  * **`base`**：存放**基础组件**

    * api：基础api接口
    * component：基础组件，被各各模块都使用的组件
    * router：总的路由配置，加载各模块的路由配置文件。

  * `common`：工具类

  * `component`：组件目录，本项目不用。

  * `mock`：存放前端单元测试方法。

  * **`module`**：存放**各业务模块的页面和api方法**。下级目录以模块名命名，下边以cms举例：

    * cms/api：cms模块的api接口
    * cms/component：cms模块的组件
    * cms/page： cms模块的页面
    * cms/router：cms模块的路由配置

  * `statics`：存放第三方组件的静态资源

  * `vuex`：存放vuex文件，本项目不使用

  

## 2 单页面应用

单页Web应用（single page web application，**SPA**），就是只有**一张Web页面的应用**。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说**模块化的开发和设计显得相当重要**。

优点：

* **用户操作体验好**，用户不用刷新页面，整个交互过程都是通过**Ajax**来操作
* **适合前后端分离开发**，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲染。

缺点：

* **首页加载慢**。单页面应用会将js、 css打包成一个文件，在加载页面显示的时候加载打包文件，如果打包文件较大或者网速慢则用户体验不好。可以压缩。
* **SEO**（Search Engine Optimization）不友好。搜索引擎对JS支持不好，所以将大大减少搜索引擎对网站的收录

> 本项目的门户、课程介绍不采用单页面应用架构去开发，对于需要用户登录的管理系统采用单页面开发。



## 3 CMS前端页面查询开发

在**model**目录创建 cms模块的目录结构：api/componets/page/router

### 3.1 api

`cms/api`目录定义`cms.js`，实现**http请求服务端**页面查询接口。

```js
//public是对axios的工具类封装，定义了http请求方法
import http from './../../../base/api/public';

let sysConfig = require('@/../config/sysConfig');
let apiUrl = sysConfig.xcApiUrlPre;
import querystring from 'querystring'

export const page_list = (page, size, params) => {
  //将json对象转成key/value对
  let query = querystring.stringify(params);
  return http.requestQuickGet(apiUrl + '/cms/page/list/' + page + '/' + size + '?' + query)
};
```

由于前端服务`http://localhost:11000/`调用后端服务`http://localhost:31001/`，跨域！！！浏览器中控制台：

`No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin
'http://localhost:11000' is therefore not allowed access.`

原因：浏览器的**同源策略**不允许跨域访问，所谓同源策略是指**协议**、**域名**、**端口**都相同

解决：采用**proxyTable**解决。

* **vue-cli提供**的解决vue开发环境下跨域问题的方法，proxyTable的底层使用了[http-proxymiddleware](https://github.com/chimurai/http-proxy-middleware)，它是http代理中间件，它依赖node.js，基本原理是**用服务端代理解决浏览器跨域**。**后台服务之间访问不存在跨域问题**！！！

* `config/index.js`，proxyTable拦截所有`/api/cms`请求，并替换为`/cms`，利用Node.js来发送请求

  ```js
  proxyTable: {
      '/api/cms': {
          target: 'http://localhost:31001',
          pathRewrite: {
          	'^/api': ''
      	}
      }
  }
  ```



### 3.2 page

`.vue`文件结构如下

```vue
<template>
  <!--编写页码静态部分，即View部分。必须有个根元素否则vue报错-->
  <div></div>
</template>

<script>
  /*编写页面静态部分，即model及vm部分。*/
</script>

<style>
  /*编写页面样式，不是必须*/
</style>
```

本项目使用[Element-UI](http://element.eleme.io/#/zh-CN/component/installation)来构建界面，Element是一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。

新建`page_list.vue`

```vue
<template>
  <!--编写页码静态部分，即View部分。必须有个根元素否则vue报错-->
  <div>
    <!--下拉选择器，自定义查询-->
      <el-select v-model="params.siteId" placeholder="请选择站点">
        <el-option
          v-for="item in siteList"
          :key="item.siteId"
          :label="item.siteName"
          :value="item.siteId">
        </el-option>
      </el-select>
      页面别名：<el-input v-model="params.pageAliase"  style="width: 100px"></el-input>
    <el-button type="primary" size="small" @click="query">查询</el-button>
    <el-table
      :data="list"
      stripe
      style="width: 100%">
      <el-table-column type="index" width="60">
      </el-table-column>
      <el-table-column prop="pageName" label="页面名称" width="120">
      </el-table-column>
      <el-table-column prop="pageAliase" label="别名" width="120">
      </el-table-column>
      <el-table-column prop="pageType" label="页面类型" width="150">
      </el-table-column>
      <el-table-column prop="pageWebPath" label="访问路径" width="250">
      </el-table-column>
      <el-table-column prop="pagePhysicalPath" label="物理路径" width="250">
      </el-table-column>
      <el-table-column prop="pageCreateTime" label="创建时间" width="180">
      </el-table-column>
    </el-table>
    <el-pagination
      layout="prev, pager, next"
      :total="total"
      :page-size="params.size"
      :current-page="params.page"
      v-on:current-change="changePage"
      style="float:right">
    </el-pagination>
  </div>
</template>

<script>
  /*编写页面静态部分，即model及vm部分。*/
  import * as cmsApi from '../api/cms';

  export default {
    data() {
      return {
        list: [],
        siteList:[],
        total: 50,
        params: {
          page: 1,
          size: 10,
          siteId:'',
          pageAliase:''
        }
      }
    },
    methods: {
      query: function () {
        cmsApi.page_list(this.params.page, this.params.size,this.params)
          .then((response) => {
          this.total = response.queryResult.total;
          this.list = response.queryResult.list;
        })
      },
      changePage: function (page) {
        this.params.page = page;
        this.query()
      }
    },
    mounted: function () {
      this.query();
      //初始化站点列表。模拟数据，本应该请求后端来获取
      this.siteList = [
        {
          siteId:'5a751fab6abb5044e0d19ea1',
          siteName:'门户主站'
        },
        {
          siteId:'102',
          siteName:'测试站'
        }
      ]
    }

  }
</script>
<style>
  /*编写页面样式，不是必须*/
</style>
```

通常使用最多的是created和mounted两个钩子：

* **created**：vue实例已创建但是DOM元素还没有渲染生成。
* **mounted**：DOM元素渲染生成完成后调用。

### 3.3 router

创建`cms/router/index.js`，实现url访问到页面

```js
import Home from '@/module/home/page/home.vue';
import page_list from '@/module/cms/page/page_list.vue';

export default [{
    path: '/cms',
    component: Home,
    name: 'CMS内容管理',
    hidden: false,
    children: [{
        path: '/cms/page/list',
        component: page_list,
        name: '页面列表',
        hidden: false,
    }]
}]
```

在`base/router/index.js`导入cms模块的路由

```js
import Vue from 'vue';
import Router from 'vue-router';
Vue.use(Router);
// 定义路由配置
let routes = []
let concat = (router) => {
    routes = routes.concat(router)
}
//导入路由规则
import HomeRouter from '@/module/home/router';
import CmsRouter from '@/module/cms/router';
// 合并路由规则
concat(HomeRouter);
concat(CmsRouter);
export default routes;
```



## 4 前后端请求响应小节

![](images/前后端请求响应.png)



# 3 CMS 系统页面管理

## 1 自定义条件查询

在页面输入查询条件，查询符合条件的页面信息。查询条件如下：

* 站点Id：精确匹配
* 模板Id：精确匹配
* 页面别名：模糊匹配
* ......

Repository层不用变动，只需修改Service层。

### 1.1 Api

```java
@Api(value="cms页面管理接口",description = "cms页面管理接口，提供页面的增、删、改、查")
public interface CmsPageControllerApi {
    //页面查询
    @ApiOperation("分页查询页面列表")
    @ApiImplicitParams({
        @ApiImplicitParam(name="page",value = "页码",required=true,paramType="path",dataType="int"),
        @ApiImplicitParam(name="size",value = "每页记录数",required=true,paramType="path",dataType="int")
    })
    QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest);



    @ApiOperation("增加页面")
    CmsPageResult add(CmsPage cmsPage);//CmsPageResult包含CmsPage，和三个重要信息！

    @ApiOperation("根据id查询页面")
    CmsPage findById(String id);

    @ApiOperation("增加页面")
    CmsPageResult edit(String id,CmsPage cmsPage);//CmsPageResult包含CmsPage，和三个重要信息！
    
    @ApiOperation("删除页面")
    ResponseResult delete(String id);

}
```

### 1.2 Repository

```java
public interface CmsPageRepository extends MongoRepository<CmsPage,String> {

    //根据站点id、页面名称、页面访问路径查询
    CmsPage findBySiteIdAndPageNameAndPageWebPath(String siteId,String pageName,String pageWebPath);
}
```

### 1.3 Service

```java
@Service
public class CmsPageService {

    @Autowired
    private CmsPageRepository cmsPageRepository;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private CmsTemplateRepository cmsTemplateRepository;

    @Autowired
    private GridFsTemplate gridFsTemplate;

    @Autowired
    private GridFSBucket gridFSBucket;
    /**
     * 分页条件查询
     * @param page，页码，从1开始
     * @param size，每页记录数
     * @param queryPageRequest，查询条件
     * @return
     */
    public QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest) {
        if (page <= 0) {
            page = 1;
        }
        if (size <= 0) {
            size = 10;
        }
        if (queryPageRequest==null){
            queryPageRequest = new QueryPageRequest();
        }
        //条件值对象
        CmsPage cmsPage = new CmsPage();
        if (!StringUtils.isEmpty(queryPageRequest.getSiteId())){ //org.springframework.util.StringUtils;
            cmsPage.setSiteId(queryPageRequest.getSiteId());//站点id
        }
        if (!StringUtils.isEmpty(queryPageRequest.getTemplateId())){
            cmsPage.setTemplateId(queryPageRequest.getTemplateId());//模板id
        }
        if (!StringUtils.isEmpty(queryPageRequest.getPageAliase())){
            cmsPage.setPageAliase(queryPageRequest.getPageAliase());//页面别名
        }
        //条件匹配器（多用于模糊查询等）
        ExampleMatcher matcher = ExampleMatcher.matching()
            .withMatcher("pageAliase",ExampleMatcher.GenericPropertyMatchers.contains());

        //条件对象
        Example<CmsPage> example = Example.of(cmsPage,matcher);
        Page<CmsPage> all = cmsPageRepository.findAll(example,PageRequest.of(page-1, size));

        QueryResult queryResult = new QueryResult();
        queryResult.setList(all.getContent());//数据列表
        queryResult.setTotal(all.getTotalElements());//数据总记录数
        QueryResponseResult queryResponseResult = new QueryResponseResult(CommonCode.SUCCESS, queryResult);
        return queryResponseResult;
    }


    public CmsPageResult add(CmsPage cmsPage) {
        //校验页面是否存在，根据页面名称、站点Id、页面webpath查询
        CmsPage page = cmsPageRepository.findBySiteIdAndPageNameAndPageWebPath(cmsPage.getSiteId(), cmsPage.getPageName(), cmsPage.getPageWebPath());
        //先处理异常
        if (page != null) {
            ExceptionCast.cast(CmsCode.CMS_ADDPAGE_EXISTSNAME);//页面已存在
        }
        //再进行业务操作
        cmsPage.setPageId(null);//为了让id自增
        cmsPageRepository.save(cmsPage);
        return new CmsPageResult(CommonCode.SUCCESS, cmsPage);
    }


    //根据id查询页面
    public CmsPage findById(String id){
        Optional<CmsPage> optional = cmsPageRepository.findById(id);
        return optional.orElse(null);//if...else简写
    }

    //编辑页面
    public CmsPageResult edit(String id, CmsPage cmsPage) {
        CmsPage page = this.findById(id);
        if (page != null) {
            //更新所属站点
            page.setSiteId(cmsPage.getSiteId());
            //更新模板id
            page.setTemplateId(cmsPage.getTemplateId());
            //更新页面别名
            page.setPageAliase(cmsPage.getPageAliase());
            //更新页面名称
            page.setPageName(cmsPage.getPageName());
            //更新访问路径
            page.setPageWebPath(cmsPage.getPageWebPath());
            //更新物理路径
            page.setPagePhysicalPath(cmsPage.getPagePhysicalPath());
            //DataUrl
            page.setDataUrl(cmsPage.getDataUrl());
            //页面类型
            page.setPageType(cmsPage.getPageType());

            CmsPage save = cmsPageRepository.save(page);
            return new CmsPageResult(CommonCode.SUCCESS, save);

        }
        return new CmsPageResult(CommonCode.FAIL, null);
    }

    //删除页面
    public ResponseResult delete(String id){
        Optional<CmsPage> optional = cmsPageRepository.findById(id);
        if (optional.isPresent()){
            cmsPageRepository.deleteById(id);
            return new ResponseResult(CommonCode.SUCCESS);
        } else {
            return new ResponseResult(CommonCode.FAIL);
        }
    }

    //页面静态化方法，返回html内容
    public String getPageHtml(String pageId){
        //静态化程序远程请求DataUrl获取数据模型。
        Map model = getModelByPageId(pageId);
        if (model==null){
            //数据模型获取不到
            ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_DATAISNULL);
        }
        //静态化程序获取页面的模板信息
        String templateContent = getTemplateByPageId(pageId);
        if (StringUtils.isEmpty(templateContent)){
            //页面模板为空
            ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL);
        }
        //执行页面静态化
        String html = generateHtml(templateContent, model);
        return html;
    }

    private String generateHtml(String templateContent,Map model){
        //创建配置对象
        Configuration configuration = new Configuration(Configuration.getVersion());
        //创建模板加载器
        StringTemplateLoader stringTemplateLoader = new StringTemplateLoader();
        stringTemplateLoader.putTemplate("template",templateContent);
        //向configuration配置模板加载器
        configuration.setTemplateLoader(stringTemplateLoader);
        try {
            Template template = configuration.getTemplate("template");
            String html = FreeMarkerTemplateUtils.processTemplateIntoString(template, model);
            return html;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }


    private String getTemplateByPageId(String pageId) {
        //取出页面的信息
        CmsPage cmsPage = this.findById(pageId);
        if (cmsPage==null){
            //页面不存在
            ExceptionCast.cast(CommonCode.CMS_PAGE_NOTEXISTS);
        }
        //获取页面的模板id
        String templateId = cmsPage.getTemplateId();
        if (StringUtils.isEmpty(templateId)){
            //页面模板为空
            ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL);
        }
        //查询模板信息
        Optional<CmsTemplate> optional = cmsTemplateRepository.findById(templateId);
        if (optional.isPresent()){
            CmsTemplate cmsTemplate = optional.get();
            //获取模板文件id
            String templateFileId = cmsTemplate.getTemplateFileId();
            //从GridFS中取模板文件内容
            //根据文件id查询文件
            GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(templateFileId)));

            //打开一个下载流对象
            GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
            //创建GridFsResource对象，获取流
            GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream);
            //从流中取数据
            try {
                String content = IOUtils.toString(gridFsResource.getInputStream(), "UTF-8");
                return content;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }

    private Map getModelByPageId(String pageId){
        //取出页面的信息
        CmsPage cmsPage = this.findById(pageId);
        if (cmsPage==null){
            //页面不存在
            ExceptionCast.cast(CommonCode.CMS_PAGE_NOTEXISTS);
        }
        //取出页面的dataUrl
        String dataUrl = cmsPage.getDataUrl();
        if (StringUtils.isEmpty(dataUrl)){
            //页面dataUrl为空
            ExceptionCast.cast(CommonCode.CMS_GENERATEHTML_DATAURLISNULL);
        }
        //通过restTemplate请求dataUrl获取数据
        ResponseEntity<Map> entity = restTemplate.getForEntity(dataUrl, Map.class);
        return entity.getBody();
    }
}
```



### 1.4 Controller

```java
@RestController
@RequestMapping("/cms/page")
public class CmsPageController implements CmsPageControllerApi {
    @Autowired
    private CmsPageService cmsPageService;

    @Override
    @GetMapping("/list/{page}/{size}")
    public QueryResponseResult findList(@PathVariable("page") int page, @PathVariable("size") int size, QueryPageRequest queryPageRequest) {
        return cmsPageService.findList(page,size,queryPageRequest);
    }

    @Override
    @PostMapping("/add")
    public CmsPageResult add(@RequestBody CmsPage cmsPage) {
        return cmsPageService.add(cmsPage);
    }

    @Override
    @GetMapping("/get/{id}")
    public CmsPage findById(@PathVariable String id) {
        return cmsPageService.findById(id);
    }

    @Override
    @PutMapping("/edit/{id}")
    public CmsPageResult edit(@PathVariable String id, @RequestBody CmsPage cmsPage) {
        return cmsPageService.edit(id,cmsPage);
    }
    
    
}
```



### 1.5 前端

#### 1.5.1 page

page_list.vue

```vue
<template>
  <!--编写页码静态部分，即View部分。必须有个根元素否则vue报错-->
  <div>
    <!--查询表单-->
    <el-select v-model="params.siteId" placeholder="请选择站点">
      <el-option
        v-for="item in siteList"
        :key="item.siteId"
        :label="item.siteName"
        :value="item.siteId">
      </el-option>
    </el-select>
    页面别名：
    <el-input v-model="params.pageAliase" style="width: 100px"></el-input>
    <el-button type="primary" size="small" @click="query">查询</el-button>
    <!--router-link时vue提供的路由功能，用于在页面生成路由链接，最终在html渲染后就是a标签，
    to表示目标路由地址；其中path为路由地址，query为url后的参数-->
    <router-link class="mui-tab-item" :to="{
    path:'/cms/page/add/',
    query:{
      page:this.params.page,
      siteId:this.params.siteId
    }}">
      <el-button type="primary" size="small">添加</el-button>
    </router-link>
    <el-table
      :data="list"
      stripe
      style="width: 100%">
      <el-table-column type="index" width="60">
      </el-table-column>
      <el-table-column prop="pageName" label="页面名称" width="120">
      </el-table-column>
      <el-table-column prop="pageAliase" label="别名" width="80">
      </el-table-column>
      <el-table-column prop="pageType" label="页面类型" width="80">
      </el-table-column>
      <el-table-column prop="pageWebPath" label="访问路径" width="250">
      </el-table-column>
      <el-table-column prop="pagePhysicalPath" label="物理路径" width="250">
      </el-table-column>
      <el-table-column prop="pageCreateTime" label="创建时间" width="180">
      </el-table-column>
      <el-table-column label="操作" width="200">
        <template slot-scope="page">
          <el-button size="small" type="text" @click="edit(page.row.pageId)">编辑</el-button>
          <el-button size="small" type="text" @click="del(page.row.pageId)">删除</el-button>
          <el-button @click="preview(page.row.pageId)" type="text" size="small">页面预览</el-button>
        </template>
      </el-table-column>
    </el-table>
    <el-pagination
      layout="prev, pager, next"
      :total="total"
      :page-size="params.size"
      :current-page="params.page"
      v-on:current-change="changePage"
      style="float:right">
    </el-pagination>
  </div>
</template>

<script>
  /*编写页面静态部分，即model及vm部分。*/
  import * as cmsApi from '../api/cms';

  export default {
    data() {
      return {
        list: [],
        siteList: [],
        total: 50,
        params: {
          page: 1,
          size: 10,
          siteId: '',
          pageAliase: ''
        }
      }
    },
    methods: {
      query() {
        cmsApi.page_list(this.params.page, this.params.size, this.params)
          .then((response) => {
            this.total = response.queryResult.total;
            this.list = response.queryResult.list;
          })
      },
      changePage(page) {
        this.params.page = page;
        this.query()
      },
      //query只是为了返回传值，用户体验
      edit(pageId) {
        this.$router.push({
          path: '/cms/page/edit/' + pageId, query: {
            page: this.params.page,
            siteId: this.params.siteId
          }
        })
      },
      del(pageId) {
        this.$confirm('确认删除吗？', '提示', {}).then(() => {
          cmsApi.page_del(pageId).then(res => {
            if (res.success) {
              this.$message.success("删除成功");
              this.query();//刷新页面
            } else {
              this.$message.success("删除失败");

            }
          })
        })
      },
      preview(pageId){
        window.open('http://www.xuecheng.com/cms/preview/'+pageId);
      }
    },
    created() {
      //取出路由中参数，赋值给数据对象。由于URL中是字符串，需转换
      this.params.page = JSON.parse(this.$route.query.page || 1); //没值默认为1！！！
      this.params.siteId = this.$route.query.siteId || '';

    },
    mounted() {
      this.query();
      //初始化站点列表。模拟数据，本应该请求后端来获取
      this.siteList = [
        {
          siteId: '5a751fab6abb5044e0d19ea1',
          siteName: '门户主站'
        },
        {
          siteId: '102',
          siteName: '测试站'
        }
      ]
    }

  }
</script>

<style>
  /*编写页面样式，不是必须*/
</style>

```

page_add.vue

```vue
<template>
  <div>
    <!--element表单校验，:rules指定规则；ref表单校验判断引用-->
    <el-form   :model="pageForm" label-width="80px" :rules="pageFormRules" ref="pageForm" >
      <el-form-item label="所属站点" prop="siteId">
        <el-select v-model="pageForm.siteId" placeholder="请选择站点">
          <el-option
            v-for="item in siteList"
            :key="item.siteId"
            :label="item.siteName"
            :value="item.siteId">
          </el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="选择模版" prop="templateId">
        <el-select v-model="pageForm.templateId" placeholder="请选择">
          <el-option
            v-for="item in templateList"
            :key="item.templateId"
            :label="item.templateName"
            :value="item.templateId">
          </el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="页面名称" prop="pageName">
        <el-input v-model="pageForm.pageName" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="别名" prop="pageAliase">
        <el-input v-model="pageForm.pageAliase" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="访问路径" prop="pageWebPath">
        <el-input v-model="pageForm.pageWebPath" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="物理路径" prop="pagePhysicalPath">
        <el-input v-model="pageForm.pagePhysicalPath" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="数据Url" prop="dataUrl">
        <el-input v-model="pageForm.dataUrl" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="类型">
        <el-radio-group v-model="pageForm.pageType">
          <el-radio class="radio" label="0">静态</el-radio>
          <el-radio class="radio" label="1">动态</el-radio>
        </el-radio-group>
      </el-form-item>
      <el-form-item label="创建时间">
        <el-date-picker type="datetime" placeholder="创建时间" v-model="pageForm.pageCreateTime"></el-date-picker>
      </el-form-item>

    </el-form>
    <div slot="footer" class="dialog-footer">
      <el-button @click="go_back">返回</el-button>
      <el-button type="primary" @click.native="addSubmit" :loading="addLoading">提交</el-button>
    </div>
  </div>
</template>
<script>
  import * as cmsApi from '../api/cms'
  export default{
    data(){
      return {
        //模版列表
        templateList:[],
        addLoading: false,//加载效果标记
        //新增界面数据
        pageForm: {
          siteId:'',
          templateId:'',
          pageName: '',
          pageAliase: '',
          pageWebPath: '',
          dataUrl:'',
          pageParameter:'',
          pagePhysicalPath:'',
          pageType:'',
          pageCreateTime: new Date()
        },
        pageFormRules: {
          siteId:[
            {required: true, message: '请选择站点', trigger: 'blur'}
          ],
          templateId:[
            {required: true, message: '请选择模版', trigger: 'blur'}
          ],
          pageName: [
            {required: true, message: '请输入页面名称', trigger: 'blur'}
          ],
          pageWebPath: [
            {required: true, message: '请输入访问路径', trigger: 'blur'}
          ],
          pagePhysicalPath: [
            {required: true, message: '请输入物理路径', trigger: 'blur'}
          ]
        },
        siteList:[],
        goback_params: {
          page: this.$route.query.page,
          siteId:this.$route.query.siteId,
        }
      }
    },
    methods:{
      go_back(){
        //this当前实例，$route路由
        this.$router.push({
          path: '/cms/page/list', query: {
            page: this.$route.query.page,
            siteId:this.$route.query.siteId
          }
        })
      },
      addSubmit(){
        //利用element的表单校验，先检查是否都通过
        this.$refs.pageForm.validate((valid) => {
          if (valid) {
            //利用element提交确认弹框
            this.$confirm('确认提交吗？', '提示', {}).then(() => {
              this.addLoading = true;
              cmsApi.page_add(this.pageForm).then(res => {
                //解析后端返回的JSON数据
                if(res.success){
                  this.addLoading = false;
                  //element提供提示信息组件
                  this.$message({
                    message: '提交成功',
                    type: 'success'
                  });
                  //利用element提交成功后重置表单数据
                  this.$refs['pageForm'].resetFields();//.调用也可以

                }else if(res.message){
                  this.addLoading = false;
                  this.$message.error(res.message);
                }else{
                  this.addLoading = false;
                  this.$message.error('提交失败');
                }
              });
            });
          }
        });
      }
    },
    created() {
    },
    mounted(){

      //初始化站点列表。模拟数据，本应该从后端获取
      this.siteList = [
        {
          siteId:'5a751fab6abb5044e0d19ea1',
          siteName:'门户主站'
        },
        {
          siteId:'102',
          siteName:'测试站'
        }
      ];
      //模板列表
      this.templateList = [
        {
          templateId:'5a962b52b00ffc514038faf7',
          templateName:'首页'
        },
        {
          templateId:'5a962bf8b00ffc514038fafa',
          templateName:'轮播图'
        }
      ];
    }
  }
</script>
<style>

</style>
```

page_edit.vue

```vue
<template>
  <div>
    <el-form :model="pageForm" label-width="80px" :rules="pageFormRules" ref="pageForm" >
      <el-form-item label="所属站点" prop="siteId">
        <el-select v-model="pageForm.siteId" placeholder="请选择站点">
          <el-option
            v-for="item in siteList"
            :key="item.siteId"
            :label="item.siteName"
            :value="item.siteId">
          </el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="选择模版" prop="templateId">
        <el-select v-model="pageForm.templateId" placeholder="请选择">
          <el-option
            v-for="item in templateList"
            :key="item.templateId"
            :label="item.templateName"
            :value="item.templateId">
          </el-option>
        </el-select>
      </el-form-item>
      <el-form-item label="页面名称" prop="pageName">
        <el-input v-model="pageForm.pageName" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="别名" prop="pageAliase">
        <el-input v-model="pageForm.pageAliase" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="访问路径" prop="pageWebPath">
        <el-input v-model="pageForm.pageWebPath" auto-complete="off" ></el-input>
      </el-form-item>

      <el-form-item label="物理路径" prop="pagePhysicalPath">
        <el-input v-model="pageForm.pagePhysicalPath" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="数据Url" prop="dataUrl">
        <el-input v-model="pageForm.dataUrl" auto-complete="off" ></el-input>
      </el-form-item>
      <el-form-item label="类型">
        <el-radio-group v-model="pageForm.pageType">
          <el-radio class="radio" label="0">静态</el-radio>
          <el-radio class="radio" label="1">动态</el-radio>
        </el-radio-group>
      </el-form-item>
      <el-form-item label="创建时间">
        <el-date-picker type="datetime" placeholder="创建时间" v-model="pageForm.pageCreateTime"></el-date-picker>
      </el-form-item>

    </el-form>
    <div slot="footer" class="dialog-footer">
      <el-button @click="go_back">返回</el-button>
      <el-button type="primary" @click.native="editSubmit" :loading="addLoading">提交</el-button>
    </div>
  </div>
</template>
<script>
  import * as cmsApi from '../api/cms'
  export default{
    data(){
      return {
        //页面id
        pageId:'',
        //模版列表
        templateList:[],
        addLoading: false,//加载效果标记
        //新增界面数据
        pageForm: {
          siteId:'',
          templateId:'',
          pageName: '',
          pageAliase: '',
          pageWebPath: '',
          dataUrl:'',
          pageParameter:'',
          pagePhysicalPath:'',
          pageType:'',
          pageCreateTime: new Date()
        },
        pageFormRules: {
          siteId:[
            {required: true, message: '请选择站点', trigger: 'blur'}
          ],
          templateId:[
            {required: true, message: '请选择模版', trigger: 'blur'}
          ],
          pageName: [
            {required: true, message: '请输入页面名称', trigger: 'blur'}
          ],
          pageWebPath: [
            {required: true, message: '请输入访问路径', trigger: 'blur'}
          ],
          pagePhysicalPath: [
            {required: true, message: '请输入物理路径', trigger: 'blur'}
          ]
        },
        siteList:[]
      }
    },
    methods:{
      go_back(){
        this.$router.push({
          path: '/cms/page/list', query: {
            page: this.$route.query.page,
            siteId:this.$route.query.siteId
          }
        })
      },
      editSubmit(){
        this.$refs.pageForm.validate((valid) => {
          if (valid) {
            this.$confirm('确认提交吗？', '提示', {}).then(() => {
              this.addLoading = true;
              cmsApi.page_edit(this.pageId,this.pageForm).then((res) => {
                  console.log(res);
                if(res.success){
                  this.addLoading = false;
                  this.$message({
                    message: '提交成功',
                    type: 'success'
                  });
                  //返回
                  this.go_back();

                }else{
                  this.addLoading = false;
                  this.$message.error('提交失败');
                }
              });
            });
          }
        });
      }

    },
    created: function () {
      //页面参数通过路由传入，这里通过this.$route.params来获取
      this.pageId=this.$route.params.pageId;
      //根据主键查询页面信息
      cmsApi.page_get(this.pageId).then((res) => {
        console.log(res);
        if(res){
          this.pageForm = res;
        }
      });
    },
    mounted:function(){

      //初始化站点列表
      this.siteList = [
        {
          siteId:'5a751fab6abb5044e0d19ea1',
          siteName:'门户主站'
        },
        {
          siteId:'102',
          siteName:'测试站'
        }
      ]
      //模板列表
      this.templateList = [
        {
          templateId:'5a962b52b00ffc514038faf7',
          templateName:'首页'
        },
        {
          templateId:'5a962bf8b00ffc514038fafa',
          templateName:'轮播图'
        }
      ]
    }
  }
</script>
<style>

</style>
```







#### 1.5.2 router

创建`cms/router/index.js`，实现url访问到页面

```js
import Home from '@/module/home/page/home.vue';
import page_list from '@/module/cms/page/page_list.vue';
import page_add from "@/module/cms/page/page_add";
import page_edit from "@/module/cms/page/page_edit";

export default [{
    path: '/cms',
    component: Home,
    name: 'CMS内容管理',
    hidden: false,
    children: [{path: '/cms/page/list',component: page_list,name: '页面列表',hidden: false},
               {path: '/cms/page/add',component: page_add,name: '添加页面',hidden: true},
               {path: '/cms/page/edit/:pageId',component: page_edit,name: '修改页面',hidden: true}
              ]
}]
```

在`base/router/index.js`导入cms模块的路由

```js
import Vue from 'vue';
import Router from 'vue-router';
Vue.use(Router);
// 定义路由配置
let routes = []
let concat = (router) => {
    routes = routes.concat(router)
}
//导入路由规则
import HomeRouter from '@/module/home/router';
import CmsRouter from '@/module/cms/router';
// 合并路由规则
concat(HomeRouter);
concat(CmsRouter);
export default routes;
```



#### 1.5.3 api

```js
//public是对axios的工具类封装，定义了http请求方法
import http from './../../../base/api/public';

let sysConfig = require('@/../config/sysConfig');
let apiUrl = sysConfig.xcApiUrlPre;
import querystring from 'querystring'

//分页条件查询
export const page_list = (page, size, params) => {
  //将json对象转成key/value对
  let query = querystring.stringify(params);
  return http.requestQuickGet(apiUrl + '/cms/page/list/' + page + '/' + size + '?' + query)
};

//添加页面
export const page_add = params =>http.requestPost(apiUrl+'/cms/page/add',params);
//根据id查找页面
export const page_get = id=>  http.requestQuickGet(apiUrl+'/cms/page/get/'+id);
//修改页面
export const page_edit = (id,params)=>http.requestPut(apiUrl+'/cms/page/edit/'+id,params);
//删除页面
export const page_del = id=>http.requestDelete(apiUrl+'/cms/page/del/'+id);
```







## 2 添加页面

前后端代码查看第3章

路由到add页面，并为了返回体验，传递当前页和查询条件。在add页返回参数并路由到list页。。。

`$route.query.xxx`获取`?`后的参数

`$route.params.xxx`获取path中参数

`$route`和`​$router`区别！！！



## 3 修改页面



## 4 删除页面



## 5 异常处理

### 5.1 异常处理的问题分析

分析如下代码

```java
public CmsPageResult add(CmsPage cmsPage){
    //校验页面是否存在，根据页面名称、站点Id、页面webpath查询
    CmsPage page = cmsPageRepository.findBySiteIdAndPageNameAndPageWebPath(cmsPage.getSiteId(), cmsPage.getPageName(), cmsPage.getPageWebPath());
    if (page==null){
        cmsPage.setPageId(null);//为了让id自增
        cmsPageRepository.save(cmsPage);
        return new CmsPageResult(CommonCode.SUCCESS,cmsPage);
    } else {
        return new CmsPageResult(CommonCode.FAIL,null);
    }
}
```

问题：

- 只要操作不成功仅向用户返回“错误代码：11111，失败信息：操作失败”，无法区别具体的错误信息。
- service方法在执行过程出现异常在哪捕获？在service中需要都加try/catch，如果在controller也需要添加try/catch，代码冗余严重且不易维护。

解决方案：

* 在Service方法中的编码顺序是**先校验判断**，有问题则抛出具体的异常信息，**最后执行具体的业务操作**，返回成功信息。
* 在**统一异常处理类**中去**捕获**异常，无需controller捕获异常，**向用户返回统一规范的响应信息**



### 5.2 异常处理流程

系统对异常的处理使用统一的异常处理流程：

* **自定义异常类型**，继承RuntimeException
* 自定义**错误代码及错误信息**。
* 对于**可预知的异常由程序员在代码中主动抛出**，由SpringMVC统一捕获。
  可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较
  齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。
* 对于**不可预知的异常（运行时异常）**由**SpringMVC统一捕获**Exception类型的异常。
  不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为
  RuntimeException类型（运行时异常）。
* 可预知的异常及不可预知的运行时异常**最终会采用统一的信息格式**（错误代码+错误信息）来表示，最终也会随
  请求响应为JSON给客户端。

异常抛出及处理流程：

![1550681223850](images/1550681223850.png)

1. 在**controller、service、dao中程序员抛出自定义异常**；springMVC框架抛出框架异常类型
2. 统一由**异常捕获类捕获异常**，并进行处理
3. 捕获到自定义异常则直接取出错误代码及错误信息，响应给用户。
4. 捕获到非自定义异常类型首先从Map中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误信息并响应给用户，如果从Map中找不到异常类型所对应的错误代码则统一为99999错误代码并响应给用户。
5. 将错误代码及错误信息**以JSON格式响应给用户**



### 5.3 可预知异常处理

#### 5.3.1 自定义异常类

在common工程定义异常类型

```java
public class CustomException extends RuntimeException {

    private ResultCode resultCode;

    //由构造方法传入
    public CustomException(ResultCode resultCode) {
        this.resultCode = resultCode;
    }

    //提供get方法获取具体信息

    public ResultCode getResultCode() {
        return resultCode;
    }
}
```



#### 5.3.2 异常抛出类

只是封装了`throw new xxx`

```java
public class ExceptionCast {
    
    public static void cast(ResultCode resultCode){
        throw new CustomException(resultCode);
    }
}
```



#### 5.3.3 异常捕获类

```java
@ControllerAdvice//控制器增强
public class ExceptionCatch {

    private static final Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch.class);

    //使用EXCEPTIONS存放异常类型和错误代码的映射，ImmutableMap的特点的一旦创建不可改变，并且线程安全
    private static ImmutableMap<Class<? extends Throwable>, ResultCode> EXCEPTIONS;
    //使用builder来构建一个异常类型和错误代码的异常
    protected static ImmutableMap.Builder<Class<? extends Throwable>, ResultCode> builder =
        ImmutableMap.builder();

    //在这里加入一些基础的异常类型判断。这里只添加了一个示例
    static {
        builder.put(HttpMessageNotReadableException.class, CommonCode.INVALID_PARAM);
    }

    @ExceptionHandler(CustomException.class)//捕获 CustomException异常
    @ResponseBody//返回JSON数据
    public ResponseResult customException(CustomException e) {
        LOGGER.error("catch exception:\n" + e.getMessage(), e);//catch到异常记录日志
        return new ResponseResult(e.getResultCode());
    }

    @ExceptionHandler(Exception.class)//捕获 Exception异常
    @ResponseBody//返回JSON数据
    public ResponseResult exception(Exception e) {
        LOGGER.error("catch exception:\n" + e.getMessage(), e);//catch到异常记录日志
        if (EXCEPTIONS == null) {
            EXCEPTIONS = builder.build();
        }
        ResponseResult responseResult;
        ResultCode resultCode = EXCEPTIONS.get(e.getClass());
        if (resultCode != null) {
            responseResult = new ResponseResult(resultCode);
        } else {
            responseResult = new ResponseResult(CommonCode.SERVER_ERROR);//99999异常
        }
        return responseResult;
    }
}
```



还需再启动类上注解要扫描异常类所在包

```java
@ComponentScan("com.xuecheng.framework")//扫描common工程下的类，包括异常类
```



#### 5.3.4 测试

后端代码如service/controller/dao修改查看3.1



### 5.4 不可预知异常处理

#### 5.4.1 定义异常捕获方法

使用postman测试后端添加页面方法，不输入cmsPost信息，提交，报错信息如下：`org.springframework.http.converter.HttpMessageNotReadableException`

此异常是springMVC在进行参数转换时报的错误。响应状态码400等信息在客户端是无法解析的

在异常捕获类中添加对Exception类的捕获。代码查看上面的



#### 5.4.2 异常捕获方法

针对上边的问题其解决方案是：

1. 我们在map中配置HttpMessageNotReadableException和错误代码。
2. 在异常捕获类中对Exception异常进行捕获，并从map中获取异常类型对应的错误代码，如果存在错误代码则返回此错误，否则统一返回99999错误。

具体的开发实现如下：

1. 在通用错误代码类CommCode中配置非法参数异常。用于添加到map集合中

   ```java
   INVALID_PARAM(false,10003,"非法参数！"),
   ```

2. 在异常捕获类中配置 HttpMessageNotReadableException 为非法参数异常。代码查看上面的5.3.3





# 4 页面静态化—页面仅预览

## 1 页面静态化需求

1. 为什么要进行页面管理？

   本项目cms系统的功能就是根据运营需要，对门户等子系统的部分页面进行管理，从而实现快速根据用户需求修改页面内容并上线的需求

2. 如何修改页面的内容？

   在开发中修改页面内容是需要人工编写html及JS文件，**CMS系统是通过程序自动化的对页面内容进行修改**，通过页面静态化技术生成html页面

3. 如何对页面进行静态化？

   一个页面等于模板加数据，在添加页面的时候我们选择了页面的模板。页面静态化就是将页面模板和数据通过技术手段将二者合二为一，生成一个html网页文件

业务**流程**如下：

1. 获取**模型数据**
2. **制作模板**
3. 对页面进行**静态化**
4. 将静态化生成的html页面存放**文件系统**中
5. 将存放在文件系统的html文件**发布到服务器**



## 2 页面静态化

### 2.1 页面静态化流程

如何获取页面的数据模型？

CMS管理了各种页面，CMS对页面进行静态化时需要数据模型，但是CMS并不知道每个页面的数据模型的具体内容，它只管执行静态化程序便可对页面进行静态化，所以CMS静态化程序需要通过一种通用的方法来获取数据模型。

在编辑页面信息时指定一个DataUrl，此**DataUrl**便是获取数据模型的Url，它基于Http方式，CMS对页面进行静态化时会从页面信息中读取DataUrl，通过Http远程调用的方法请求DataUrl获取数据模型。若此页面是轮播图页面，它的DataUrl由开发轮播图管理的程序员提供。同理精品课程推荐页面、课程详情页面也一样。

![1550754095049](images/1550754095049.png)

### 2.2 数据模型

#### 2.2.1 轮播图DataUrl接口

##### 1、需求分析

CMS中有轮播图管理、精品课程推荐的功能，以轮播图管理为例说明：轮播图管理是通过可视化的操作界面由管理员指定轮播图片地址，最后将轮播图图片地址保存在**cms_config**集合中。针对首页的轮播图信息、精品推荐等信息的获取统一提供一个Url供静态化程序调用，这样我们就知道了轮播图页面、精品课程推荐页面的DataUrl，管理在页面配置中将此Url配置在页面信息中。

本小节开发一个查询轮播图、精品推荐信息的接口，此接口**供静态化程序调用获取数据模型**

##### 2、接口定义

轮播图信息、精品推荐等信息存储在MongoDB的**cms_config**集合中。

**cms_config有固定的数据结构如下：**

```java
@Data
@Document(collection = "cms_config")
public class CmsConfig {
    @Id
    private String id;//主键
    private String name;//数据模型的名称
    private List<CmsConfigModel> model;//数据模型项目
}
```

其中数据模型项目内容如下：

```java
@Data
public class CmsConfigModel {
    private String key;//主键
    private String name;//项目名称
    private String url;//项目url
    private Map mapValue;//项目复杂值
    private String value;//项目简单值
}
```

**根据ID查询配置信息**，定义接口如下：

```java
@Api(value="cms配置管理接口",description = "cms配置管理接口，提供数据模型的管理、查询接口")
public interface CmsConfigControllerApi {

    @ApiOperation("根据id查询CMS配置信息")
    CmsConfig getModel(String id);
}
```

##### 3、Dao

```java
public interface CmsConfigRepository extends MongoRepository<CmsConfig,String> {
}
```

##### 4、service

```java
@Service
public class CmsConfigService {

    @Autowired
    private CmsConfigRepository cmsConfigRepository;

    public CmsConfig getModel(String id){
        Optional<CmsConfig> optional = cmsConfigRepository.findById(id);
        return optional.orElse(null);//简写形式
    }
}
```

##### 5、controller

```java
@RestController
@RequestMapping("/cms/config")
public class CmsConfigController implements CmsConfigControllerApi {

    @Autowired
    private CmsConfigService cmsConfigService;

    @Override
    @GetMapping("/getmodel/{id}")
    public CmsConfig getModel(@PathVariable String id) {
        return cmsConfigService.getModel(id);
    }
}
```

利用Swagger或PostMan测试成功http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f



#### 2.2.2 远程请求接口RestTemplate

SpringMVC提供 **RestTemplate请求http接口**，RestTemplate的底层可以使用第三方的http客户端工具实现http 的请求，常用的http客户端工具有Apache HttpClient、**OkHttpClient**等，本项目使用OkHttpClient完成http请求，原因也是因为它的性能比较出众。

依赖

```xml
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
</dependency>
```

配置RestTemplate。可以在启动类中配置

```java
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
}
```

测试RestTemplate。根据url获取数据，并转为map格式。

```java
@Autowired
private RestTemplate restTemplate;
@Test
public void testRestTemplate(){
    ResponseEntity<Map> forEntity =
        restTemplate.getForEntity("http://localhost:31001/cms/config/get/5a791725dd573c3574ee333f",Map.class);
    System.out.println(forEntity);
}
```

> 需要修改cms_config集合中图片的地址用nginx中静态页面的图片替代，否则查看不到

### 2.3 模板管理（手动\^_^）

#### 2.3.1 模板管理业务流程

CMS提供模板管理功能，业务流程如下：

![1550759950705](images/1550759950705.png)

1. 要增加新模板首先需要制作模板，模板的内容就是Freemarker ftl模板内容。

2. 通过模板管理模块功能新增模板、修改模板、删除模板。

3. 模板信息存储在MongoDB数据库，其中**模板信息**存储在**cms_template**集合中，模板文件存储在**GridFS**文件系统中。

   templateFileId是模板文件的ID，此ID对应GridFS文件系统中文件ID

#### 2.3.2 模板制作

##### 1、编写模板文件

在门户的静态工程目录有**轮播图的静态页面**，路径是：`/include/index_banner.html`，只需改为ftl，并遍历图片即可

##### 2、模板测试RestTemplate

```java
@RequestMapping("/test2")
public String freemarker2(Map<String, Object> map) {
    ResponseEntity<Map> entity = restTemplate.getForEntity("http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f", Map.class);
    System.out.println(entity.getBody());
    map.putAll(entity.getBody());
    return "index_banner";
}
```

RestTemplate获取的数据结构截取如下：

```json
"name"  : "xxx"
"model" : [
    {
        "key" : "banner1", 
        "name" : "轮播图1地址", 
        "value" : "http://www.xuecheng.com/img/widget-bannerB.jpg"
    },
```



#### 2.3.3 GridFS研究

[GridFS](https://docs.mongodb.com/manual/core/gridfs/)是MongoDB提供的用于持久化存储文件的模块，CMS使用MongoDB存储数据，使用GridFS可以快速集成开发。

它的工作原理是：在GridFS存储文件是将文件分块存储，文件会按照256KB的大小分割成多个块进行存储，GridFS使用两个集合
（collection）存储文件，一个集合是`chunks`, 用于存储文件的**二进制数据**；一个集合是`files`，用于存储文件的**元数据**信息（文件名称、块大小、上传时间等信息）。从GridFS中读取文件要对文件的各各块进行组装、合并。

##### 1、GridFS存文件测试

向测试程序注入GridFsTemplate（直接使用！不用配置Bean）

```java
//存文件
@Test
public void testStore() throws FileNotFoundException {
    //定义file
    File file =new File("d:/index_banner.ftl");
    //定义fileInputStream
    FileInputStream fileInputStream = new FileInputStream(file);
    ObjectId objectId = gridFsTemplate.store(fileInputStream, "index_banner.ftl");
    System.out.println(objectId);
}
```

存储原理说明：

文件存储成功得到一个文件id，是`fs.files`集合中的主键。可以通过文件id查询`fs.chunks`表中的记录，得到文件的内容。



##### 2、GridFS读文件测试

在config包中定义Mongodb的配置类，GridFSBucket用于打开下载流对象，如下：

```java
@Configuration
public class MongoConfig {
    @Value("${spring.data.mongodb.database}")
    String db;
    @Bean
    public GridFSBucket getGridFSBucket(MongoClient mongoClient){
        MongoDatabase database = mongoClient.getDatabase(db);
        GridFSBucket bucket = GridFSBuckets.create(database);
        return bucket;
    }
}
```

测试代码如下

```java
@Autowired
GridFSBucket gridFSBucket;

//取文件
@Test
public void queryFile() throws IOException {
    //根据文件id查询文件
    GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is("5c6ec434eca668357c802175")));
    //打开一个下载流对象
    GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
    //创建GridFsResource对象，获取流
    GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream);
    //从流中取数据
    String content = IOUtils.toString(gridFsResource.getInputStream(), "utf-8");
    System.out.println(content);

}
```



##### 3、GridFS删除文件测试

```java
//删除文件
@Test
public void testDelFile() throws IOException {
    //根据文件id删除fs.files和fs.chunks中的记录
    gridFsTemplate.delete(Query.query(Criteria.where("_id").is("5c6ec434eca668357c802175")));
}
```



#### 2.3.4 模板存储（手动\^_^）

根据模板管理的流程，最终将模板信息存储到MongoDB的cms_template中，将模板文件存储到GridFS中。

模板管理功能在课堂中不再讲解，教学中手动向cms_template及GridFS中存储模板

添加模板：使用GridFS测试代码存储模板文件到GridFS，并得到文件id。向cms_template添加记录

删除模板：使用GridFS测试代码根据文件id删除模板文件，根据模板id删除cms_template中的记录

修改模板信息：使用Studio 3T修改cms_template中的记录

修改模板文件：通过Studio 3T修改模板文件(`fs.chunks`，此方法限文件小于256K)，先找到模板文件，再导入进去



### 2.4 静态化测试（*）

上边章节完成了数据模型和模板管理的测试，下边测试整个页面静态化的流程，流程如下：

1、填写页面DataUrl，将此字段保存到cms_page集合中。

2、静态化程序获取页面的DataUrl

3、静态化程序远程请求DataUrl获取数据模型。

4、静态化程序获取页面的模板信息

5、执行页面静态化

静态化程序。如下代码应放入3.1中service

```java
//页面静态化方法，返回html内容
public String getPageHtml(String pageId){
    //静态化程序远程请求DataUrl获取数据模型。
    Map model = getModelByPageId(pageId);
    if (model==null){
        //数据模型获取不到
        ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_DATAISNULL);
    }
    //静态化程序获取页面的模板信息
    String templateContent = getTemplateByPageId(pageId);
    if (StringUtils.isEmpty(templateContent)){
        //页面模板为空
        ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL);
    }
    //执行页面静态化
    String html = generateHtml(templateContent, model);
    return html;
}

private String generateHtml(String templateContent,Map model){
    //创建配置对象
    Configuration configuration = new Configuration(Configuration.getVersion());
    //创建模板加载器
    StringTemplateLoader stringTemplateLoader = new StringTemplateLoader();
    stringTemplateLoader.putTemplate("template",templateContent);
    //向configuration配置模板加载器
    configuration.setTemplateLoader(stringTemplateLoader);
    try {
        Template template = configuration.getTemplate("template");
        String html = FreeMarkerTemplateUtils.processTemplateIntoString(template, model);
        return html;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}


private String getTemplateByPageId(String pageId) {
    //取出页面的信息
    CmsPage cmsPage = this.findById(pageId);
    if (cmsPage==null){
        //页面不存在
        ExceptionCast.cast(CommonCode.CMS_PAGE_NOTEXISTS);
    }
    //获取页面的模板id
    String templateId = cmsPage.getTemplateId();
    if (StringUtils.isEmpty(templateId)){
        //页面模板为空
        ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL);
    }
    //查询模板信息
    Optional<CmsTemplate> optional = cmsTemplateRepository.findById(templateId);
    if (optional.isPresent()){
        CmsTemplate cmsTemplate = optional.get();
        //获取模板文件id
        String templateFileId = cmsTemplate.getTemplateFileId();
        //从GridFS中取模板文件内容
        //根据文件id查询文件
        GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(templateFileId)));
        //打开一个下载流对象
        GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
        //创建GridFsResource对象，获取流
        GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream);
        //从流中取数据
        try {
            String content = IOUtils.toString(gridFsResource.getInputStream(), "UTF-8");
            return content;
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}

private Map getModelByPageId(String pageId){
    //取出页面的信息
    CmsPage cmsPage = this.findById(pageId);
    if (cmsPage==null){
        //页面不存在
        ExceptionCast.cast(CommonCode.CMS_PAGE_NOTEXISTS);
    }
    //取出页面的dataUrl
    String dataUrl = cmsPage.getDataUrl();
    if (StringUtils.isEmpty(dataUrl)){
        //页面dataUrl为空
        ExceptionCast.cast(CommonCode.CMS_GENERATEHTML_DATAURLISNULL);
    }
    //通过restTemplate请求dataUrl获取数据
    ResponseEntity<Map> entity = restTemplate.getForEntity(dataUrl, Map.class);
    return entity.getBody();
}
```







## 3 页面预览

### 3.1 页面预览开发

#### 3.1.1 需求分析

页面在发布前增加页面预览的步骤，方便用户检查页面内容是否正确。（内部就是执行页面静态化，返回html代码）：

1、用户进入cms前端，点击“页面预览”在浏览器请求cms页面预览链接。

2、cms根据页面id查询DataUrl并远程请求DataUrl获取数据模型。

3、cms根据页面id查询页面模板内容

4、cms执行页面静态化。

5、cms将静态化内容响应给浏览器。

6、在浏览器展示页面内容，实现页面预览的功能。



#### 3.1.2 搭建环境

在CMS服务中加入freemarker的依赖，并配置

```yaml
spring:
  freemarker:
    cache: false #关闭模板缓存，方便测试
    settings:
      template_update_delay: 0
```



#### 3.1.3 Controller

调用service的静态化方法，将静态化内容通过**response**输出到浏览器显示

```java
@Controller//需要Response输出
public class CmsPagePreviewController extends BaseController {

    @Autowired
    private CmsPageService cmsPageService;

    //根据页面id来生成静态页面内容
    @GetMapping("/cms/preview/{pageId}")
    public void preview(@PathVariable("pageId") String pageId) {
        String pageHtml = cmsPageService.getPageHtml(pageId);
        if (!StringUtils.isEmpty(pageHtml)){
            try {
                response.getOutputStream().write(pageHtml.getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

访问http://localhost:31001/cms/preview/5a795ac7dd573c04508f3a56即可看到轮播图

### 3.2 页面预览测试

#### 3.2.1 配置Nginx代理

为了通过nginx请求静态资源（css、图片等），通过nginx代理进行页面预览。

在www.xuecheng.com虚拟主机配置：

```nginx
#后端nginx集群cms页面预览
location /cms/preview/ {
	proxy_pass http://cms_server_pool/cms/preview/;
}
```

配置cms_server_pool将请求转发到cms

```nginx
#后端nginx集群cms页面预览
upstream cms_server_pool{
	server 127.0.0.1:31001 weight=10;
}
```

访问http://www.xuecheng.com/cms/preview/5a795ac7dd573c04508f3a56即可看到轮播图



#### 3.2.2 添加“页面预览”链接

修改page_list.vue，添加preview方法。利用`window.open('url')`实现预览。代码查看3.1





# 5 消息队列—RabbitMQ

## 1 页面发布

![1550825377029](images/1550825377029.png)

业务流程如下：

1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。

2、cms页面发布接口执行页面静态化，并将静态化页面(html文件)存储至GridFS中。

3、静态化成功后，向消息队列发送页面发布的消息。页面发布的最终目标是将页面发布到服务器。**通过消息队列将页面发布的消息发送给各个服务器**。

3、消息队列负责将消息发送给各个服务器上部署的Cms Client(Cms客户端)。在服务器上部署Cms Client(Cms客户端)，客户端接收消息队列的通知。

4、每个接收到页面发布消息的Cms Client从GridFS获取Html页面文件，并**将Html文件存储在本地服务器**。CmsClient根据页面发布消息的内容请求GridFS获取页面文件，存储在本地服务器。



## 2 RabbitMQ

> 查看Spring Boot中笔记



# 6 页面真发布—课程管理

## 1 页面发布

### 1.1 技术方案

本项目使用MQ实现页面发布的技术方案如下：

![1550989837755](images/1550989837755.png)

技术**方案**说明：

1、平台包括**多个站点**，页面归属不同的站点。

2、发布一个页面应将该页面**发布到所属站点的服务器**上。

3、每个站点服务器部署**cms client**程序，并与**交换机绑定**，绑定时指定**站点Id**为**routingKey**，就可以实现cms client只能接收到所属站点的页面发布消息。

4、页面发布程序向MQ发布消息时指定页面所属站点Id为routingKey，将该页面发布到它所在服务器上的cms client。

------

页面发布流程图如下：

![1550994071959](images/1550994071959.png)





### 1.2 页面发布生产方

#### 1.2.1 需求分析

管理员通过 cms系统发布“页面发布”的消费，cms系统作为页面发布的生产方。需求如下：

1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。

2、cms页面发布接口执行页面静态化，并将静态化页面存储至GridFS中。

3、静态化成功后，向消息队列发送页面发布的消息。

​	1） 获取页面的信息及页面所属站点ID。

​	2） 设置消息内容为页面ID。（采用json格式，方便日后扩展）

​	3） 发送消息给ex_cms_postpage交换机，并将**站点ID**作为**routingKey**。



#### 1.2.2 RabbitMQ配置

amqp的起步依赖

在application.yml中配置Rabbitmq的连接参数

```yaml
rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
    virtualHost: /
```

RabbitMQConfig配置：

由于cms作为页面发布方要面对很多不同站点的服务器，面对很多页面发布队列，所以这里不再配置队列，只需要配置交换机即可

```java
@Configuration
public class RabbitMQConfig {

    //交换机的名称
    public static final String EX_ROUTING_CMS_POSTPAGE="ex_routing_cms_postpage";

    //交换机配置使用direct类型，routing。durable为持久化，重启不删除
    @Bean(EX_ROUTING_CMS_POSTPAGE)
    public Exchange EXCHANGE_TOPICS_INFORM() {
        return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build();
    }
}
```



#### 1.2.3 Api接口

```java
@ApiOperation("页面发布")
ResponseResult post(String id);
```



#### 1.2.4 Service

CmsPageService中添加代码：

```java
//页面发布
public ResponseResult post(String pageId){
    //执行页面静态化
    String content = this.getPageHtml(pageId);
    //将HTML页面存储到GridFS中
    CmsPage cmsPage = this.saveHtml(pageId, content);
    //向MQ发消息
    this.sendPostPage(pageId);
    return new ResponseResult(CommonCode.SUCCESS);

}

//向mq 发送消息
private void sendPostPage(String pageId){
    //创建消息对象并转为JSON字符串
    Map<String,Object> map = new HashMap();
    map.put("pageId",pageId);
    String jsonString = JSON.toJSONString(map);
    //发送MQ
    CmsPage cmsPage = this.findById(pageId);//先得到页面信息
    if (cmsPage == null){
        ExceptionCast.cast(CommonCode.INVALID_PARAM);
    }
    String siteId = cmsPage.getSiteId();//站点id作为routingKey
    rabbitTemplate.convertAndSend(RabbitMQConfig.EX_ROUTING_CMS_POSTPAGE,siteId,jsonString);

}

//保存HTML到GridFS中
private CmsPage saveHtml(String pageId,String content){
    CmsPage cmsPage = this.findById(pageId);//先得到页面信息
    if (cmsPage == null){
        ExceptionCast.cast(CommonCode.INVALID_PARAM);
    }
    InputStream inputStream = null;
    ObjectId objectId = null;
    try {
        //将htmlContent内容转成输入流
        inputStream = IOUtils.toInputStream(content, "UTF-8");
        //将html文件内容保存到GridFS
        objectId = gridFsTemplate.store(inputStream, this.findById(pageId).getPageName());

    } catch (IOException e) {
        e.printStackTrace();
    }
    //将HTML文件id更新到cmspage中
    if (objectId != null){
        cmsPage.setHtmlFileId(objectId.toHexString());
        cmsPageRepository.save(cmsPage);
    }
    return cmsPage;
}
```

#### 1.2.5 Controller

CmsPageController中实现api接口，接收页面请求，调用service执行页面发布

```java
@Override
@PostMapping("/postPage/{pageId}")
public ResponseResult post(@PathVariable String pageId) {
    return cmsPageService.post(pageId);
}
```





### 1.3 页面发布消费方

#### 1.3.1 需求分析

创建**Cms Client工程**作为页面发布消费方，将Cms Client部署在**多个服务器上**，它负责接收到页面发布的消息后从GridFS中下载文件在本地保存。

需求如下：

1、将cms Client部署在服务器，配置**队列名称和站点ID**。

2、cms Client连接RabbitMQ并监听各自的“页面发布队列”

3、cms Client接收页面发布队列的消息

4、根据消息中的**页面id**从mongodb数据库下载页面到本地

5、调用dao查询页面信息，获取到页面的物理路径，调用dao查询站点信息，得到站点的物理路径
页面物理路径=**站点物理路径**+**页面物理路径**+**页面名称**。从GridFS查询静态文件内容，将静态文件内容保存到页面物理路径下。



#### 1.3.2 创建Cms Client工程

`xc-service-manage-cms-client`的依赖如下：

```xml
<!--Spring Boot 继承amqp-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-io</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
</dependency>
<dependency>
    <groupId>com.xuecheng</groupId>
    <artifactId>xc-framework-model</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

启动类

```java
@SpringBootApplication
@EntityScan("com.xuecheng.framework.domain.cms")//扫描实体类
@ComponentScan(basePackages={"com.xuecheng.framework"})//扫描common包下的类
@ComponentScan(basePackages={"com.xuecheng.manage_cms_client"})//扫描本项目下的所有类
public class XcServiceManageCmsClientApplication {

    public static void main(String[] args) {
        SpringApplication.run(XcServiceManageCmsClientApplication.class, args);
    }
}
```



#### 1.3.3 RabbitMQ配置

application.yml和logback-spring.xml（略）配置文件如下：

```yaml
server:
  port: 31000
spring:
  application:
    name: xc-service-manage-cms-client
  data:
    mongodb:
      uri:  mongodb://root:123@localhost:27017
      database: xc_cms
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
    virtualHost: /
xuecheng:
  mq:
    #cms客户端监控的队列名称（不同的客户端监控的队列不能重复，有的为了集群，有的是因为不同站点的服务器）
    queue: queue_cms_postpage_01
    routingKey: 5a751fab6abb5044e0d19ea1	#此routingKey为门户站点ID
```

消息队列设置如下：

1、创建“ex_cms_postpage”交换机

2、每个Cms Client创建一个队列与交换机绑定

3、每个Cms Client程序配置队列名称和routingKey，将站点ID作为routingKey。

```java
@Configuration
public class RabbitMQConfig {

    //队列bean的名称
    public static final String QUEUE_CMS_POSTPAGE = "queue_cms_postpage";
    //交换机的名称
    public static final String EX_ROUTING_CMS_POSTPAGE="ex_routing_cms_postpage";
    //队列的名称
    @Value("${xuecheng.mq.queue}")
    public  String queue_cms_postpage_name;
    //routingKey 即站点Id
    @Value("${xuecheng.mq.routingKey}")
    public  String routingKey;

    //交换机配置使用direct类型，routing。durable为持久化，重启不删除
    @Bean(EX_ROUTING_CMS_POSTPAGE)
    public Exchange EXCHANGE_TOPICS_INFORM() {
        return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build();
    }

    //声明队列
    @Bean(QUEUE_CMS_POSTPAGE)
    public Queue QUEUE_CMS_POSTPAGE() {
        return new Queue(queue_cms_postpage_name);
    }

    //绑定队列到交换机
    @Bean
    public Binding BINDING_QUEUE_INFORM_SMS(@Qualifier(QUEUE_CMS_POSTPAGE) Queue queue, @Qualifier(EX_ROUTING_CMS_POSTPAGE) Exchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(routingKey).noargs();
    }
}
```

```java
//用于下载MongoDB中文件
@Configuration
public class MongoConfig {
    @Value("${spring.data.mongodb.database}")
    String db;

    @Bean
    public GridFSBucket getGridFSBucket(MongoClient mongoClient){
        MongoDatabase database = mongoClient.getDatabase(db);
        return GridFSBuckets.create(database);
    }
}
```



#### 1.3.4 定义消息格式

消息内容采用json格式存储数，**方便后期扩展**，如下：

```json
{
    "pageId":"" //页面id：发布页面的id
}
```



#### 1.3.4 Dao

查询页面信息，获取页面路径和页面名称

```java
public interface CmsPageRepository extends MongoRepository<CmsPage,String> {
}
```

查询站点信息，主要获取站点物理路径

```java
public interface CmsSiteRepository extends MongoRepository<CmsSite,String > {
}
```



#### 1.3.5 Service

定义保存页面静态文件到服务器物理路径方法

```java
@Service
public class PageService {

    private static final Logger LOGGER = LoggerFactory.getLogger(PageService.class);

    @Autowired
    private CmsPageRepository cmsPageRepository;

    @Autowired
    private CmsSiteRepository cmsSiteRepository;

    @Autowired
    private GridFsTemplate gridFsTemplate;//由于依赖了MongoDB所以直接注入即可使用

    @Autowired
    private GridFSBucket gridFSBucket;//需要配置类

    //将页面html保存到页面物理路径
    public void savePageToServerPath(String pageId) {
        //根据pageId查询cmsPage
        CmsPage cmsPage = this.findCmsPageById(pageId);
        //得到html的文件id，即从cmsPage中获取htmlFileId内容
        String htmlFileId = cmsPage.getHtmlFileId();
        //从gridFS中查询html文件的输入流
        InputStream inputStream = this.getFileById(htmlFileId);
        if (inputStream == null) {
            LOGGER.error("getFileById InputStream is null ,htmlFileId:{}", htmlFileId);//记录错误日志
            return;
        }

        //得到站点的信息
        String siteId = cmsPage.getSiteId();
        CmsSite cmsSite = this.findCmsSiteById(siteId);
        //得到站点的物理路径
        String sitePhysicalPath = cmsSite.getSitePhysicalPath();//这个模型该Field未定义，需定义

        //最终要存入的路径
        String path = sitePhysicalPath + cmsPage.getPagePhysicalPath() + cmsPage.getPageName();

        //通过输入流和文件名称保存到该服务器中。利用common.io
        FileOutputStream fileOutputStream = null;
        try {
            fileOutputStream = new FileOutputStream(new File(path));
            IOUtils.copy(inputStream, fileOutputStream);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                inputStream.close();
                if (fileOutputStream != null) {
                    fileOutputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

    //根据文件id从GridFS中查询文件内容，返回输入流
    public InputStream getFileById(String htmlFileId) {
        //获取文件对象
        GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(htmlFileId)));
        //打开下载流
        GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());
        //定义GridFsResource
        GridFsResource gridFsResource = new GridFsResource(gridFSFile, gridFSDownloadStream);
        try {
            return gridFsResource.getInputStream();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    //根据页面id查询页面信息
    public CmsPage findCmsPageById(String pageId) {
        Optional<CmsPage> optional = cmsPageRepository.findById(pageId);
        return optional.orElse(null);
    }

    //根据站点id查询站点信息
    public CmsSite findCmsSiteById(String siteId) {
        Optional<CmsSite> optional = cmsSiteRepository.findById(siteId);
        return optional.orElse(null);
    }
}
```

#### 1.3.6 Consumer

在cms client工程的mq包下创建ConsumerPostPage类，ConsumerPostPage作为发布页面的消费客户端，监听页面发布队列的消息，收到消息后从mongodb下载文件，保存在本地。

```java
@Component
public class ConsumerPostPage {
    private static final Logger LOGGER = LoggerFactory.getLogger(ConsumerPostPage.class);

    @Autowired
    private PageService pageService;

    @RabbitListener(queues = {"${xuecheng.mq.queue}"})
    public void postPage(String message){
        //解析消息
        Map map = JSON.parseObject(message, Map.class);
        //得到页面id，JSON中定义的消息格式
        String pageId = (String) map.get("pageId");

        //校验该pageId是否不存在
        CmsPage cmsPage = pageService.findCmsPageById(pageId);
        if (cmsPage == null){
            LOGGER.error("receive postpage message,cmsPage is null,pageId:{}",pageId);
            return;
        }
        //调用service中方法，下载HTML文件到服务器
        pageService.savePageToServerPath(pageId);
    }
}
```

在RabbitMQ的web监控页面即可看到交换机和队列都创建好了，并且还有routingKey为站点id



利用swagger测试，可能需要修改站点和页面的物理地址（给的有问题），还需要启动Nginx，最后在最终路径看到页面即可



### 1.4 页面发布前端

用户操作流程：

1、用户进入cms页面列表。

2、点击“发布”请求服务端接口，发布页面。

3、提示“发布成功”，或发布失败。

#### 1.4.1 page

修改page_list.vue，添加发布按钮

```vue
<el-button size="small" type="primary" plain @click="postPage(page.row.pageId)">发布</el-button>
```

添加页面发布事件：

```js
postPage(pageId) {
    this.$confirm('确认发布该页面吗?', '提示', {})
        .then(() => {
        cmsApi.page_postPage(pageId).then((res) => {
            if (res.success) {
                console.log('发布页面id=' + pageId);
                this.$message.success('发布成功，请稍后查看结果');
            } else {
                this.$message.error('发布失败');
            }
        });
    }).catch(() => {});
}
```



#### 1.4.2 api

cms.js的api文件中添加如下

```js
//发布页面
export const page_postPage= id =>  http.requestPost(apiUrl+'/cms/page/postPage/'+id);
```

测试后会发现，在前端`D:\Code-Workspace\_Project\xcEdu\xcEduUI\xc-ui-pc-static-portal\include`中会出现生成的静态页面



### 1.5 思考

1、如果发布到服务器的页面内容不正确怎么办？

2、一个页面需要发布很多服务器，点击“发布”后如何知道详细的发布结果？

3、一个页面发布到多个服务器，其中有一个服务器发布失败时怎么办？





## 2 课程管理

在线教育平台的课程信息相当于电商平台的商品。课程管理是后台管理功能中最重要的模块。本项目为教学机构提供课程管理功能，教学机构可以添加属于自己的课程，供学生在线学习。课程管理包括如下功能需求：

1、分类管理

2、新增课程

3、修改课程

4、预览课程

5、发布课程

用户的操作流程如下：

1、进入我的课程

2、点击“添加课程”，进入添加课程界面

3、输入课程基本信息，点击提交

4、课程基本信息提交成功，自动进入“管理课程”界面，点击“管理课程”也可以进入“管理课程”界面

> 课程计划功能采用全程教学，我的课程、新增课程、修改课程、课程营销四个功能采用实战方式。

## 3 课程计划功能

### 3.1 环境搭建

课程管理使用MySQL数据库，创建课程管理数据库：xc_course

导入课程管理服务工程：

* 课程管理服务使用MySQL数据库存储课程信息，持久层技术如下：
  * spring data jpa：用于表的基本CRUD（也可以继承另一个类实现复制查询）
  * mybatis：用于复杂的查询操作
  * druid：使用阿里巴巴提供的spring boot 整合druid包`druid-spring-boot-starter`管理连接池。

导入后端和前端工程即可，前端问题参考2.1中解决办法，后端测试两个数据库即可



### 3.2 需求分析

课程计划定义了课程的章节内容，学生通过课程计划进行在线学习。功能包括：添加课程计划、删除课程计划、修改课程计划等



### 3.3 课程教学计划查询

课程计划查询是将某个课程的课程计划内容完整的显示出来

#### 3.3.1 页面原型

本功能使用element-ui 的**tree组件**来完成

在course_plan.vue文件中添加tree组件的代码

```vue
<el‐tree
         :data="data"
         show‐checkbox
         node‐key="id"
         default‐expand‐all
         :expand‐on‐click‐node="false"
         :render‐content="renderContent">
</el‐tree>
```

```js
let id = 1000;
export default {
    data() {
        return {
            data : [{
                id: 1,
                label: '一级 1',
                children: [{
                    id: 4,
                    label: '二级 1‐1',
                    children: [{
                        id: 9,
                        label: '三级 1‐1‐1'
                    }, {
                        id: 10,
                        label: '三级 1‐1‐2'
                    }]
                }]
            }]
        }
    }
}
```

本组件用到了**JSX**语法

JSX 是Javascript和XML结合的一种格式，它是React的核心组成部分，JSX和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式。遇到 HTML 标签（以 < 开头），就用 HTML 规则解析；遇到代码块（以 { 开头？？？），就用 JavaScript 规则解析。

Webstorm设置如下：

* Javascript version 选择 React JSX （如果没有就选择JSX Harmony）。2018.3版自动就是这个设置
* HTML 类型文件中增加vue。2018.3版能解析，不用设置
  * preferences -> Editor -> File Types 中找到上边框中HTML 在下边加一个 *.vue
  * 如果已经在vue.js template 中已存在.vue 则把它改为.vue2（因为要在Html中添加.vue）

#### 3.3.2 API接口

数据模型：teachpaln表

模型类：课程计划为树型结构，由树根（课程）和树枝（章节）组成，为了保证系统的可扩展性，在系统设计时将课程计划设置为树型结构。

TeachplanNode继承了Teachplan，所以拥有Teachplan属性和自己的childrenList属性

```java
@Data
@Entity
@Table(name="teachplan")
@GenericGenerator(name = "jpa-uuid", strategy = "uuid")
public class Teachplan implements Serializable {
    private static final long serialVersionUID = -916357110051689485L;
    @Id
    @GeneratedValue(generator = "jpa-uuid")
    @Column(length = 32)
    private String id;
    private String pname;
    private String parentid;
    private String grade;
    private String ptype;
    private String description;
    private String courseid;
    private String status;
    private Integer orderby;
    private Double timelength;
    private String trylearn;
}
```

自定义模型类

```java
@Data
public class TeachplanNode extends Teachplan {

    List<TeachplanNode> children;
}
```

根据课程id查询课程的计划接口如下，在api工程创建course包，创建CourseControllerApi接口类并定义接口方法：

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {

    @ApiOperation("课程计划查询")
    TeachplanNode findTeachplanList(String courseId);
}
```



#### 3.3.3 课程管理服务

##### 1、Sql

采用外连接

```sql
SELECT
	a.id one_id,
	a.pname one_pname,
	b.id two_id,
	b.pname two_pname,
	c.id three_id,
	c.pname three_pname 
FROM
	teachplan a
	LEFT JOIN teachplan b ON a.id = b.parentid
	LEFT JOIN teachplan c ON b.id = c.parentid 
WHERE
	a.parentid = '0' 
	AND a.courseid = '4028e581617f945f01617f9dabc40000' 
ORDER BY
	a.orderby,
	b.orderby,
	c.orderby
```

##### 2、Dao 

```java
@Repository//不加这个注解也行，只是会在测试时提示找不到bean，但运行时不会有此问题
@Mapper
public interface TeachplanMapper {

    //课程计划查询
    TeachplanNode selectList(String courseId);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.xuecheng.manage_course.dao.TeachplanMapper">

    <!--课程计划查询，可以不用设置parameterType，会根据接口自动补-->
    <select id="selectList" parameterType="java.lang.String" resultMap="teachplanMap">
        SELECT a.id    one_id,
               a.pname one_pname,
               b.id    two_id,
               b.pname two_pname,
               c.id    three_id,
               c.pname three_pname
        FROM teachplan a
                 LEFT JOIN teachplan b ON a.id = b.parentid
                 LEFT JOIN teachplan c ON b.id = c.parentid
        WHERE a.parentid = '0'
          <if test="_parameter!=null and _parameter !='' ">
              AND a.courseid = #{courseId}<!--courseId变量名随便起-->
          </if>
        ORDER BY a.orderby,
                 b.orderby,
                 c.orderby
    </select>

    <!--三层树结构-->
    <resultMap id="teachplanMap" type="com.xuecheng.framework.domain.course.ext.TeachplanNode">
        <id property="id" column="one_id" />
        <result property="pname" column="one_pname" />
        <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
            <id property="id" column="two_id"/>
            <result property="pname" column="two_pname"/>
            <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
                <id property="id" column="three_id"/>
                <result property="pname" column="three_pname"/>
            </collection>
        </collection>
    </resultMap>
</mapper>
```



##### 3、Service

```java
@Service
public class CourseService {

    @Autowired
    private TeachplanMapper teachplanMapper;

    //课程计划查询
    public TeachplanNode findTeachplanList(String courseId){
        return teachplanMapper.selectList(courseId);
    }
}
```



##### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Autowired
    private CourseService courseService;

    @Override
    @GetMapping("/teachplan/list/{courseId}")
    public TeachplanNode findTeachplanList(@PathVariable String courseId) {
        return courseService.findTeachplanList(courseId);
    }
}
```



利用swagger测试（配置类在api工程中）



### 3.4 添加课程教学计划

用户操作流程：

1、进入课程计划页面，点击“添加课程计划”

2、打开添加课程计划页面，输入课程计划信息

上级结点说明：

不选择上级结点表示**当前课程计划**为该课程的一级结点。当添加该课程在课程计划中还**没有节点**时要**自动添加课程的根结点**。

后端查看3.3中代码



#### 3.4.1 API接口

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    /*......省略了3.3.2中api接口*/
    @ApiOperation("添加教学计划")
    ResponseResult addTeachplan(Teachplan teachplan);
}
```



#### 3.4.2 课程管理服务

##### 1、Dao

```java
@Repository//这个只是为了test测试时防止报错，可以删掉！
@Mapper
public interface TeachplanRepository extends JpaRepository<Teachplan,String> {

    //定义方法根据课程id和父结点id查询出结点列表，可以使用此方法实现查询根结点
    List<Teachplan> findByCourseidAndParentid(String courseId,String parentId);
}
```

##### 2、Service

```java
@Service
public class CourseService {
    @Autowired
    private TeachplanRepository teachplanRepository;

    @Autowired
    private CourseBaseRepository courseBaseRepository;

    /*省略了3.3中代码*/

    //添加课程教学计划
    @Transactional
    public ResponseResult addTeachplan(Teachplan teachplan) {
        if (teachplan == null || StringUtils.isEmpty(teachplan.getCourseid()) || StringUtils.isEmpty(teachplan.getPname())) {
            ExceptionCast.cast(CommonCode.INVALID_PARAM);
        }
        //课程id
        String courseid = teachplan.getCourseid();
        //页面传入的parentId
        String parentid = teachplan.getParentid();
        if (StringUtils.isEmpty(parentid)) {
            //若父节点为空，则获取该课程的根节点id（不是parentId）
            parentid = this.getTeachplanRoot(courseid);
        }
        //新节点，不用new直接使用也行
        Teachplan teachplanNew = new Teachplan();
        BeanUtils.copyProperties(teachplan, teachplanNew);//BeanUtils方法赋值
        teachplanNew.setParentid(parentid);//设置父结点
        teachplanNew.setCourseid(courseid);//设置课程id
        //根据父结点级别设置新节点的级别（这个参数parentId其实是根节点的id，不是字面意思！）
        Optional<Teachplan> optional = teachplanRepository.findById(parentid);
        if (!optional.isPresent()) {
            ExceptionCast.cast(CommonCode.INVALID_PARAM);
        }
        Teachplan parentNode = optional.get();
        if ("1".equals(parentNode.getGrade())) {
            teachplanNew.setGrade("2");
        } else {
            teachplanNew.setGrade("3");
        }
        teachplanRepository.save(teachplanNew);
        return new ResponseResult(CommonCode.SUCCESS);

    }

    //取出该课程的根节点id，若查询不到需要自动添加根节点（保存时自动生成）
    private String getTeachplanRoot(String courseId) {
        //取出课程信息
        Optional<CourseBase> optional = courseBaseRepository.findById(courseId);
        if (!optional.isPresent()) {
            return null;
        }
        CourseBase courseBase = optional.get();
        //查询课程的根节点。其实传入courseId后最多只有一个符合
        List<Teachplan> teachplanList = teachplanRepository.findByCourseidAndParentid(courseId, "0");
        if (teachplanList == null || teachplanList.size() <= 0) {
            Teachplan teachplan = new Teachplan();
            teachplan.setParentid("0");
            teachplan.setPname(courseBase.getName());
            teachplan.setParentid("0");
            teachplan.setGrade("1");//1级
            teachplan.setStatus("0");//未发布
            teachplanRepository.save(teachplan);
            return teachplan.getId();

        }
        return teachplanList.get(0).getId();
    }
}
```

##### 3、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Autowired
    private CourseService courseService;
    
    /*省略了3.3中代码*/

    @Override
    @PostMapping("/teachplan/add")
    public ResponseResult addTeachplan(@RequestBody Teachplan teachplan) {
        return courseService.addTeachplan(teachplan);
    }
}
```

swagger测试

#### 3.4.3 前端

##### 1、Api

```js
/*添加课程计划*/
export const addTeachplan = teachplah => http.requestPost(apiUrl+'/course/teachplan/add',teachplah);
```

##### 2、page

```js
//提交课程计划
addTeachplan(){
    //校验表单
    this.$refs.teachplanForm.validate((valid) => {
        if (valid) {
            //调用api方法
            //将课程id设置到teachplanActive
            this.teachplanActive.courseid = this.courseid
            courseApi.addTeachplan(this.teachplanActive).then(res=>{
                if(res.success){
                    this.$message.success("添加成功")
                    //刷新树
                    this.findTeachplan()
                }else{
                    this.$message.error(res.message)
                }

            })
        }
    })
}
```

添加课程计划采用弹出窗口组件**Dialog**。利用`:visible.sync="teachplayFormVisible"`实现打开关闭弹窗效果





### 3.5 我的课程（自己实现）

课程添加完成后可通过我的课程进入课程修改页面，此页面显示我的课程列表，如下图所示，可分页查询（图片暂不显示）。要实现分页、会存在多表关联查询，所以建议使用mybatis实现



#### 1、API

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    /*省略其他方法*/
    @ApiOperation("查询我的课程列表")
    QueryResponseResult findCourseList(int page,int size,CourseListRequest courseListRequest);
    
    
}
```

#### 2、Dao

返回的pojo中已经包括了另一张表的属性，并且不是pojo对象，可以不用写resultMap映射

```java
@Mapper
public interface CourseMapper {
    /*省略其他方法*/
    Page<CourseInfo> findCourseListPage(CourseListRequest courseListRequest);
}
```

```xml
<mapper namespace="com.xuecheng.manage_course.dao.CourseMapper">
    <select id="findCourseListPage" resultType="com.xuecheng.framework.domain.course.ext.CourseInfo">
        select b.*,p.pic
        from course_base b
        left join course_pic p on b.id = p.courseid
    </select>
</mapper>
```



#### 3、Service

```java
@Service
public class CourseService {
    /*省略其他方法*/
    public QueryResponseResult findCourseList(int page, int size, CourseListRequest courseListRequest){
        if (courseListRequest == null){
            courseListRequest = new CourseListRequest();
        }
        if (page<=0){
            page = 1;
        }
        if (size<=0){
            size = 10;
        }
        //分页参数，及Page对象。也可以使用PageInfo，但是需要构造
        PageHelper.startPage(page,size);
        Page<CourseInfo> courseListPage = courseMapper.findCourseListPage(courseListRequest);

        //返回值封装
        QueryResult<CourseInfo> queryResult = new QueryResult<>();
        queryResult.setList(courseListPage);
        queryResult.setTotal(courseListPage.getTotal());

        return new QueryResponseResult(CommonCode.SUCCESS,queryResult);
    }
}
```



#### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @GetMapping("/coursebase/list/{page}/{size}")
    public QueryResponseResult findCourseList(@PathVariable int page, @PathVariable int size, CourseListRequest courseListRequest) {
        return courseService.findCourseList(page,size,courseListRequest);
    }
}
```



#### 5、前端

我的课程列表使用element 的card组件。



### 3.6 新增课程（自己实现）

用户操作流程如下：

1、用户进入“我的课程”页面，点击“新增课程”，进入新增课程页面

2、填写课程信息，选择课程分类、课程等级、学习模式等

3、信息填写完毕，点击“提交”，课程添加成功或课程添加失败并提示失败原因

需要解决的是在新增页面上输入的信息：

1、**课程分类**。多级分类，需要方便用户去选择。**category表，一对多，3级**，但1级没用

2、**课程等级、学习模式**等这些选项建议是可以**配置**的。（利用MongoDB）



课程分类返回的数据实体类

```java
@Data
@Entity
@Table(name="category")
@GenericGenerator(name = "jpa-assigned", strategy = "assigned")
//@GenericGenerator(name = "jpa-uuid", strategy = "uuid")
public class Category implements Serializable {
    private static final long serialVersionUID = -906357110051689484L;
    @Id
    @GeneratedValue(generator = "jpa-assigned")
    @Column(length = 32)
    private String id;
    private String name;
    private String label;
    private String parentid;
    private String isshow;
    private Integer orderby;
    private String isleaf;

}
```

```java
@Data
public class CategoryNode extends Category {

    List<CategoryNode> children;
}
```



#### 3.6.1 课程分类

##### 1、API

```java
@Api(value = "课程分类管理",description = "课程分类管理",tags = {"课程分类管理"})
public interface CategoryControllerApi {

    @ApiOperation("查询分类")
    public CategoryNode findList();
}
```



##### 2、Dao

```java
@Mapper
public interface CategoryMapper {

    CategoryNode findList();
}
```

```java
<mapper namespace="com.xuecheng.manage_course.dao.CategoryMapper">
    <select id="findList" resultMap="CategoryNodeMap">
        SELECT
            a.id one_id,
            a.NAME one_name,
            a.label one_label,
            a.isshow one_isshow,
            a.isleaf one_isleaf,
            a.orderby one_orderby,
            a.parentid one_parentid,
            b.id two_id,
            b.NAME two_name,
            b.label two_label,
            b.isshow two_isshow,
            b.isleaf two_isleaf,
            b.orderby two_orderby,
            b.parentid two_parentid,
            c.id three_id,
            c.NAME three_name,
            c.label three_label,
            c.isshow three_isshow,
            c.isleaf three_isleaf,
            c.orderby three_orderby,
            c.parentid three_parentid
        FROM
            category a
                LEFT JOIN category b ON a.id = b.parentid
                LEFT JOIN category c ON b.id = c.parentid
        WHERE
            a.parentid = '0'
        ORDER BY
            a.orderby,
            b.orderby,
            c.orderby
    </select>
    <resultMap id="CategoryNodeMap" type="com.xuecheng.framework.domain.course.ext.CategoryNode">
        <id property="id" column="one_id"/>
        <result property="name" column="one_name"/>
        <result property="label" column="one_label"/>
        <result property="isshow" column="one_isshow"/>
        <result property="isleaf" column="one_isleaf"/>
        <result property="orderby" column="one_orderby"/>
        <result property="parentid" column="one_parentid"/>
        <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.CategoryNode">
            <id property="id" column="two_id"/>
            <result property="name" column="two_name"/>
            <result property="label" column="two_label"/>
            <result property="isshow" column="two_isshow"/>
            <result property="isleaf" column="two_isleaf"/>
            <result property="orderby" column="two_orderby"/>
            <result property="parentid" column="two_parentid"/>
            <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.CategoryNode">
                <id property="id" column="three_id"/>
                <result property="name" column="three_name"/>
                <result property="label" column="three_label"/>
                <result property="isshow" column="three_isshow"/>
                <result property="isleaf" column="three_isleaf"/>
                <result property="orderby" column="three_orderby"/>
                <result property="parentid" column="three_parentid"/>
            </collection>
        </collection>
    </resultMap>
</mapper>
```



##### 3、Service

```java
@Service
public class CategoryService {
    @Autowired
    private CategoryMapper categoryMapper;

    public CategoryNode findList(){
        return categoryMapper.findList();
    }
}
```



##### 4、Controller

```java
@RestController
@RequestMapping("/category")
public class CategoryController {

    @Autowired
    private CategoryService categoryService;

    @GetMapping("/list")
    public CategoryNode findList(){
        return categoryService.findList();
    }
}
```



##### 5、前端

采用element UI的Cascader级联选择器

用户选择课程分类后，所选分类ID绑定到categoryActive（数组）中，选择了一级、二级分类，分别存储在categoryActive数组的第一个、第二个元素中。



#### 3.6.2 课程等级、学习模式

在新增课程界面需要选择课程等级、课程状态等，这些信息统一采用**数据字典管理**的方式。

数据字典对系统的业务分类进行统一管理，并且也可以解决硬编码问题，比如添加课程时选择课程等级，下拉框中的课程等级信息如果在页面硬编码将造成不易修改维护的问题，所以从数据字典表中获取，如果要修改名称则在数据字典修改即可，提高系统的可维护性。

##### 1、数据模型

在mongodb中创建数据字典表sys_dictionary，内容如下：

```json
{
    "_id" : ObjectId("5a7e8d2dd019f15418fa2b71"),
    "d_name" : "课程等级", //字典名称
    "d_type" : "200", //字典分类
    "d_value" : [ //字典数据
        {
            "sd_name" : "低级", //项目名称
            "sd_id" : "200001", //项目id
            "sd_status" : "1" //项目状态（1：可用，0不可用）
        },
        {
            "sd_name" : "中级",
            "sd_id" : "200002",
            "sd_status" : "1"
        },
        {
            "sd_name" : "高级",
            "sd_id" : "200003",
            "sd_status" : "1"
        }
    ]
}
```

数据模型类

```java
@Data
@Document(collection = "sys_dictionary")
public class SysDictionary {

    @Id
    private String id;

    @Field("d_name")
    private String dName;

    @Field("d_type")
    private String dType;

    @Field("d_value")
    private List<SysDictionaryValue> dValue;
}
```

```java
@Data
public class SysDictionaryValue {

    @Field("sd_id")
    private String sdId;

    @Field("sd_name")
    private String sdName;

    @Field("sd_status")
    private String sdStatus;
}
```

##### 2、API

可以其他微服务远程调用！

```java
@Api(value = "数据字典接口",description = "提供数据字典接口的管理、查询功能")
public interface SysDictionaryControllerApi {

    //数据字典
    @ApiOperation(value="数据字典查询接口")
    SysDictionary getByType(String type);
}
```

##### 3、Dao

> 之后的都在cms微服务中创建

```java
public interface SysDictionaryRepository extends MongoRepository<SysDictionary,String> {

    //根据字典分类查询字典信息
    SysDictionary findByDType(String dType);
}
```

##### 4、Service

```java
@Service
public class CmsDictionaryService {

    @Autowired
    private SysDictionaryRepository sysDictionaryRepository;

    //根据字典分类type查询字典信息
    public SysDictionary findByDType(String type){
        return sysDictionaryRepository.findByDType(type);
    }
}
```

##### 5、Controller

```java
@RestController
@RequestMapping("/sys/dictionary")
public class CmsDictionaryController implements SysDictionaryControllerApi {

    @Autowired
    private CmsDictionaryService cmsDictionaryService;

    @Override
    @GetMapping("/get/{type}")
    public SysDictionary getByType(@PathVariable String type) {
        return cmsDictionaryService.findByDType(type);
    }
}
```



##### 6、前端

采用element UI的el-radio

#### 3.6.3 新增课程

##### 1、API

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
	/*省略其他方法*/

    @ApiOperation("添加课程基础信息")
    AddCourseResult addCourse(CourseBase courseBase);
}
```

##### 2、Dao

```java
public interface CourseBaseRepository extends JpaRepository<CourseBase,String> {
}
```

##### 3、Service

```java
@Service
public class CourseService {
    @Transactional
    public AddCourseResult addCourse(CourseBase courseBase){
        courseBase.setStatus("200201");
        CourseBase base = courseBaseRepository.save(courseBase);
        return new AddCourseResult(CommonCode.SUCCESS,base.getId());//并不能获取到添加后的id
    }
}
```

##### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi { 
    @Override
    @PostMapping("/coursebase/add")
    public AddCourseResult addCourse(@RequestBody CourseBase courseBase) {
        return courseService.addCourse(courseBase);
    }
}
```



### 3.7 课程信息修改（自己实现）

课程添加成功进入课程管理页面，通过课程管理页面修改课程的基本信息、编辑课程图片、编辑课程营销信息等。

导航效果使用Element-UI的NavMenu组件实现

#### 1、Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {

    @ApiOperation("根据课程id查询课程")
    CourseBase getCourseBaseById(String courseId);

    @ApiOperation("根据课程id修改或添加课程")
    ResponseResult updateCourseBase(String courseId,CourseBase courseBase);
}
```



#### 2、Dao

```java
public interface CourseBaseRepository extends JpaRepository<CourseBase,String> {
}
```



#### 3、Service

```java
@Service
public class CourseService {
    public CourseBase getCourseBaseById(String courseId){
        Optional<CourseBase> optional = courseBaseRepository.findById(courseId);
        return optional.orElse(null);
    }

    @Transactional
    public ResponseResult updateCourseBase(String courseId,CourseBase courseBase){
        CourseBase newCourseBase = this.getCourseBaseById(courseId);
        //不存在
        if (newCourseBase == null){
            newCourseBase = new CourseBase();
        }

        BeanUtils.copyProperties(courseBase,newCourseBase);
        courseBaseRepository.save(newCourseBase);
        return new ResponseResult(CommonCode.SUCCESS);

    }
}
```



#### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {   
    @Override
    @GetMapping("/coursebase/get/{courseId}")
    public CourseBase getCourseBaseById(@PathVariable String courseId) {
        return courseService.getCourseBaseById(courseId);
    }

    @Override
    @PutMapping("/coursebase/update/{courseId}")
    public ResponseResult updateCourseBase(@PathVariable String courseId, @RequestBody CourseBase courseBase) {
        return courseService.updateCourseBase(courseId,courseBase);
    }
}
```



### 3.8 课程营销（自己实现）

课程营销信息包括课程价格、课程有效期等信息。

课程营销信息使用course_market表存储，数据模型如下：

```java
@Data
@Entity
@Table(name="course_market")
@GenericGenerator(name = "jpa-assigned", strategy = "assigned")
public class CourseMarket implements Serializable {
    private static final long serialVersionUID = -916357110051689486L;
    @Id
    @GeneratedValue(generator = "jpa-assigned")
    @Column(length = 32)
    private String id;
    private String charge;
    private String valid;
    private String qq;
    private Float price;
    private Float price_old;
    //private Date expires;
    @Column(name = "start_time")
    private Date startTime;
    @Column(name = "end_time")
    private Date endTime;
}
```



#### 1、Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {   
    @ApiOperation("根据课程id获取课程营销信息")
    CourseMarket getCourseMarketById(String courseId);

    @ApiOperation("根据课程id更新课程营销信息")
    ResponseResult updateCourseMarket(String courseId,CourseBase courseBase);
}
```



#### 2、Dao

```java
public interface CourseMarketRepository extends JpaRepository<CourseMarket,String> {
}
```



#### 3、Service

```java
@Service
public class CourseMarketService {

    @Autowired
    private CourseMarketRepository courseMarketRepository;

    public CourseMarket getCourseMarketById(String courseId){
        Optional<CourseMarket> optional = courseMarketRepository.findById(courseId);
        return optional.orElse(null);
    }


    public ResponseResult updateCourseMarket(String courseId,CourseMarket courseMarket){
        CourseMarket newCourseMarket = this.getCourseMarketById(courseId);
        //有则更新，无则添加
        if (newCourseMarket == null){
            newCourseMarket = new CourseMarket();
        }
        BeanUtils.copyProperties(courseMarket,newCourseMarket);
        courseMarketRepository.save(newCourseMarket);
        return new ResponseResult(CommonCode.SUCCESS);
    }
}
```



#### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @GetMapping("/coursemarket/get/{courseId}")
    public CourseMarket getCourseMarketById(@PathVariable String courseId) {
        return courseMarketService.getCourseMarketById(courseId);
    }

    @Override
    @PutMapping("/coursemarket/update/{courseId}")
    public ResponseResult updateCourseMarket(@PathVariable String courseId, @RequestBody CourseMarket courseMarket) {
        return courseMarketService.updateCourseMarket(courseId,courseMarket);
    }
}
```



# 8 课程图片管理—FastDFS

## 1 分布式文件系统

### 1.1 简介

**文件系统**：负责**管理和存储**文件的系统软件，它是操作系统和硬件驱动之间的桥梁，操作系统通过文件系统提供的接口去存取文件，用户通过操作系统访问磁盘上的文件。常见的文件系统：FAT16/FAT32、NTFS、HFS、UFS、APFS、XFS、Ext4等

**分布式文件系统**：将多个地点的文件系统通过**网络连接**起来，组成一个文件系统网络，结点之间通过网络进行通信，一台文件系统的存储和传输能力有限，我们让文件在多台计算机上存储，通过多台计算共同传输。==解决了海量文件**存储**及**传输访问**的瓶颈问题，对海量视频的管理、对海量图片的管理等。==

分布式文件系统**好处**：

* 一台计算机的文件系统处理能力扩充到**多台计算机同时处理**。
* 一台计算机挂了还有另外**副本**计算机提供数据。
* 每台计算机可以放在不同的地域，这样用户就可以**就近访问**，提高访问速度。



### 1.2 主流的分布式文件系统

* NFS，网络文件系统

  1）在客户端上映射NFS服务器的驱动器。

  2）客户端通过网络访问NFS服务器的硬盘完全透明。

* GFS（GoogleFS），是可扩展的分布式文件系统

  ![1551251705300](images/1551251705300.png)

  1）GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver组成。

  2）master存储了数据文件的元数据，一个文件被分成了若干**块**存储在多个chunkserver中。

  3）用户从master中获取数据元信息，从chunkserver存储数据。

* HDSF（Hadoop分布式文件系统），大数据中用的多

  ![1551251822644](images/1551251822644.png)

  1）HDFS采用主从结构，一个HDFS集群由一个名称结点和若干数据结点组成。名称结点存储数据的元信息，一个完整的数据文件分成若干块存储在数据结点。

  2）客户端从名称结点获取数据的元信息及数据分块的信息，得到信息客户端即可从数据块来存取数据。

  

  ### 1.3 分布式文件服务提供商

  * 阿里的OSS
  * 七牛云存储
  * 百度云存储

  

  

  

## 2 FastDFS

### 2.1 FastDFS工作原理

FastDFS是用 C 语言编写的一款开源的分布式文件系统，它是由淘宝资深架构师余庆编写并开源。FastDFS**专为互联网量身定制**，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。为什么要使用FastDFS呢？

上边介绍的NFS、GFS都是通用的分布式文件系统，通用的分布式文件系统的优点的是开发体验好，但是系统复杂性高、性能一般，而专用的分布式文件系统虽然开发体验性差，但是系统复杂性低并且性能高。FastDFS非常**适合存储图片等那些小文件**，FastDFS**不对文件进行分块**，所以它就没有分块合并的开销，fastDFS网络通信采用Socket，通信速度很快。

#### 2.1.1 FastDFS架构

FastDFS架构包括 Tracker server和Storage server。客户端请求Tracker server进行文件上传、下载，通过Tracker server调度最终由Storage server完成文件上传和下载。

最简单的 FastDFS 架构：6个服务器，其中2个Tracker、2个卷，每个卷中有2个Storager

![1551252781712](images/1551252781712.png)

* **Tracker**

  Tracker作用是**负载均衡和调度**，通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将Tracker 称为追踪服务器或调度服务器。

  FastDFS集群中的Tracker server可以有多台，Tracker server之间是相互平等关系同时提供服务，不存在单点故障。客户端请求Tracker server采用轮询方式，如果请求的Tracker 无法提供服务则换另一个Tracker。

* **Storage**

  Storage Server作用是**文件存储**，客户端上传的文件最终存储在Storage服务器上，Storage server没有实现自己的文件系统而是使用操作系统的文件系统来管理文件。可以将Storage称为存储服务器。

  Storage集群采用了分组存储方式。storage集群由一个或多个组（卷）构成，集群存储总容量为集群中所有组（卷）的存储容量之和。一个组（卷）由一台或多台存储服务器组成，组（卷）内的Storage server之间是平等关系，不同组（卷）的Storage server之间不会相互通信，同组（卷）内的Storage server之间会相互连接进行文件同步，从而保证同组（卷）内每个storage上的文件完全一致的。一个组（卷）的存储容量为该组（卷）内的存储服务器容量最小的那个，由此可见组（卷）内存储服务器的软硬件配置最好是一致的。

  采用分组（卷）存储方式的好处是灵活、可控性较强。比如上传文件时，可以由客户端直接指定上传到的组（卷）也可以由Tracker进行调度选择。一个分组（卷）的存储服务器访问压力较大时，可以在该组（卷）增加存储服务器来扩充服务能力（纵向扩容）。当系统容量不足时，可以增加组（卷）来扩充存储容量（横向扩容）。

* Storage**状态收集**

  Storage server会连接集群中所有的Tracker server，定时向他们报告自己的状态，包括磁盘剩余空间、文件同步状况、文件上传下载次数等统计信息。



#### 2.1.2 文件上传流程

![1551253620048](images/1551253620048.png)

客户端上传文件后存储服务器将**文件ID**返回给客户端，此文件ID**用于以后访问该文件的索引信息**。文件索引信息包括：**组名**，**虚拟磁盘路径**，**数据两级目录**，**文件名**。

![1551253731023](images/1551253731023.png)

* **组名**：文件上传后所在的storage组名称，在文件上传成功后由storage服务器返回，需要客户端自行保存。
* **虚拟磁盘路径**：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推。
* **数据两级目录**：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。
* **文件名**：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。



#### 2.1.3 文件下载流程

![1551253837704](images/1551253837704.png)

Tracker根据请求的文件路径即文件ID 来快速定义文件。比如请求下边的文件：

![1551253865754](images/1551253731023.png)

1. 通过组名Tracker能够很快的定位到客户端需要访问的存储服务器组是group1，并选择合适的存储服务器提供客户端访问。
2. 存储服务器根据“文件存储虚拟磁盘路径”和“数据文件两级目录”可以很快定位到文件所在目录，并根据文件名找到客户端需要访问的文件。

### 2.2 FastDFS入门

#### 2.2.1 FastDFS安装与配置

> 使用品优购的虚拟机，或自己安装，使用之前安装的Ubuntu18，但是Tracker可以正常启动，Storage GG了...

1. 启动`VMware NAT Service`服务！

2. 修改本机网络连接中VMnet8网卡（为NAT模式的网卡）的**IP地址**为101网段如`192.168.101.1`，子网掩码`255.255.255.0`

3. 修改虚拟机网络配置如VMnet8（NAT模式）的**子网IP**为`192.168.101.0`

4. DHCP配置开始IP为128，结束为254（默认就是这样）

5. FastDFS--tracker安装（分别安装两台，初次使用可以只安装一台）

   1. tracker和storage使用相同的安装包，[下载地址](https://github.com/happyfish100/FastDFS)。本教程下载：FastDFS_v5.05.tar.gz

   2. 安装FastDFS需要先将官网下载的源码进行编译，编译依赖gcc环境。Ubuntu18自带

   3. FastDFS依赖libevent库，`sudo apt-get install libevent-dev`

   4. 安装libfastcommon，包含了FastDFS运行所需要的一些基础库

      1. 将libfastcommonV1.0.7.tar.gz拷贝至/usr/local/下
      2. cd /usr/local
      3. tar -zxvf libfastcommonV1.0.7.tar.gz
      4. cd libfastcommon-1.0.7
      5. ./make.sh
      6. ./make.sh install
      7. libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib下。或者软连接（网上找）

   5. Tracker编译安装

      1. 将FastDFS_v5.05.tar.gz拷贝至/usr/local/下
      2. tar -zxvf FastDFS_v5.05.tar.gz
      3. cd FastDFS
      4. ./make.sh 编译
      5. ./make.sh install 安装
      6. 安装成功将安装目录下的conf下的文件拷贝到/etc/fdfs/下

   6. 配置

      1. 进入/etc/fdfs目录

      2. 拷贝一份新的tracker配置文件：cp tracker.conf.sample tracker.conf

      3. 修改tracker.conf的配置

         1. 端口：`port=22122`

         2. Tracker 基础目录：`base_path=/home/fastdfs`，tracker在运行时会向此目录存储storage的管理数据

            > 没有/home/fastdfs这个目录需要手动创建！后面的配置也是

         3. 存储策略：store_lookup=取值范围：0（轮询向storage存储文件）、1（指定具体的group）、2负载均衡，选择空闲的storage存储指定具体的group：store_group= 如果store_lookup设置为1则这里必须指定一个具体的group。

      4. 修改storage.conf的配置（实际应该在另一台机器中）

         1. 端口：`port=23000`

         2. Storage基础目录：`base_path=/home/fastdfs`

         3. 组名：`group_name=group1`

         4. 向Tracker心跳间隔（秒）：`heart_beat_interval=30`

         5. 磁盘存储目录，可定义多个store_path：`store_path0=/home/fastdfs/fdfs_storage `

            此目录下存储上传的文件在`/home/fastdfs/fdfs_storage/data`下

         6. 上报tracker的地址：`tracker_server=192.168.101.64:22122`，如果有多个tracker则配置多个tracker

   7. 启动停止

      1. fastDFS启动/停止脚本目录：

         1. fdfs_trackerd：tracker脚本，通过此脚本对 tracker进行启动和停止

            `/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart`

         2. fdfs_storaged：storage脚本，通过此脚本对 storage进行启动和停止

            `/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart`



#### 2.2.2 文件上传下载测试

这里我们使用javaApi测试文件的上传，java版本的[fastdfs-client地址](https://github.com/happyfish100/fastdfs-client-java)，参考此工程编写测试用例。

1. Maven依赖

   ```xml
   <!-- https://mvnrepository.com/artifact/net.oschina.zcx7878/fastdfs-client-java -->
   <dependency>
       <groupId>net.oschina.zcx7878</groupId>
       <artifactId>fastdfs-client-java</artifactId>
       <version>1.27.0.0</version>
   </dependency>
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-test</artifactId>
       <scope>test</scope>
   </dependency>
   <dependency>
       <groupId>org.apache.commons</groupId>
       <artifactId>commons-io</artifactId>
       <version>1.3.2</version>
   </dependency>
   ```

2. 在classpath:config下创建`fastdfs-client.properties`配置文件

   ```properties
   #http连接超时时间
   fastdfs.connect_timeout_in_seconds = 5
   #tracker与storage网络通信超时时间
   fastdfs.network_timeout_in_seconds = 30
   #字符编码
   fastdfs.charset = UTF-8
   #tracker服务器地址，多个地址中间用英文逗号分隔
   fastdfs.tracker_servers = 192.168.25.133:22122
   ```

3. 文件上传

   ```java
   //加载fastdfs-client.properties配置文件
   ClientGlobal.initByProperties("config/fastdfs-client.properties");
   //定义TrackerClient，用于请求TrackerServer
   TrackerClient trackerClient = new TrackerClient();
   //连接tracker
   TrackerServer trackerServer = trackerClient.getConnection();
   //获取Stroage
   StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
   //创建stroageClient
   StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer);
   
   //向stroage服务器上传文件
   String filePath = "D:/dog.jpg";//本地文件的路径
   String fileId = storageClient1.upload_file1(filePath, "jpg", null);//上传成功后拿到文件Id
   System.out.println(fileId);//group1/M00/00/00/wKgZhVx2q6yARolJAAGgU0NHZ6E212.jpg
   ```

   根据文件ID，M00为虚拟路径，是配置文件中的`store_path0=/home/fastdfs/fdfs_storage`，此目录下存储上传的文件在`/home/fastdfs/fdfs_storage/data`下，在该目录利用`ll /00/00/wKgZhVx2q6yARolJAAGgU0NHZ6E212.jpg`即可找到

4. 文件下载

   ```java
   //加载fastdfs-client.properties配置文件
   ClientGlobal.initByProperties("config/fastdfs-client.properties");
   //定义TrackerClient，用于请求TrackerServer
   TrackerClient trackerClient = new TrackerClient();
   //连接tracker
   TrackerServer trackerServer = trackerClient.getConnection();
   //获取Stroage
   StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
   //创建stroageClient
   StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer);
   
   //下载文件
   byte[] bytes = storageClient1.download_file1("group1/M00/00/00/wKgZhVx2q6yARolJAAGgU0NHZ6E212.jpg");
   IOUtils.write(bytes,new FileOutputStream("D:/cat.jpg"));//C盘有权限问题，不能存放
   ```

5. 文件查询

   ```java
   //加载fastdfs-client.properties配置文件
   ClientGlobal.initByProperties("config/fastdfs-client.properties");
   //定义TrackerClient，用于请求TrackerServer
   TrackerClient trackerClient = new TrackerClient();
   //连接tracker
   TrackerServer trackerServer = trackerClient.getConnection();
   //获取Stroage
   StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
   //创建stroageClient
   StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer);
   
   FileInfo fileInfo = storageClient.query_file_info("group1","M00/00/01/wKhlQFrKBSOAW5AWAALcAg10vf4862.png");
   System.out.println(fileInfo);
   //source_ip_addr = 192.168.25.133, file_size = 106579, create_timestamp = 2019-02-27 23:24:28, crc32 = 1128753057
   ```



#### 2.2.3 在Storage搭建图片虚拟主机

在 Storage server 上安装 nginx 的目的是**对外通过 http 访问 storage server 上的文件**。使用 nginx 的模块**FastDFS-nginx-module** 的作用是通过 http 方式访问 storage 中的文件，当 storage 本机**没有要找的文件时向源storage 主机代理请求文件**。

在storage上安装nginx（安装**FastDFS-nginx-module模块**，没安装，上面的失败了，这边暂时不自己做）

1. 将FastDFS-nginx-module_v1.16.tar.gz传至FastDFS的storage服务器的/usr/local/下

2. cd /usr/local

3. tar -zxvf FastDFS-nginx-module_v1.16.tar.gz

4. cd FastDFS-nginx-module/src

5. 修改config文件将/usr/local/路径改为/usr/（在CORE_INCS和CORE_LIBS）

6. 将FastDFS-nginx-module/src下的mod_FastDFS.conf拷贝至/etc/fdfs/下

7. cp mod_FastDFS.conf /etc/fdfs/

8. 修改mod_FastDFS.conf的内容：

   1. base_path=/home/FastDFS
   2. tracker_server=192.168.101.3:22122
   3. tracker_server=192.168.101.4:22122（有几台配置几台）
   4. url_have_group_name=true，url中包含group名称
   5. store_path0=/home/fastdfs/fdfs_storage，指定文件存储路径，有多个配置多个
   6. cp /usr/lib64/libfdfsclient.so /usr/lib/，将libfdfsclient.so拷贝至/usr/lib下（好像软连接过了）
   7. mkdir -p /var/temp/nginx/client，创建nginx/client目录

9. nginx安装

   1. 将nginx-1.8.0.tar.gz拷贝到/usr/local下

   2. 解压nginx-1.8.0.tar.gz

   3. 进入nginx-1.8.0目录，执行如下配置命令（最后一行表示添加FastDFS-nginx-module模块）：

      ```shell
      ./configure \ 
      --prefix=/usr/local/nginx \ 
      --pid-path=/var/run/nginx/nginx.pid \
      --lock-path=/var/lock/nginx.lock \ 
      --error-log-path=/var/log/nginx/error.log \ 
      --http-log-path=/var/log/nginx/access.log \ 
      --with-http_gzip_static_module \ 
      --http-client-body-temp-path=/var/temp/nginx/client \ 
      --http-proxy-temp-path=/var/temp/nginx/proxy \ 
      --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \ 
      --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \ 
      --http-scgi-temp-path=/var/temp/nginx/scgi \ 
      --add-module=/usr/local/FastDFS-nginx-module/src
      ```

   4. make

   5. make install

   6. nginx配置文件

      新建一个nginx配置文件nginx-fdfs.conf，添加虚拟主机

      ```nginx
      server { 
      	listen 80;
      	server_name 192.168.101.65;
      	
      	location /group1/M00/{ 
      		root /home/FastDFS/fdfs_storage/data; 
      		ngx_FastDFS_module; 
          }
      }
      ```

      server_name指定本机ip

      location /group1/M00/：group1为nginx 服务FastDFS的分组名称，M00是FastDFS自动生成编号，对应store_path0=/home/FastDFS/fdfs_storage，如果FastDFS定义store_path1，这里就是M01

10. 安装完成启动storage上的nginx：`/usr/local/nginx/sbin/nginx ‐c /usr/local/nginx/conf/nginx‐fdfs.conf`

11. 上传文件后，访问Storage，如http://192.168.25.133/group1/M00/00/00/wKgZhVx2q6yARolJAAGgU0NHZ6E212.jpg

    若一组有两台Storage服务器，则那一台也可以访问到，因为文件互相同步。并且访问Tracker服务器也可以看到文件

**配置Nginx图片服务虚拟机主机**

图片服务虚拟主机的作用是负载均衡，将图片请求转发到storage server上。

![1551285265020](images/1551285265020.png)

在nginx图片代理服务上配置图片服务器**虚拟主机**（在本机和前端静态文件同一个Nginx，如下只是测试，具体自己配置）

```nginx
#图片服务
upstream img_server_pool1{
	#server 192.168.101.64:80 weight=10;
	server 192.168.101.65:80 weight=10;
}
upstream img_server_pool2{
	#server 192.168.101.66:80 weight=10;
	server 192.168.101.67:80 weight=10;
}

#学成网图片服务
server {
	listen 80;
	server_name img.xuecheng.com;

	#个人中心
	location /group1 {
		proxy_pass http://img_server_pool1;
	}

	location /group2 {
		proxy_pass http://img_server_pool2;
	}
}
```

重启Nginx，`./nginx -s reload`，配置hosts`127.0.0.1 img.xuecheng.com`



## 3 上传图片开发

### 3.1 需求分析

在很多系统都有上传图片/上传文件的需求，比如：上传课程图片、上传课程资料、上传用户头像等，为了提供系统的**可重用性**专门设立**文件系统服务**承担图片/文件的管理，文件系统服务实现对文件的上传、删除、查询等功能进行管理。

下图是课程管理中上传图片处理流程：

![1551286536321](images/1551286536321.png)

执行流程如下：

1、管理员进入教学管理前端，点击上传图片

2、图片上传至文件系统服务，文件系统请求fastDFS上传文件

3、**文件系统将文件入库（FastDFS）**，存储到**文件系统服务数据库中（MongoDB）**

4、文件系统服务向前端返回文件上传结果，如果成功则包括文件的Url路径

5、课程管理前端请求课程管理进行保存课程图片信息到课程数据库

6、课程管理服务将课程图片信息**保存在课程数据库（MySQL）**



### 3.2 创建文件系统微服务工程

导入xc-service-base-filesystem.zip工程。Maven依赖就不给出了

配置文件：原测试程序中fastdfs-client.properties的配置信息统一放在application.yml

```yaml
server:
  port: 22100
spring:
  application:
    name: xc-service-base-filesystem
#mongo配置
  data:
    mongodb:
      database: xc_fs
      uri: mongodb://root:123@127.0.0.1:27017
#SpringMVC上传文件配置
  servlet:
    multipart:
      #默认支持文件上传.
      enabled: true
      #支持文件写入磁盘.
      file-size-threshold: 0
      # 上传文件的临时目录
      location:
      # 最大支持文件大小
      max-file-size: 1MB
      # 最大支持请求大小
      max-request-size: 30MB
xuecheng:
  fastdfs:
    connect_timeout_in_seconds: 5 #http连接超时时间
    network_timeout_in_seconds: 30 #tracker与storage网络通信超时时间
    charset: UTF-8 #字符编码
    tracker_servers: 192.168.25.133:22122 #tracker服务器地址，多个地址中间用英文逗号分隔
```





### 3.2 模型类

还需创建xc_fs的MongoDB数据库，其中集合和文档就不需要了，因为Spring Data MongoDB会根据模型类自动映射并创建

```java
@Data
@Document(collection = "filesystem")
public class FileSystem {

    @Id//自动生成的文档中列名为_id。fastDFS返回的文件ID
    private String fileId;
    //文件请求路径，和fileId一致，请求fastDFS浏览文件URL
    private String filePath;
    //文件大小
    private long fileSize;
    //文件名称
    private String fileName;
    //文件类型
    private String fileType;
    //图片宽度
    private int fileWidth;
    //图片高度
    private int fileHeight;
    //用户id，用于授权
    private String userId;
    
    //以下三个为其他业务可能要上传的图片相关信息，与上传的图片无关
    
    //文件系统服务为其它子系统提供的一个业务标识字段，各子系统根据自己的需求去使用，比如：课程管理会在此字段中存储课程id用于标识该图片属于哪个课程。
    private String businesskey;
    //文件标签，由于文件系统服务是公共服务，文件系统服务会为使用文件系统服务的子系统分配文件标签，用于标识此文件来自哪个系统。
    private String filetag;
    //文件元信息
    private Map metadata;

}
```



### 3.3 Api

```java
@Api(value="文件系统服务接口",description = "文件系统服务接口，提供文件的管理、查询等接口")
public interface FileSystemControllerApi {

    //传入的metadata是JSON字符串，需要转换为Map
    @ApiOperation("文件上传")
    UploadFileResult upload(MultipartFile file,String businesskey,String filetag,String metadata);
}
```



### 3.4 Dao

```java
public interface FileSystemRepository extends MongoRepository<FileSystem,String> {
}
```



### 3.5 Service

```java
@Service
public class FileSystemService {
    @Value("${xuecheng.fastdfs.connect_timeout_in_seconds}")
    private int connect_timeout_in_seconds;
    @Value("${xuecheng.fastdfs.network_timeout_in_seconds}")
    private int network_timeout_in_seconds;
    @Value("${xuecheng.fastdfs.tracker_servers}")
    private String tracker_servers;
    @Value("${xuecheng.fastdfs.charset}")
    private String charset;

    @Autowired
    private FileSystemRepository fileSystemRepository;

    public UploadFileResult upload(MultipartFile file, String businesskey, String filetag, String metadata) {
        if (file == null) {
            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_FILEISNULL);
        }

        //第一步：将文件上传到fastDFS中，得到一个文件id
        String fileId = fdfs_upload(file);
        if (StringUtils.isEmpty(fileId)) {
            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_SERVERFAIL);
        }
        //第二步：将文件id及其它文件信息存储到mongodb中
        FileSystem fileSystem = new FileSystem();
        fileSystem.setFileId(fileId);//文件id
        fileSystem.setFilePath(fileId);//文件在文件系统中的路径
        fileSystem.setFileName(file.getOriginalFilename());//名称
        fileSystem.setFileSize(file.getSize());//大小
        fileSystem.setFileType(file.getContentType());//文件类型
        fileSystem.setBusinesskey(businesskey);//业务标识
        fileSystem.setFiletag(filetag);//标签
        if (!StringUtils.isEmpty(metadata)) { //元数据
            Map map = JSON.parseObject(metadata, Map.class);
            fileSystem.setMetadata(map);
        }
        fileSystemRepository.save(fileSystem);
        return new UploadFileResult(CommonCode.SUCCESS, fileSystem);
    }

    //上传文件到FastDFS
    private String fdfs_upload(MultipartFile file) {
        //初始化fastDFS的环境
        initFastDFSConfig();
        //创建trackerClient
        TrackerClient trackerClient = new TrackerClient();
        try {
            //得到Tracker服务器
            TrackerServer trackerServer = trackerClient.getConnection();
            //得到storage服务器
            StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
            //创建storageClient来上传文件
            StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer);
            //得到文件扩展名
            String ext = Objects.requireNonNull(file.getOriginalFilename()).split(".")[1];
            //上传并返回文件ID
            return storageClient1.upload_file1(file.getBytes(), ext, null);
        } catch (IOException | MyException e) {
            e.printStackTrace();
            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_SERVERFAIL);
        }
        return null;

    }

    //FastDFS初始化（由于使用了yml，所以需要手动初始化）
    private void initFastDFSConfig() {
        try {
            ClientGlobal.initByTrackers(tracker_servers);//初始化tracker服务地址
            ClientGlobal.setG_connect_timeout(connect_timeout_in_seconds);
            ClientGlobal.setG_network_timeout(network_timeout_in_seconds);
            ClientGlobal.setG_charset(charset);
        } catch (IOException | MyException e) {
            e.printStackTrace();
            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_USERISNULL);
        }
    }
}
```

### 3.6 Controller

```java
@RestController
@RequestMapping("/filesystem")
public class FileSystemController implements FileSystemControllerApi {
    @Autowired
    private FileSystemService fileSystemService;

    @Override
    @PostMapping("/upload")
    public UploadFileResult upload(MultipartFile file, String businesskey, String filetag, String metadata) {
        return fileSystemService.upload(file, businesskey, filetag, metadata);
    }
}
```

【注意】前端上传文件的name必须和MultipartFile的变量名`file`一致，也可以修改为其他名称

利用Swagger测试时，无论后端中MultipartFile的变量名是什么都可以上传成功，但是前端就必须一致！！！

### 3.7 前端

点击“加号”上传图片，图片上传成功自动显示；点击“删除”将删除图片。

使用Element-UI的Upload上传组件实现上边的效果。

```vue
<el-upload
           action="/api/filesystem/upload"
           list-type="picture-card"
           :before-upload="setuploaddata"
           :on-success="handleSuccess"
           :file-list="fileList"
           :limit="picmax"
           :on-exceed="rejectupload"
           :before-remove="handleRemove"
           :data="uploadval"
           name="file">
    <i class="el-icon-plus"></i>
</el-upload>
```

action：必选参数，上传的地址
list-type：文件列表的类型（text/picture/picture-card）
before-upload：上传前执行钩子方法 ，function(file)
on-success：上传成功 执行的钩子方法 ，function(response, file, fileList)
on-error：上传失败的钩子方法，function(err, file, fileList)
on-remove：文件删除的钩子方法，function(file, fileList)
**file-list**：文件列表，此列表为上传成功的文件
limit：最大允许上传个数
on-exceed：文件超出个数限制时的钩子，方法为：function(files, fileList)
data：提交上传的额外参数，需要封装为json对象，最终提交给服务端为key/value串

**name**必须前后端一致！！！！





## 4 保存课程图片

图片上传到文件系统后，其它子系统如果想使用图片可以引用图片的地址，课程管理模块使用图片的方式是将图片地址保存到课程数据库course_pic中。当前系统只保存一张！

### 4.1 Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("添加课程图片与课程关联")
    ResponseResult addCoursePic(String courseId,String pic);
}
```

### 4.2 Dao

数据模型

```java
@Data
@Entity
@Table(name="course_pic")
@GenericGenerator(name = "jpa-assigned", strategy = "assigned")
public class CoursePic implements Serializable {
    private static final long serialVersionUID = -916357110051689486L;

    @Id
    @GeneratedValue(generator = "jpa-assigned")
    private String courseid;
    private String pic;
}
```

```java
public interface CoursePicRepository extends JpaRepository<CoursePic,String> {
}
```



### 4.3 Service

```java
@Transactional
public ResponseResult saveCoursePic(String courseId, String pic) {
    CoursePic coursePic = null;
    //查询课程图片
    Optional<CoursePic> optional = coursePicRepository.findById(courseId);
    if (optional.isPresent()) {
        coursePic = optional.get();
    }
    //没有课程图片则新建对象
    if (coursePic==null){
        coursePic = new CoursePic();
    }
    //保存课程图片
    coursePic.setCourseid(courseId);
    coursePic.setPic(pic);
    coursePicRepository.save(coursePic);
    return new ResponseResult(CommonCode.SUCCESS);
}
```



### 4.4 Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @PostMapping("/coursepic/add")
    public ResponseResult addCoursePic(String courseId, String pic) {
        return courseService.saveCoursePic(courseId,pic);
    }
}
```



### 4.5 前端

前端需要在上传图片成功后保存课程图片信息

利用element UI上传成功的钩子 :on-success="handleSuccess"



## 5 图片查询

课程图片上传成功，再次进入课程上传页面应该显示出来已上传的图片。



### 5.1 Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("获取课程图片信息")
    CoursePic findCoursePic(String courseId);
}
```



### 5.2 Dao

```java
public interface CoursePicRepository extends JpaRepository<CoursePic,String> {
}
```



### 5.3 Service

```java
@Service
public class CourseService {
    public CoursePic findCoursepic(String courseId){
        Optional<CoursePic> optional = coursePicRepository.findById(courseId);
        return optional.orElse(null);
    }
}
```



### 5.4 Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @GetMapping("/coursepic/list/{courseId}")
    public CoursePic findCoursePic(@PathVariable String courseId) {
        return courseService.findCoursepic(courseId);
    }
}
```



### 5.5 前端

在课程图片页面的mounted钩子方法 中查询课程图片信息，并将图片地址赋值给数据对象（拼接域名），放入file-list中



## 6 课程图片删除

课程图片上传成功后，可以重新上传，方法是先删除现有图片再上传新图片。

注意：此删除只删除课程数据库的课程图片信息，不去删除文件数据库的文件信息及文件系统服务器上的文件，由于课程图片来源于该用户的文件库，所以此图片可能存在多个地方共用的情况，所以要删除文件系统中的文件需要到图片库由用户确认后再删除。

### 6.1 Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("删除课程图片")
    ResponseResult deleteCoursePic(String courseId);
}
```



### 6.2 Dao

原有的删除方法没有返回值，需要自定义

```java
public interface CoursePicRepository extends JpaRepository<CoursePic,String> {
    //返回影响的行数
    long deleteByCourseid(String courseId);
}
```



### 6.3 Service

```java
@Service
public class CourseService {
    @Transactional
    public ResponseResult deleteCoursePic(String courseId) {
        long row = coursePicRepository.deleteByCourseid(courseId);
        if (row>0){
            return new ResponseResult(CommonCode.SUCCESS);
        }
        return new ResponseResult(CommonCode.FAIL);
    }
}
```



### 6.4 Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @DeleteMapping("/coursepic/delete")
    public ResponseResult deleteCoursePic(String courseId) {
        return courseService.deleteCoursePic(courseId);;
    }
}
```



### 6.5 前端

在upload组件的before-remove钩子方法中实现删除动作。before-remove说明：

==删除文件之前的钩子，参数为上传的文件和文件列表，若**返回 false** 或者**返回 Promise 且被reject**，则**停止删除**。==

```js
//删除图片
handleRemove(file, fileList) {
    console.log(file)
    // return true;
    //删除图片
    courseApi.deleteCoursePic('1').then((res) => {
        if(res.success){
            this.$message.success('删除成功');
            return true;
        }else{
            this.$message.error(res.message);
            return false;
        }
    });
},
```

before-remove钩子方法中若调用Axios（使用Promise编写的HTTP异步请求方法），由于后端有异常处理，无论什么都会有统一格式的返回，所以对before-remove钩子方法来说，返回总是Promise的resolve状态。由于异步！所以此时已经删除了，不会等待判断后端返回是true或false。所以方法应改写如下

```js
//删除图片
handleRemove(file, fileList) {
    console.log(file)
    return new Promise((resolve,reject)=>{
        //删除图片
        courseApi.deleteCoursePic(this.courseid).then((res) => {
            if(res.success){
                this.$message.success('删除成功');
                resolve()//通过
            }else{
                this.$message.error(res.message);
                reject()//拒绝
            }
        });
    })
}
```



# 9 课程预览/发布 Eureka/Feign

> Eureka [jʊ'riːkə] 。vi：（因找到某物，尤指问题的答案而高兴）我发现了
>
> Feign [fen]。vt：假装，伪装；vi：假装； 装作



## 1 Eureka注册中心

在前后端分离架构中，服务层被拆分成了很多的微服务，Spring Cloud中提供服务注册中心来管理微服务信息。

为什么要用注册中心？

1、微服务数量众多，要进行**远程调用**就需要**知道**服务端的**ip地址和端口**，注册中心帮助我们管理这些服务的ip和端口。

2、微服务会实时上报自己的状态，**注册中心**统一**管理这些微服务的状态**，将存在问题的服务踢出服务列表，客户端获取到可用的服务进行调用。



### 1.1 Eureka介绍

Spring Cloud Eureka 是对**Netflix**公司的**Eureka的二次封装**，它实现了**服务治理**的功能，Spring Cloud Eureka提供服务端与客户端，**服务端即是Eureka服务注册中心**，**客户端完成微服务向Eureka服务的注册与发现**。服务端和客户端均采用Java语言编写。下图显示了Eureka Server与Eureka Client的关系：

![1551374469172](images/1551374469172.png)

1、Eureka Server是服务端，负责**管理各个微服务结点的信息和状态**。

2、在**微服务上部署Eureka Client程序**，**远程访问Eureka Server将自己注册在Eureka Server**。

3、微服务需要调用另一个微服务时**从Eureka Server中获取服务调用地址**，进行**远程调用**。



### 1.2 Eureka Server搭建

#### 1.2.1 单机环境搭建

1. 创建xc-govern-center工程，包结构：com.xuecheng.govern.center

2. 添加Spring Cloud依赖，在父工程添加（有了则不用重复添加）

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring‐cloud‐dependencies</artifactId>
       <version>Finchley.SR1</version>
       <type>pom</type>
       <scope>import</scope>
   </dependency>
   ```

   在Eureka Server工程添加：

   ```xml
   <dependencies>
       <!--导入Eureka服务的依赖-->
       <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
           </dependency>
   </dependencies>
   ```

3. Spring Boot 启动类

   ```java
   @EnableEurekaServer//标识这是一个Eureka服务
   @SpringBootApplication
   public class GovernCenterApplication {
       public static void main(String[] args) {
           SpringApplication.run(GovernCenterApplication.class, args);
       }
   }
   ```

   > Govern ['ɡʌvərn] ，v.治理；控制；管理；统治

   **`@EnableEurekaServer`**，标识此服务为Eureka服务

4. 从其它服务拷贝application.yml和logback-spring.xml

   ```yaml
   server:
     port: 50101 #服务端口
   spring:
     application:
       name: xc‐govern‐center #指定服务名
   eureka:
     server:
       enable-self-preservation: false #是否开启自我保护模式
       eviction-interval-timer-in-ms: 60000 #服务注册表清理间隔（单位毫秒，默认是60*1000）。这个时间段内如果没有收到该结点的上报则将结点从服务列表中剔除
     client:
       registerWithEureka: false #服务注册，是否将自己注册到Eureka服务中，被其它服务调用时需向Eureka注册
       fetchRegistry: false #服务发现，是否从Eureka中获取注册信息，需要从Eureka中查找要调用的目标服务时需要设置为true
       serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方服务器的地址，单机状态配置自己（如果不配置则默认本机8761端口）
         defaultZone: http://localhost:50101/eureka/
   ```

5. 启动Eureka Server，浏览50101端口

   红色提示信息：`THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.`自我保护模式被关闭。在网络或其他问题的情况下可能不会保护实例失效。

   Eureka Server有一种自我保护模式，当微服务不再向Eureka Server上报状态，Eureka Server会从服务列表将此服务删除，如果出现网络异常情况（微服务正常），此时Eureka server进入自保护模式，不再将微服务从服务列表删除。在开发阶段建议关闭自保护模式。



#### 1.2.2 高可用环境搭建

Eureka Server 高可用环境需要部署两个Eureka server，它们**互相向对方注册**。如果在本机启动两个Eureka需要注意两个Eureka Server的端口要设置不一样，这里我们部署一个Eureka Server工程，将端口可配置，制作两个Eureka Server启动脚本，启动不同的端口，如下图：

![1551377211536](images/1551377211536.png)

1、在实际使用时Eureka Server至少部署两台服务器，实现高可用。

2、两台Eureka Server互相注册。

3、微服务需要连接两台Eureka Server注册，当其中一台Eureka死掉也不会影响服务的注册与发现。

4、微服务会定时向Eureka server发送心跳，报告自己的状态。

5、微服务从注册中心获取服务地址以RESTful方式发起远程调用。

配置如下（启动类配置`@EnableEurekaServer`）：

1. 端口可配置

   ```yaml
   server:
     port: ${PORT:50101} #服务端口
   ```

2. Eureka客户端与Eureka服务端的交互地址可配置

   ```yaml
   eureka:
     client:
       register-with-eureka: false #服务注册，是否将自己注册到Eureka服务中，被其它服务调用时需向Eureka注册
       fetch-registry: false #服务发现，是否从Eureka中获取注册信息，需要从Eureka中查找要调用的目标服务时需要设置为true
       serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方服务器的地址，单机状态配置自己（如果不配置则默认本机8761端口）
         defaultZone: ${EUREKA_SERVER:http://eureka02:50102/eureka/}
   ```

3. 配置hostname

   Eureka 组成高可用，两个Eureka**互相向对方注册**，这里需要**通过域名或主机名访问**，这里我们设置两个Eureka服务的主机名分别为 eureka01、eureka02。完整的Eureka配置如下：

   ```yaml
   server:
     port: ${PORT:50101} #服务端口
   spring:
     application:
       name: xc‐govern‐center #指定服务名
   
   eureka:
     server:
       enable-self-preservation: false #是否开启自我保护模式
       eviction-interval-timer-in-ms: 60000 #服务注册表清理间隔（单位毫秒，默认是60*1000）。这个时间段内如果没有收到该结点的上报则将结点从服务列表中剔除
     client:
       registerWithEureka: false #服务注册，是否将自己注册到Eureka服务中，被其它服务调用时需向Eureka注册
       fetchRegistry: false #服务发现，是否从Eureka中获取注册信息，需要从Eureka中查找要调用的目标服务时需要设置为true
       serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方服务器的地址，单机状态配置自己（如果不配置则默认本机8761端口）
         defaultZone: ${EUREKA_SERVER:http://eureka02:50102/eureka/}
     instance:
       hostname: ${EUREKA_DOMAIN:eureka01}
   ```

   还需配置hosts

   ```
   127.0.0.1 eureca01
   127.0.0.1 eureca02
   ```

4. 在IDEA中制作启动脚本，设置环境变量，在VM options中分别配置：

   - `-DPORT=50101 -DEUREKA_SERVER=http://eureka02:50102/eureka/ -DEUREKA_DOMAIN=eureka01`
   - `-DPORT=50102 -DEUREKA_SERVER=http://eureka01:50101/eureka/ -DEUREKA_DOMAIN=eureka02`

5. 运行两个启动脚本，分别浏览 http://localhost:50101/ 和 http://localhost:50102/

6. 以50101端口为例。DS Replicas为副本名称，Instances为注册在Eureka中的实例

   ![1551379518691](images/1551379518691.png)



### 1.3 Eureka Client服务注册

下边实现cms向Eureka Server注册

1. 在cms服务中添加依赖

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
   </dependency>
   ```

2. 在application.yml添加配置Eureka的信息

   ```yaml
   server:
     port: ${PORT:31001}
   spring:
     application:
       name: xc-service-manage-cms
         
   eureka:
     client:
       registerWithEureka: true #服务注册开关
       fetchRegistry: true #服务发现开关
       serviceUrl: #Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔
         defaultZone: ${EUREKA_SERVER:http://localhost:50101/eureka/,http://localhost:50102/eureka/}
     instance:
       prefer-ip-address:  true  #将自己的ip地址注册到Eureka服务中
       ip-address: ${IP_ADDRESS:127.0.0.1}
       instance-id: ${spring.application.name}:${server.port} #指定实例id
   ```

3. 在启动类上添加**注解`@EnableEurekaClient`**，表示它是一个Eureka的客户端，可以从Eureka远程调用服务。启动服务

   也可以配置**`@EnableDiscoveryClient`**，在使用其他注册中心时需要使用这个通用的

4. 以Eureka Server的50101端口为例

   ![1551381678754](images/1551381678754.png)

   

> 同理将manage-course注册到Eureka Server



## 2 Feign远程调用

在前后端分离架构中，服务层被拆分成了很多的微服务，服务与服务之间难免发生交互，比如：课程发布需要调用CMS服务生成课程静态化页面，本节研究微服务远程调用所使用的技术。下图是课程管理服务远程调用CMS服务的流程图：

![1551381915725](images/1551381915725.png)

1、cms服务将自己注册到注册中心。

2、课程管理服务从注册中心获取cms服务的地址。

3、课程管理服务远程调用cms服务。

### 2.1 Ribbon

#### 2.1.1 Ribbon 简介

[Ribbon](https://github.com/Netflix/ribbon)是Netflix公司开源的一个负载均衡的项目，它是一个基于HTTP、TCP的==**客户端负载均衡器**==。

1、什么是负载均衡？

负载均衡是微服务架构中必须使用的技术，**通过负载均衡来实现系统的高可用、集群扩容等功能**。负载均衡可通过硬件设备及软件来实现，硬件比如：F5、Array等，软件比如：LVS、Nginx等。如下图是负载均衡的架构图：

![1551382033658](images/1551382033658.png)

用户请求先到达负载均衡器（也相当于一个服务），负载均衡器根据负载均衡算法将请求转发到微服务。负载均衡算法有：轮训、随机、加权轮训、加权随机、地址哈希等方法，负载均衡器维护一份服务列表，根据负载均衡算法将请求转发到相应的微服务上，所以负载均衡可以为微服务集群分担请求，降低系统的压力。

2、什么是**客户端负载均衡**？

上图是服务端负载均衡，客户端负载均衡与服务端负载均衡的区别在于**客户端要维护一份服务列表**，Ribbon从Eureka Server获取服务列表，Ribbon根据负载均衡算法直接请求到具体的微服务，中间省去了负载均衡服务。如下图是Ribbon负载均衡的流程图：

![1551382153266](images/1551382153266.png)

1、在消费微服务中使用Ribbon实现负载均衡，Ribbon先从EurekaServer中获取服务列表。

2、Ribbon根据负载均衡的算法去调用微服务。



#### 2.1.2 Ribbon测试

Spring Cloud引入Ribbon 配合 restTemplate 实现客户端负载均衡调用。Java中远程调用的技术有很多，如：webservice、socket、rmi、Apache HttpClient、OkHttp等，互联网项目使用基于http的客户端较多，本项目使用OkHttp。

1. 在**客户端**添加Ribbon依赖（这里在**课程管理服务**配置ribbon依赖，来请求**CMS**服务端），由于依赖了spring-cloud-starter-eureka-***，会自动添加spring-cloud-starter-ribbon依赖。只需额外配置okhttp依赖。

2. 配置Ribbon参数（这里在课程管理服务的application.yml中配置ribbon参数，不配置也可以（IDEA提示属性不能解析））

   ```yaml
   ribbon:
     MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试
     MaxAutoRetriesNextServer: 3 #切换实例的重试次数
     OkToRetryOnAllOperations: false  #对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false
     ConnectTimeout: 5000  #请求连接的超时时间
     ReadTimeout: 6000 #请求处理的超时时间
   ```

3. **负载均衡测试**

   1. 启动两个cms服务，注意端口要不一致（还是利用 VM options，参考之前的写法，如`${PORT:31001}`）

   2. 在课程管理服务的启动类中**配置RestTemplate**

      ```java
      @Bean
      @LoadBalanced//开启客户端负载均衡
      public RestTemplate restTemplate(){
          return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
      }
      ```

   3. 课程管理服务中测试类请求CMS服务

      ```java
      @SpringBootTest
      @RunWith(SpringRunner.class)
      public class TestRibbon {
          @Autowired
          private RestTemplate restTemplate;
      
          @Test
          public void testRibbon() {
              //确定要获取的服务名（实例id，大小写无所谓）
              String serviceId = "XC-SERVICE-MANAGE-CMS";
              for (int i = 0; i < 10; i++) {
                  //Ribbon客户端从EurekaServer中获取服务列表,根据服务名获取服务列表
                  ResponseEntity<Map> forEntity = restTemplate.getForEntity("http://" + serviceId + "/cms/page/get/5a754adf6abb500ad05688d9", Map.class);
                  Map body = forEntity.getBody();
                  System.out.println(body);
              }
          }
      }
      ```

   添加@LoadBalanced注解后，restTemplate会走LoadBalancerInterceptor拦截器，此拦截器中会通过
   **`RibbonLoadBalancerClient`**查询服务地址，在此类打断点观察每次调用的服务地址和端口，两个cms服务会轮流被调用

   ![1551430371106](images/1551430371106.png)

   




### 2.2 Feign

Feign是Netflix公司开源的轻量级**rest客户端**，使用Feign可以非常方便的实现Http 客户端。Spring Cloud引入**Feign并且集成了Ribbon实现客户端负载均衡调用**。

1. 在客户端添加依赖（课程管理服务添加下边的依赖）

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-openfeign</artifactId>
   </dependency>
   ```

2. 定义**`FeignClient`接口**，参考Swagger文档，注意接口的Url、请求参数类型、返回值类型与Swagger接口一致。

   本次实例在课程管理服务中创建client包，定义查询cms页面的客户端该用接口

   ```java
   @FeignClient("XC-SERVICE-MANAGE-CMS")//指定远程调用的服务名，不区分大小写
   public interface CmsPageClient {
   
       //根据页面id查询页面信息，远程调用cms请求数据
       @GetMapping("/cms/page/get/{id}")//用GetMapping标识远程调用的http的方法类型
       CmsPage findById(@PathVariable String id);
   
   }
   ```

3. Spring Boot 启动类上**添加`@EnableFeignClients`注解**

4. 远程调用测试

   ```java
   @SpringBootTest
   @RunWith(SpringRunner.class)
   public class TestFeign {
       @Autowired
       private CmsPageClient cmsPageClient; //接口代理对象，由Feign生成代理对象
   
       @Test
       public void testRibbon() {
           //发起远程调用
           CmsPage cmsPage = cmsPageClient.findById("5a754adf6abb500ad05688d9");
           System.out.println(cmsPage);
       }
   }
   ```

【注意】SpringCloud对Feign进行了增强兼容了SpringMVC的注解 ，我们在使用SpringMVC的注解时需要注意：

* feignClient接口 有参数在参数必须加@PathVariable("XXX")和@RequestParam("XXX")
* feignClient**返回值为复杂对象时其类型必须有无参构造函数**（利用lombok的`@NoArgsContructor`）







## 3 课程预览—页面静态化

### 3.1 技术方案

课程预览是为了保证课程发布后的正确性，通过课程预览可以直观的通过课程详情页面看到课程的信息是否正确，通过**课程预览**看到的页面内容和课程发布后的**页面详情内容**是**一致**的。

课程详情页面技术方案：

* 技术需求

  * 课程详情页面是向用户展示课程信息的窗口，课程相当于网站的商品，本页面的**访问量会非常大**。
  * **SEO**，要非常有利于爬虫抓取页面上信息，并且生成页面快照，利于用户通过搜索引擎搜索课程信息。

* 解决方案：

  对于不会频繁改变的信息可以采用**页面静态化**的技术，提前让页面生成html静态页面存储在nginx服务器，用户直接访问nginx即可，对于一些**动态信息可以访问服务端获取json数据**在页面渲染。

  ![1551437588132](images/1551437588132.png)

  * 优点：使用Nginx作为web服务器，并且直接访问html页面，性能出色。
  * 缺点：需要维护大量的静态页面，增加了维护的难度。

* 操作流程：

  1. 制作课程详情页面**模板**
  2. 开发课程详情页面**数据模型的查询接口**（为静态化提供数据）
  3. **调用cms课程预览接口**通过浏览器**浏览静态文件**

  



### 3.2 课程详情页面静态化

#### 3.2.1 页面内容组成及拆分

利用SSI技术进行页面拆分：

* 页头：include\header.html
* 页尾：include\footer.html
* 课程详情主页面：课程id.html（课程id动态变化）
* 教育机构页面：company_info_公司id.html（公司id动态变化）
* 老师信息页面：teacher_info_教师id.html（教师id动态变化）
* 课程统计页面：course_stat_课程id.**json**（课程id动态变化）
* 教育机构统计页面：company_stat_公司id.**json**（公司id动态变化）



#### 3.2.2 静态页面测试

##### 1、页面加载思路

- 我们需要在主页面中通过SSI加载：页头、页尾、教育机构、教师信息
- 异步加载课程统计与教育机构统计信息，都是JSON
- 用户点击“马上学习”会根据课程收费情况、课程购买情况执行下一步操作

##### 2、静态资源虚拟主机

1. 静态资源虚拟主机负责处理课程详情、公司信息、老师信息、统计信息等页面的请求

   将课程资料中的“静态页面目录”中的static目录拷贝到D:\Code-Workspace\_Project\xcEdu\xcEduUI目录下

   在nginx中配置静态虚拟主机如下（上面拷贝的static中资源，访问`localhost:91`时就访问该资源。单独配置好管理）：

   ```nginx
   #学成网静态资源
   server {
   	listen 91;
   	server_name localhost;
   
   	#公司信息
   	location /static/company/ {
   		alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/static/company/;
   	}
   	#老师信息
   	location /static/teacher/ {
   		alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/static/teacher/;
   	}
   	#统计信息
   	location /static/stat/ {
   		alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/static/stat/;
   	}
   	location /course/detail/ {
   		alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/static/course/detail/;
   	}
   }
   ```

2. 由于课程页面需要通过SSI加载页头和页尾所以需要通过www.xuecheng.com虚拟主机转发到静态资源

   将通过访问www.xuecheng.com，映射到1中的静态资源

   ```nginx
   #静态资源服务
   upstream static_server_pool{
   	server 127.0.0.1:91 weight=10;
   }
   
   server{
   	listen 80;
   	server_name www.xuecheng.com;
   	
   	ssi on;
   	ssi_silent_errors on;
   	
   	location /static/company/ {
   		proxy_pass http://static_server_pool;
   	}
   	location /static/teacher/ {
   		proxy_pass http://static_server_pool;
   	}
   	location /static/stat/ {
   		proxy_pass http://static_server_pool;
   	}
   	location /course/detail/ {
   		proxy_pass http://static_server_pool;
   	}
   }
   ```

##### 3、门户静态资源路径

门户中的一些图片、样式等静态资源统一通过/static路径对外提供服务，在www.xuecheng.com虚拟主机中配置如下：

添加在2的第2步骤中server

```nginx
#静态资源，包括系统所需要的图片，js、css等静态资源
location /static/img/ {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/img/;
}
location /static/css/ {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/css/;
}
location /static/js/ {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/js/;
}
location /static/plugins/ {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/plugins/;
	add_header Access‐Control‐Allow‐Origin http://ucenter.xuecheng.com;
	add_header Access‐Control‐Allow‐Credentials true;
	add_header Access‐Control‐Allow‐Methods GET;
}
```

CORS跨域参数：

* Access-Control-Allow-Origin：允许跨域访问的外域地址。如果允许任何站点跨域访问则设置为*，通常这是不建议的。

* Access-Control-Allow-Credentials： 允许客户端携带证书访问

* Access-Control-Allow-Methods：允许客户端跨域访问的方法

##### 4、测试

请求：http://www.xuecheng.com/course/detail/course_main_template.html测试课程详情页面模板



##### 5、页面动态脚本

为了方便日后的维护，我们将javascript实现的动态部分单独编写一个 html 文件，在门户的include目录下定义course_detail_dynamic.html文件，此文件通过ssi包含在课程详情页面中。所有的课程公用一个 页面动态脚本。

在课程详情主页面下端添加如下代码，通过SSI技术包含课程详情页面动态脚本文件：

```html
<body>
	<!--省略...-->
    <script>var courseId = "template"</script>
    <!‐‐#include virtual="/include/course_detail_dynamic.html"‐‐>
</body>
```

请求的是当前域名即`协议:IP:端口`下的/include/course_detail_dynamic.html，会被之前做的如下配置映射

```nginx
location / {
	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/xc-ui-pc-static-portal/;
	index index.html;
}
```



### 3.3 课程数据模型查询

#### 1、数据模型

```java
@Data
@NoArgsConstructor
public class CourseView implements Serializable {

    private CourseBase courseBase;//基础信息
    private CoursePic coursePic;//课程图片
    private CourseMarket courseMarket;//课程营销
    private TeachplanNode teachplanNode;//教学计划
}
```

#### 2、Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("课程视图查询")
    CourseView courseview(String id);
}
```

#### 3、Dao

略

#### 4、Service

```java
public CourseView getCourseView(String id) {
    CourseView courseView = new CourseView();
    //查询课程基本信息
    Optional<CourseBase> baseOptional = courseBaseRepository.findById(id);
    baseOptional.ifPresent(courseView::setCourseBase);//lambda中方法引用
    //查询课程图片信息
    Optional<CoursePic> picOptional = coursePicRepository.findById(id);
    picOptional.ifPresent(courseView::setCoursePic);
    //查询课程营销信息
    Optional<CourseMarket> marketOptional = courseMarketRepository.findById(id);
    marketOptional.ifPresent(courseView::setCourseMarket);
    //查询课程计划信息（使用MyBatis）
    TeachplanNode teachplanNode = teachplanMapper.selectList(id);
    courseView.setTeachplanNode(teachplanNode);
    return courseView;
}
```

#### 5、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @GetMapping("/courseview/{id}")
    public CourseView courseview(@PathVariable String id) {
        return courseService.getCourseView(id);
    }
}
```

swagger测试



### 3.4 课程信息模板设计

在确定了静态化所需要的数据模型之后，就可以编写页面模板了，课程详情页面由多个静态化页面组成，所以我们需要创建多个页面模板，本章节创建**课程详情页面的主模板**，**即课程信息模板**。（此处就不从HTML改写为ftl）

#### 3.4.1 模板测试

使用test-freemarker工程测试模板

将course.ftl拷贝到test-freemarker工程的resources/templates下，并在test-freemarker工程的controller中添加测试方法

```java
@RequestMapping("/courseview")
public String courseview(Map<String, Object> map) {
    ResponseEntity<Map> entity = restTemplate.getForEntity("http://localhost:31200/course/courseview/4028e581617f945f01617f9dabc40000", Map.class);
    map.putAll(entity.getBody());
    return "course";
}
```

注意：上边的测试页面不显示样式，原因是页面通过SSI包含了页面头，而使用test-freemarker工程使用Tomcat无法加载页头



#### 3.4.2 模板保存

模板编写并测试通过后要在数据库保存：

1、模板信息保存在xc_cms数据库(mongodb)的cms_template表

2、模板文件保存在mongodb的GridFS中。

模板的保存应该编写在CMS服务中，由CMS前端来管理保存。此处使用手动方式😁：

第一步：在CMS服务中测试方法将模板文件上传到GridFS中，记录模板文件的id

第二步：向cms_template表添加模板记录（不要重复添加），最重要的是修改第一步中的文件id到cms_template中



#### 3.4.3 其它模板

除了课程详情主页面需要设计模板所有静态化的页面都要设计模板，如下：教育机构页面模板、教师信息页面模板、课程统计信息json模板、教育机构统计信息json模板。本项目我们实现课程详情主页面模板的制作和测试，其它页面模板的开发参考课程详情页面去实现。



### 3.5 课程预览功能开发

#### 3.5.1 需求分析

课程预览功能将使用cms系统提供的页面预览功能，业务流程如下：

1、用户进入课程管理页面，点击课程预览，请求到课程管理服务。传入课程id

2、**课程管理服务远程调用cms添加页面接口向cms添加课程详情页面**（**包括dataUrl**，请求数据模型；**模板文件id**）

3、课程管理服务得到cms返回**课程详情页面id**，并拼接生成课程预览Url

4、课程管理服务将课程预览Url给前端返回

5、用户在前端页面请求课程预览Url，打开新窗口显示课程详情内容

![1551457274579](images/1551457274579.png)

该图下部分已经在CMS中开发成功，只需要开发上面服务间远程调用添加页面

#### 3.5.2 CMS页面预览测试

CMS已经提供了页面预览功能，课程预览功能要使用CMS页面预览接口实现，下边通过cms页面预览接口测试课程预览的效果。

1、向cms_page表插入一条页面记录或者从cms_page找一个页面进行测试。需设置正确的**模板id和dataUrl**。

2、课程详细页面使用SSI注意。由于Nginx先请求cms的课程预览功能得到html页面，再解析页面中的ssi标签，这里必须保证cms页面预览返回的页面的**Content-Type**。`response.setContentType("text/html;charset=utf-8");`

3、请求http://www.xuecheng.com/cms/preview/5af942190e661827d8e2f5e3传入页面Id



#### 3.5.3 CMS添加页面（2）

cms服务对外提供添加页面接口，实现：如果不存在页面则添加，否则就更新页面信息。·由课程管理服务在课程预览时调用。

##### 1、Api

```java
@Api(value="cms页面管理接口",description = "cms页面管理接口，提供页面的增、删、改、查")
public interface CmsPageControllerApi {
    @ApiOperation("保存页面")
    CmsPageResult save(CmsPage cmsPage);
}
```

##### 2、Dao

略

##### 3、Service

```java
//添加页面，如果已存在则更新页面
@Transactional
public CmsPageResult save(CmsPage cmsPage) {
    //校验页面是否存在，根据页面名称、站点Id、页面webpath查询
    CmsPage page = cmsPageRepository.findBySiteIdAndPageNameAndPageWebPath(cmsPage.getSiteId(), cmsPage.getPageName(), cmsPage.getPageWebPath());
    if (!Objects.isNull(page)){
        //更新
        return this.edit(page.getPageId(),cmsPage);
    }
    //添加
    return this.add(cmsPage);
}
```



##### 4、Controller

```java
@RestController
@RequestMapping("/cms/page")
public class CmsPageController implements CmsPageControllerApi {
    @Override
    @PostMapping("/save")
    public CmsPageResult save(@RequestBody CmsPage cmsPage) {
        return cmsPageService.save(cmsPage);
    }
}
```



#### 3.5.4 课程预览服务端—Feign（1）

##### 1、Api

此Api是课程管理前端请求服务端进行课程预览的Api。请求：**课程Id**；响应：**课程（页面）预览Url**

```java
@Data
@NoArgsConstructor
public class CoursePublishResult extends ResponseResult {
    String previewUrl;
    public CoursePublishResult(ResultCode resultCode, String previewUrl) {
        super(resultCode);
        this.previewUrl = previewUrl;
    }
}
```

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("预览课程")
    CoursePublishResult preview(String id);
}
```



##### 2、Feign Client

在课程管理工程创建CMS服务的Feign Client，通过此Client远程请求cms添加页面。

```java
@FeignClient("XC-SERVICE-MANAGE-CMS")//指定远程调用的服务名，不区分大小写
public interface CmsPageClient {
    //保存页面
    @PostMapping("/cms/page/save")
    CmsPageResult save(@RequestBody CmsPage cmsPage);

}
```



##### 3、Service

配置添加页面参数信息

```yml
course-publish:
  siteId: 5c795e2eeca6683e005e1795
  templateId: 5aec5dd70e661808240ab7a6
  previewUrl: http://www.xuecheng.com/cms/preview/
  pageWebPath: /course/detail/
  pagePhysicalPath: /course/detail/
  dataUrlPre: http://localhost:31200/course/courseview/
```

```java
@Value("${course-publish.dataUrlPre}")
private String publish_dataUrlPre;
@Value("${course-publish.pagePhysicalPath}")
private String publish_page_physicalpath;
@Value("${course-publish.pageWebPath}")
private String publish_page_webpath;
@Value("${course-publish.siteId}")
private String publish_siteId;
@Value("${course-publish.templateId}")
private String publish_templateId;
@Value("${course-publish.previewUrl}")
private String previewUrl;

@Autowired
private CmsPageClient cmsPageClient;

public CoursePublishResult preview(String courseId) {
    CourseBase courseBase = this.findCourseBaseById(courseId);

    //发布课程预览页面
    CmsPage cmsPage = new CmsPage();
    cmsPage.setSiteId(publish_siteId);//课程预览站点
    cmsPage.setPageName(courseId + ".html");//页面名称
    cmsPage.setPageAliase(courseBase.getName());//页面别名
    cmsPage.setPageWebPath(publish_page_webpath);//页面访问路径
    cmsPage.setPagePhysicalPath(publish_page_physicalpath);//页面存储路径
    cmsPage.setDataUrl(publish_dataUrlPre + courseId);//数据url
    cmsPage.setTemplateId(publish_templateId);//模板

    //远程请求cms保存页面信息！且需要给CmsPageResult添加无参构造方法！！！！！！！！！！！！！！
    CmsPageResult cmsPageResult = cmsPageClient.save(cmsPage);
    if (!cmsPageResult.isSuccess()){
        return new CoursePublishResult(CommonCode.FAIL,null);
    }
    String pageId = cmsPageResult.getCmsPage().getPageId();//页面id
    String url = previewUrl+pageId;//页面url
    return new CoursePublishResult(CommonCode.SUCCESS,url);

}

//根据id查询课程基本信息
private CourseBase findCourseBaseById(String courseId) {
    Optional<CourseBase> optional = courseBaseRepository.findById(courseId);
    if (optional.isPresent()) {
        return optional.get();
    }
    ExceptionCast.cast(CourseCode.COURSE_PUBLISH_VIEWERROR);
    return null;
}
```



##### 4、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @PostMapping("/preview/{id}")//也可以get
    public CoursePublishResult preview(@PathVariableString id) {
        return courseService.preview(id);
    }
}
```

请求课程预览URL

```java
@Controller//需要Response输出
public class CmsPagePreviewController extends BaseController {

    @Autowired
    private CmsPageService cmsPageService;

    //根据页面id来生成静态页面内容
    @GetMapping("/cms/preview/{pageId}")
    public void preview(@PathVariable("pageId") String pageId) {
        String pageHtml = cmsPageService.getPageHtml(pageId);
        if (!StringUtils.isEmpty(pageHtml)){
            try {
                response.setContentType("text/html;charset=utf-8");
                response.getOutputStream().write(pageHtml.getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



swagger测试



#### 3.5.5 前端

略



## 4 课程发布—页面静态化

### 4.1 需求分析

课程发布后将生成正式的课程详情页面，课程发布后用户即可浏览课程详情静态HTML页面，并开始课程的学习。

课程发布生成课程详情页面的流程与课程预览业务流程相同，如下：

1、用户进入教学管理中心，进入某个课程的管理界面

2、点击课程发布，前端请求到课程管理服务

3、课程管理服务远程调用CMS生成课程发布页面，CMS将课程详情页面发布到服务器

4、课程管理服务修改课程发布状态为 “已发布”，并向前端返回发布成功

5、用户在教学管理中心点击“课程详情页面”链接，查看课程详情页面内容

![1551467864865](images/1551467864865.png)

==和预览一样，前端给课程管理的只有**课程id**，需要**先调用CMS的添加课程服务**（有则修改，无则添加），并根据添加的**页面信息**进行**静态化**。进行页面静态化后，将**CMS服务将HTML页面保存到GridFS**中，并通过**MQ**向CMS Client发送消息，让它**下载页面到所属站点的服务器中**；与此同时CMS服务**返回发布结果**和页面的在服务器中的**URL**，课程管理服务**修改课程状态**，返回发布结果的URL。即可打开静态HTML页面==

### 4.2 CMS一键发布接口（2）

为了不像预览一样，需要课程管理服务两次调用接口，所以重新编写一次发布接口供课程管理服务调用，此接口的功能如下：

1、接收课程管理服务发布的页面信息

2、将页面信息添加到 数据库（mongodb）

3、对页面信息进行静态化（已实现）

4、将页面信息发布到服务器（已实现）



#### 1、Api

创建响应结果类型：页面发布成功cms返回页面的url

`页面Url= cmsSite.siteDomain+cmsSite.siteWebPath+ cmsPage.pageWebPath + cmsPage.pageName`

```java
@Data
@NoArgsConstructor
public class CmsPostPageResult extends ResponseResult {
    String pageUrl;

    public CmsPostPageResult(ResultCode resultCode, String pageUrl) {
        super(resultCode);
        this.pageUrl = pageUrl;
    }
}
```

```java
@Api(value="cms页面管理接口",description = "cms页面管理接口，提供页面的增、删、改、查")
public interface CmsPageControllerApi {
    @ApiOperation("一次发布接口")
    CmsPostPageResult postPageQuick(CmsPage cmsPage);
}
```



#### 2、Controller

```java
@RestController
@RequestMapping("/cms/page")
public class CmsPageController implements CmsPageControllerApi {
    @Override
    @PostMapping("/postPageQuick")
    public CmsPostPageResult postPageQuick(@RequestBody CmsPage cmsPage) {
        return cmsPageService.postPageQuick(cmsPage);
    }
}
```



#### 3、Service

```java
public CmsPostPageResult postPageQuick(CmsPage cmsPage) {
    ///将页面保存到cms_page集合中
    CmsPageResult save = this.save(cmsPage);
    if (Objects.isNull(save)) {
        ExceptionCast.cast(CommonCode.FAIL);
    }
    //的到保存的页面
    CmsPage saveCmsPage = save.getCmsPage();
    //得到页面id
    String pageId = saveCmsPage.getPageId();
    //执行页面发布（静态化、保存到GridFS、想MQ发消息）
    ResponseResult responseResult = this.post(pageId);
    if (!responseResult.isSuccess()) {
        ExceptionCast.cast(CommonCode.FAIL);
    }
    //拼接URL
    String siteId = saveCmsPage.getSiteId();
    CmsSite cmsSite = this.findCmsSiteById(siteId);
    String pageUrl = cmsSite.getSiteDomain() + cmsSite.getSiteWebPath() + saveCmsPage.getPageWebPath() + saveCmsPage.getPageName();

    return new CmsPostPageResult(CommonCode.SUCCESS, pageUrl);

}

//根据id查询站点信息
private CmsSite findCmsSiteById(String siteId) {
    Optional<CmsSite> optional = cmsSiteRepository.findById(siteId);
    return optional.orElse(null);
}
```



#### 4、Dao

略



### 4.3 课程发布接口（1）



#### 1、Api

```java
@Api(value="课程管理接口",description = "课程管理接口，提供课程的增、删、改、查")
public interface CourseControllerApi {
    @ApiOperation("发布课程")
    CoursePublishResult publish(String id);
}
```



#### 2、Controller

```java
@RestController
@RequestMapping("/course")
public class CourseController implements CourseControllerApi {
    @Override
    @PostMapping("/publish/{id}")
    public CoursePublishResult publish(@PathVariable String id) {
        return courseService.publish(id);
    }
}
```



#### 3、Service

配置信息和课程预览中一致！！！

```java
@Transactional
public CoursePublishResult publish(String courseId) {
    CourseBase courseBase = this.findCourseBaseById(courseId);

    //发布课程预览页面
    CmsPage cmsPage = new CmsPage();
    cmsPage.setSiteId(publish_siteId);//课程预览站点
    cmsPage.setPageName(courseId + ".html");//页面名称
    cmsPage.setPageAliase(courseBase.getName());//页面别名
    cmsPage.setPageWebPath(publish_page_webpath);//页面访问路径
    cmsPage.setPagePhysicalPath(publish_page_physicalpath);//页面存储路径
    cmsPage.setDataUrl(publish_dataUrlPre + courseId);//数据url
    cmsPage.setTemplateId(publish_templateId);//模板

    //调用CMS一键发布接口，将课程详细页面发布到服务器
    CmsPostPageResult result = cmsPageClient.postPageQuick(cmsPage);
    if (!result.isSuccess()){
        return new CoursePublishResult(CommonCode.FAIL,null);
    }
    //保存课程发布状态为已发布
    CourseBase base = saveCoursePubState(courseId);
    if (Objects.isNull(base)){
        ExceptionCast.cast(CommonCode.FAIL);
    }


    //保存课程索引信息

    //缓存课程信息

    String pageUrl = result.getPageUrl();
    return new CoursePublishResult(CommonCode.SUCCESS,pageUrl);
}

//更新课程状态为已发布（根据数据字典中已发布为202002）
private CourseBase saveCoursePubState(String courseId){
    CourseBase courseBase = this.findCourseBaseById(courseId);
    courseBase.setStatus("202002");
    courseBaseRepository.save(courseBase);
    return courseBase;
}
```



#### 4、Feign Client

```java
@FeignClient("XC-SERVICE-MANAGE-CMS")//指定远程调用的服务名，不区分大小写
public interface CmsPageClient {

    //一键发布
    @PostMapping("cms/page/postPageQuick")
    CmsPostPageResult postPageQuick(@RequestBody CmsPage cmsPage);
}
```



Nginx中已配置虚拟主机（3.2中），swagger测试



### 4.4 测试

1、启动RabbitMQ服务

2、启动cms服务

3、启动cms_client，注意配置routingKey和队列名称

```yaml
xuecheng:
  mq:
    queue: queue_cms_postpage_05 #客户端监控的队列名称（不同的客户端监控的队列不能重复）
    routingKey: 5c795e2eeca6683e005e1795	#此routingKey为课程详情站点ID
```





# 10 课程搜索服务

## 1 课程搜索需求分析

1、根据分类搜索课程信息。

2、根据关键字搜索课程信息，搜索方式为全文检索，关键字需要匹配课程的名称、 课程内容。

3、根据难度等级搜索课程。

4、搜索结点分页显示。

搜索流程：

![1551721443151](images/1551721443151.png)

1、课程管理服务将数据写到MySQL数据库

2、使用Logstash将MySQL数据库中的数据写到ES的索引库。

3、用户在前端搜索课程信息，请求到搜索服务。

4、搜索服务请求ES搜索课程信息。



## 2 课程索引

### 2.1 技术方案

如何维护课程索引信息？

1、当课程向MySQL**添加**后同时将课程信息添加到索引库。采用**Logstach**实现，它会从MySQL中将数据采集到ES索引库。

2、当课程在MySQL**更新**信息后同时更新该课程在索引库的信息。采用**Logstach**实现。

3、当课程在MySQL**删除**后同时将该课程从索引库删除。手工**写程序**实现，在删除课程后将索引库中该课程信息删除。



### 2.2 准备课程索引信息

**课程发布**成功在MySQL数据库存储课程发布信息，此信息作为课程索引信息。

课程信息分布在course_base、course_pic等不同的表中。课程发布成功为了**方便！！！**进行索引将这几张表的数据合并在一张表中，作为课程发布信息。创建**`course_pub`表**，其中 timestamp 为 logstash 使用

创建**课程发布表模型**

```java
@Data
@Entity
@Table(name="course_pub")
@GenericGenerator(name = "jpa-assigned", strategy = "assigned")
public class CoursePub implements Serializable {
    private static final long serialVersionUID = -916357110051689487L;
    @Id
    @GeneratedValue(generator = "jpa-assigned")
    @Column(length = 32)
    private String id;
    private String name;
    private String users;
    private String mt;
    private String st;
    private String grade;
    private String studymodel;
    private String teachmode;
    private String description;
    private String pic;//图片
    private Date timestamp;//时间戳
    private String charge;
    private String valid;
    private String qq;
    private Float price;
    private Float price_old;
    private String expires;
    private String teachplan;//课程计划
    @Column(name="pub_time")
    private String pubTime;//课程发布时间
}
```

修改课程发布服务

在课程管理服务定义dao

```java
public interface CoursePubRepository extends JpaRepository<CoursePub,String> {
}
```

修改课程发布service

```java
@Service
public class CourseService {
    @Transactional
    public CoursePublishResult publish(String courseId) {
        CourseBase courseBase = this.findCourseBaseById(courseId);

        //发布课程预览页面...
        //调用CMS一键发布接口，将课程详细页面发布到服务器...
        //保存课程发布状态为已发布...

        
        //保存课程索引信息
        //先创建一个coursePub对象，组合分散的表中信息
        CoursePub coursePub = this.createCoursePut(courseId);
        //将coursePub对象保存到数据库
        this.saveCoursePub(courseId, coursePub);
        //缓存课程信息
        

        
        //给前端返回url
        String pageUrl = result.getPageUrl();
        return new CoursePublishResult(CommonCode.SUCCESS,pageUrl);
    }

    //将coursePub对象保存到数据库
    private CoursePub saveCoursePub(String courseId, CoursePub coursePub) {
        Optional<CoursePub> pubOptional = coursePubRepository.findById(courseId);
        //存在则更新，否则创建
        CoursePub newCoursePub = pubOptional.orElseGet(CoursePub::new);
        //将coursePub对象中的信息保存到coursePubNew中
        BeanUtils.copyProperties(coursePub,newCoursePub);
        newCoursePub.setId(courseId);
        //时间戳,给logstach使用
        newCoursePub.setTimestamp(new Date());
        //发布时间
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("YYYY-MM-dd HH:mm:ss");
        String date = simpleDateFormat.format(new Date());
        newCoursePub.setPubTime(date);

        coursePubRepository.save(coursePub);
        return newCoursePub;

    }

    //创建一个coursePub对象，组合分散的表中信息
    private CoursePub createCoursePut(String courseId) {
        CoursePub coursePub = new CoursePub();

        //根据课程id查询course_base
        Optional<CourseBase> baseOptional = courseBaseRepository.findById(courseId);
        //都是同样的属性，没有get/set，只能复制
        baseOptional.ifPresent(courseBase -> BeanUtils.copyProperties(courseBase, coursePub));

        //查询课程图片
        Optional<CoursePic> picOptional = coursePicRepository.findById(courseId);
        picOptional.ifPresent(coursePic -> BeanUtils.copyProperties(coursePic,coursePub));

        //课程营销信息
        Optional<CourseMarket> marketOptional = courseMarketRepository.findById(courseId);
        marketOptional.ifPresent(courseMarket -> BeanUtils.copyProperties(courseMarket,coursePub));

        //课程计划信息，mybatis
        TeachplanNode teachplanNode = teachplanMapper.selectList(courseId);
        //将课程计划信息json串保存到 course_pub中
        String jsonString = JSON.toJSONString(teachplanNode);
        coursePub.setTeachplan(jsonString);

        return coursePub;
    }
}
```





### 2.3 搭建ES环境

开发环境使用ES单机环境，启动ES服务端。

创建xc_course索引库，一个分片，0个副本。

创建映射：`POST http://localhost:9200/xc_course/doc/_mapping`

```json
{
    "properties" : {
        "description" : {
            "analyzer" : "ik_max_word",
            "search_analyzer": "ik_smart",
            "type" : "text"
        },
        "grade" : {
            "type" : "keyword"
        },
        "id" : {
            "type" : "keyword"
        },
        "mt" : {
            "type" : "keyword"
        },
        "name" : {
            "analyzer" : "ik_max_word",
            "search_analyzer": "ik_smart",
            "type" : "text"
        },
        "users" : {
            "index" : false,
            "type" : "text"
        },
        "charge" : {
            "type" : "keyword"
        },
        "valid" : {
            "type" : "keyword"
        },
        "pic" : {
            "index" : false,
            "type" : "keyword"
        },
        "qq" : {
            "index" : false,
            "type" : "keyword"
        },
        "price" : {
            "type" : "float"
        },
        "price_old" : {
            "type" : "float"
        },
        "st" : {
            "type" : "keyword"
        },
        "status" : {
            "type" : "keyword"
        },
        "studymodel" : {
            "type" : "keyword"
        },
        "teachmode" : {
            "type" : "keyword"
        },
        "teachplan" : {
            "analyzer" : "ik_max_word",
            "search_analyzer": "ik_smart",
            "type" : "text"
        },
        "expires" : {
            "type" : "date",
            "format": "yyyy‐MM‐dd HH:mm:ss"
        },
        "pub_time" : {
            "type" : "date",
            "format": "yyyy‐MM‐dd HH:mm:ss"
        },
        "start_time" : {
            "type" : "date",
            "format": "yyyy‐MM‐dd HH:mm:ss"
        },
        "end_time" : {
            "type" : "date",
            "format": "yyyy‐MM‐dd HH:mm:ss"
        }
    }
}
```



### 2.4 Logstash创建索引

Logstash是ES下的一款开源软件，它能够同时从多个来源采集数据、转换数据，然后将数据发送到Eleasticsearch中创建索引。

#### 2.4.1 下载Logstash

1. 下载Logstash6.2.1版本，和本项目使用的Elasticsearch6.2.1版本一致，zip包解压即可

2. 安装logstash-input-jdbc：
   1. logstash-input-jdbc 是ruby开发的，先[下载ruby](https://rubyinstaller.org/downloads/)并安装，下载2.5版本即可

   2. 安装完成查看是否安装成功`ruby -v`

   3. Logstash5.x以上版本本身自带有logstash-input-jdbc，6.x版本本身不带logstash-input-jdbc插件，需要手动安装

      在`Logstash5\bin`目录下执行` .\logstash-plugin.bat install logstash-input-jdbc`

      安装成功后我们可以在以下目录查看对应的插件版本`logstash-6.2.1\vendor\bundle\jruby\2.3.0\gems`

      > 解压老师提供的logstash-6.2.1.zip,此logstash中已集成了logstash-input-jdbc插件

#### 2.4.2 创建模板文件

Logstash的工作是从MySQL中读取数据，向ES中创建索引，这里需要提前创建mapping的模板文件以便logstash使用。

在logstach的`config`目录创建`xc_course_template.json`，内容如下：

```json
{
   "mappings" : {
      "doc" : {
         "properties" : {
            "charge" : {
               "type" : "keyword"
            },
            "description" : {
               "analyzer" : "ik_max_word",
               "search_analyzer" : "ik_smart",
               "type" : "text"
            },
            "end_time" : {
               "format" : "yyyy-MM-dd HH:mm:ss",
               "type" : "date"
            },
            "expires" : {
               "format" : "yyyy-MM-dd HH:mm:ss",
               "type" : "date"
            },
            "grade" : {
               "type" : "keyword"
            },
            "id" : {
               "type" : "keyword"
            },
            "mt" : {
               "type" : "keyword"
            },
            "name" : {
               "analyzer" : "ik_max_word",
               "search_analyzer" : "ik_smart",
               "type" : "text"
            },
            "pic" : {
               "index" : false,
               "type" : "keyword"
            },
            "price" : {
               "type" : "float"
            },
            "price_old" : {
               "type" : "float"
            },
            "pub_time" : {
               "format" : "yyyy-MM-dd HH:mm:ss",
               "type" : "date"
            },
            "qq" : {
               "index" : false,
               "type" : "keyword"
            },
            "st" : {
               "type" : "keyword"
            },
            "start_time" : {
               "format" : "yyyy-MM-dd HH:mm:ss",
               "type" : "date"
            },
            "status" : {
               "type" : "keyword"
            },
            "studymodel" : {
               "type" : "keyword"
            },
            "teachmode" : {
               "type" : "keyword"
            },
            "teachplan" : {
               "analyzer" : "ik_max_word",
               "search_analyzer" : "ik_smart",
               "type" : "text"
            },
            "users" : {
               "index" : false,
               "type" : "text"
            },
            "valid" : {
               "type" : "keyword"
            }
         }
      }
   },
   "template" : "xc_course"
}
```

#### 2.4.3 配置mysql.conf

在logstash的config目录下配置mysql.conf文件供logstash使用，logstash会根据mysql.conf文件的配置的地址从MySQL中读取数据向ES中写入索引。[参考](https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html)配置输入数据源和输出数据源。

【注意】可能当前版本的Logstash与MySQL8 不适合，怎么都同步不了数据，所以改用MySQL5

```nginx
input {
  stdin {
  }
  jdbc {
  jdbc_connection_string => "jdbc:mysql://localhost:3306/xc_course?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC"
  # the user we wish to excute our statement as
  jdbc_user => "root"
  jdbc_password => w111151
  # the path to our downloaded jdbc driver  
  jdbc_driver_library => "D:/Maven_repository/mysql/mysql-connector-java/5.1.40/mysql-connector-java-5.1.40.jar"
  # the name of the driver class for mysql
  jdbc_driver_class => "com.mysql.jdbc.Driver"
  jdbc_paging_enabled => "true"
  jdbc_page_size => "50000"
  #要执行的sql文件
  #statement_filepath => "/conf/course.sql"
  statement => "select * from course_pub where timestamp > date_add(:sql_last_value,INTERVAL 8 HOUR)"
  #定时配置
  schedule => "* * * * *"
  record_last_run => true
  last_run_metadata_path => "D:/ElasticSearch3940/logstash-6.2.1/config/logstash_metadata"
  }
}


output {
  elasticsearch {
  #ES的ip地址和端口
  hosts => "localhost:9200"
  #hosts => ["localhost:9200","localhost:9202","localhost:9203"]
  #ES索引库名称
  index => "xc_course"
  document_id => "%{id}"
  document_type => "doc"
  template =>"C:/Develop/Elasticsearch/logstash-6.2.1/config/xc_course_template.json"
  template_name =>"xc_course"
  template_overwrite =>"true"
  }
  stdout {
 #日志输出
  codec => json_lines
  }
}
```

1、ES采用UTC时区问题。ES采用UTC 时区，比北京时间早8小时，所以ES读取数据时让最后更新时间加8小时`where timestamp > date_add(:sql_last_value,INTERVAL 8 HOUR)`

2、logstash每个执行完成会在`C:/Develop/Elasticsearch/logstash-6.2.1/config/logstash_metadata`记录执行时间下次**以此时间为基准进行增量同步数据到索引库**。

```
--- 2019-03-05 07:35:00.257000000 Z
```





#### 2.4.5 测试

启动logstash.bat：`.\logstash.bat ‐f ..\config\mysql.conf`。遇到无法加载主类问题，看[这篇博客](https://www.cnblogs.com/sbj-dawn/p/8549369.html)

修改course_pub中的数据，并且修改timestamp为当前时间，观察Logstash日志是否读取到要索引的数据。



## 3 课程搜索

### 3.1 需求分析

1、根据分类搜索课程信息，采用过虑器实现

2、根据关键字搜索课程信息，搜索方式为全文检索，采用MultiMatchQuery，搜索name、description、teachplan

3、根据难度等级搜索课程，采用过虑器实现

4、搜索结点分页显示



### 3.2 创建搜索服务工程

1. 创建xc-service-search工程

2. 配置appliction.yml

   ```yaml
   server:
     port: ${port:40100}
   spring:
     application:
       name: xc-search-service
   xuecheng:
     elasticsearch:
       hostlist: ${eshostlist:127.0.0.1:9200} #多个结点中间用逗号分隔
     course:
       index: xc_course
       type: doc
       source_field: id,name,grade,mt,st,charge,valid,pic,qq,price,price_old,status,studymodel,teachmode,expires,pub_time,start_time,end_time
   ```

3. 配置RestHighLevelClient和RestClient

   ```java
   @Configuration
   public class ElasticsearchConfig {
   
       @Value("${xuecheng.elasticsearch.hostlist}")
       private String hostlist;
   
       @Bean
       public RestHighLevelClient restHighLevelClient(){
           //解析hostlist配置信息
           String[] split = hostlist.split(",");
           //创建HttpHost数组，其中存放es主机和端口的配置信息
           HttpHost[] httpHostArray = new HttpHost[split.length];
           for(int i=0;i<split.length;i++){
               String item = split[i];
               httpHostArray[i] = new HttpHost(item.split(":")[0], Integer.parseInt(item.split(":")[1]), "http");
           }
           //创建RestHighLevelClient客户端
           return new RestHighLevelClient(RestClient.builder(httpHostArray));
       }
   
       //项目主要使用RestHighLevelClient，对于低级的客户端暂时不用
       @Bean
       public RestClient restClient(){
           //解析hostlist配置信息
           String[] split = hostlist.split(",");
           //创建HttpHost数组，其中存放es主机和端口的配置信息
           HttpHost[] httpHostArray = new HttpHost[split.length];
           for(int i=0;i<split.length;i++){
               String item = split[i];
               httpHostArray[i] = new HttpHost(item.split(":")[0], Integer.parseInt(item.split(":")[1]), "http");
           }
           return RestClient.builder(httpHostArray).build();
       }
   
   }
   ```



### 3.3 Api

```java
package com.xuecheng.api.search;

@Api(value = "课程搜索",description = "课程搜索",tags = {"课程搜索"})
public interface EsCourseControllerApi {

    @ApiOperation("课程搜索")
    QueryResponseResult<CoursePub> list(int page, int size, CourseSearchParam courseSearchParam);
}
```

```java
@Data
public class CourseSearchParam implements Serializable {
    //关键字
    String keyword;
    //一级分类
    String mt;
    //二级分类
    String st;

    //难度等级
    String grade;

    //价格区间
    Float price_min;
    Float price_max;

    //排序字段
    String sort;
    //过虑字段
    String filter;

}
```



### 3.4 Controller

```java
@RestController
@RequestMapping("/search/course")
public class EsCourseController implements EsCourseControllerApi {

    @Autowired
    private EsCourseService esCourseService;

    @Override
    @GetMapping(value="/list/{page}/{size}")
    public QueryResponseResult<CoursePub> list(@PathVariable int page, @PathVariable int size, CourseSearchParam courseSearchParam) {
        return esCourseService.list(page, size, courseSearchParam);
    }
}
```



### 3.5 Service

分页；关键字；分类；难度等级；高亮

```java
@Service
public class EsCourseService {
    @Value("${xuecheng.course.index}")
    private String index;

    @Value("${xuecheng.course.type}")
    private String type;

    @Value("${xuecheng.course.source_field}")
    private String source_field;

    @Autowired
    private RestHighLevelClient client;

    //课程搜索
    public QueryResponseResult<CoursePub> list(int page, int size, CourseSearchParam courseSearchParam) {
        if (Objects.isNull(courseSearchParam)) {
            courseSearchParam = new CourseSearchParam();
        }

        //创建搜索请求对象
        SearchRequest searchRequest = new SearchRequest(index);
        //设置搜索类型
        searchRequest.types(type);
        //搜索源构建对象
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();

        //过滤源字段
        String[] split = source_field.split(",");
        searchSourceBuilder.fetchSource(split, new String[]{});

        //分页
        page = page <= 0 ? 1 : page;
        size = size <= 0 ? 10 : size;
        searchSourceBuilder.from((page - 1) * size);
        searchSourceBuilder.size(size);

        //搜索条件：
        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();

        //1.根据关键字搜索
        if (!StringUtils.isEmpty(courseSearchParam.getKeyword())) {
            boolQueryBuilder.must(QueryBuilders.multiMatchQuery(courseSearchParam.getKeyword(), "name", "description", "teachplan")
                    .minimumShouldMatch("70%")
                    .field("name", 10));
        }
        //2.根据分类
        if (!StringUtils.isEmpty(courseSearchParam.getMt())) {
            //根据一级分类
            boolQueryBuilder.filter(QueryBuilders.termQuery("mt", courseSearchParam.getMt()));
        }
        if (!StringUtils.isEmpty(courseSearchParam.getSt())) {
            //根据二级分类
            boolQueryBuilder.filter(QueryBuilders.termQuery("st", courseSearchParam.getSt()));
        }
        //3.根据难度等级
        if (!StringUtils.isEmpty(courseSearchParam.getGrade())) {
            boolQueryBuilder.filter(QueryBuilders.termQuery("grade", courseSearchParam.getGrade()));
        }

        //高亮
        HighlightBuilder highlightBuilder = new HighlightBuilder()
                .preTags("<font class='eslight'>")
                .postTags("</font>")
                .field("name");


        searchSourceBuilder.query(boolQueryBuilder).highlighter(highlightBuilder);
        searchRequest.source(searchSourceBuilder);

        QueryResult<CoursePub> queryResult = new QueryResult<>();
        List<CoursePub> list = new ArrayList<>();
        //执行搜索
        SearchResponse searchResponse = null;
        try {
            //执行搜索
            searchResponse = client.search(searchRequest);
        } catch (IOException e) {
            e.printStackTrace();
            return new QueryResponseResult<>(CommonCode.FAIL, queryResult);
        }

        //获取命中结果
        SearchHits hits = searchResponse.getHits();
        //匹配度高的结果
        SearchHit[] searchHits = hits.getHits();
        for (SearchHit searchHit : searchHits) {
            CoursePub coursePub = new CoursePub();
            //得到原文档
            Map<String, Object> sourceAsMap = searchHit.getSourceAsMap();
            //取出id
            String id = (String) sourceAsMap.get("id");
            coursePub.setId(id);
            //取出name
            String name = (String) sourceAsMap.get("name");
            //取出高亮字段name
            Map<String, HighlightField> highlightFields = searchHit.getHighlightFields();
            if (Objects.nonNull(highlightFields)){
                HighlightField highlightFieldName = highlightFields.get("name");
                StringBuilder builder = new StringBuilder();
                if (Objects.nonNull(highlightFieldName)){
                    Text[] nameFragments = highlightFieldName.getFragments();
                    for (Text text : nameFragments) {
                        builder.append(text);
                    }
                    name = builder.toString();
                }
            }
            coursePub.setName(name);
            //图片
            String pic = (String) sourceAsMap.get("pic");
            coursePub.setPic(pic);
            //价格
            Double price = null;
            try {
                if (sourceAsMap.get("price") != null) {
                    price = (Double) sourceAsMap.get("price");
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
            coursePub.setPrice(price);
            //旧价格
            Double price_old = null;
            try {
                if (sourceAsMap.get("price_old") != null) {
                    price_old = (Double) sourceAsMap.get("price_old");
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            coursePub.setPrice_old(price_old);
            //将coursePub对象放入list
            list.add(coursePub);

        }

        queryResult.setList(list);
        queryResult.setTotal(hits.getTotalHits());
        return new QueryResponseResult<>(CommonCode.SUCCESS, queryResult);

    }
}
```





# 11 搜索前端—Nuxt.js

## 1 搜索前端技术需求

### 1.1 需求描述

采用vue.js开发搜索界面则SEO不友好，需要解决SEO的问题。

SEO是网站为了提高自已的网站排名，获得更多的流量，对网站的结构及内容进行调整优化，以便搜索引擎（百度，google等）更好抓取到更优质的网站的内容。

下图是搜索引擎爬取网站页面的大概流程图：

![1551857195852](images/1551857195852.png)

从上图可以看到SEO是网站自己为了方便spider抓取网页而作出的网页内容优化，常见的SEO方法比如：

1）对url链接的规范化，多用restful风格的url，多用静态资源url

2）注意title、keywords的设置

3）由于spider对javascript支持不好，对于网页跳转用href标签



### 1.2 服务端渲染和客户端渲染

用传统的servlet开发来举例：浏览器请求servlet，servlet在服务端生成html响应给浏览器，浏览器展示html的内容，这个过程就是服务端渲染，特点：

1）在服务端生成html网页的dom元素

2）客户端（浏览器）只负责显示dom元素内容

![1551857276180](images/1551857276180.png)

------

随着web2.0的到来，A JAX技术兴起，出现了客户端渲染：客户端（浏览器） 使用A JAX向服务端发起http请求，获取到了想要的数据，客户端拿着数据开始渲染html网页，生成Dom元素，并最终将网页内容展示给用户，特点：

1）在服务端只是给客户端响应的了数据，而不是html网页

2）客户端（浏览器）负责获取服务端的数据生成Dom元素。查看源代码时看不到

![1551857362342](images/1551857362342.png)

------

两种方式各有什么优缺点？

* 客户端渲染：

  * 缺点：不利于网站进行SEO，因为网站大量使用javascript技术，不利于spider抓取网页。
  * 优点：客户端负责渲染，用户体验性好，服务端只提供数据不用关心用户界面的内容，有利于提高服务端的开发效率。
  * 适用场景：对SEO没有要求的系统，比如后台管理类的系统，如电商后台管理，用户管理等。

* 服务端渲染：

  * 优点：有利于SEO，网站通过href的url将spider直接引到服务端，服务端提供优质的网页内容给spider。
  * 缺点：服务端完成一部分客户端的工作，通常完成一个需求需要修改客户端和服务端的代码，开发效率低，不利于系统的稳定性。
  * 适用场景：对SEO有要求的系统，比如：门户首页、商品详情页面等。

  

  

## 2 Nuxt.js介绍

官网：https://zh.nuxtjs.org/

移动互联网的兴起促进了web前后端分离开发模式的发展，服务端只专注业务，前端只专注用户体验，前端大量运用的前端渲染技术，比如流行的vue.js、react框架都实现了功能强大的前端渲染。

react框架提供next.js实现服务端渲染。

vue.js框架提供Nuxt.js实现服务端渲染。

下图展示了从客户端请求到Nuxt.js进行服务端渲染的整体的工作流程：

![1551858112087](images/1551858112087.png)

1、用户打开浏览器，输入网址请求到Node.js
2、部署在Node.js的应用Nuxt.js接收浏览器请求，并请求服务端获取数据
3、Nuxt.js获取到数据后进行服务端渲染
4、Nuxt.js将html网页响应给浏览器

Nuxt.js使用Vue.js+webpack+Babel（js的转码器，负责将ES6的代码转成浏览器识别的ES5代码）三大技术框架/组件



## 3 Nuxt.js基本使用

### 3.1 创建Nuxt工程

nuxt.js有标准的目录结构，官方提供了模板工程，可以模板工程快速创建nuxt项目，[模板工程地址](https://github.com/nuxt-community/starter-template/archive/master.zip)。

本项目提供基于Nuxt.js的封装工程，基于此封装工程开发搜索前端，解压xc-ui-pc-portal.zip到本项目前端工程目录下。本前端工程属于门户的一部分，将承载一部分考虑SEO的非静态化页面。本工程基于Nuxt.js模板工程构建，Nuxt.js使用1.3版本，并加入了今后开发中所使用的依赖包，直接解压本工程即可使用。

本工程的目录结构如下：

![1551859371546](images/1551859371546.png)

* assets：资源目录，用于组织未编译的静态资源如 LESS、SASS 或 JavaScript
* components：组件目录，用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不
  会像页面组件那样有 asyncData 方法的特性。
* **layouts**：布局目录，用于组织应用的布局组件。该目录名为Nuxt.js保留的，不可更改。
* middleware：目录用于存放应用的中间件。
* pages：页面目录，用于组织应用的路由及视图。Nuxt.js框架读取该目录下所有.vue文件并自动生成对应的路由配置
  该目录名为Nuxt.js保留的，不可更改。
* plugins：插件目录，用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。
* static：静态文件目录，用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。 服务
  器启动的时候，该目录下的文件会映射至应用的根路径 / 下。举个例子: /static/logo.png 映射至 /logo.png
  该目录名为Nuxt.js保留的，不可更改。
* store：目录用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。
  该目录名为Nuxt.js保留的，不可更改。
* nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。
  该文件名为Nuxt.js保留的，不可更改。
* package.json 文件用于描述应用的依赖关系和对外暴露的脚本接口。
  该文件名为Nuxt.js保留的，不可更改。

nuxt.js 提供了目录的别名，方便在程序中引用：

![1551859693181](images/1551859693181.png)



### 3.2 页面布局

页面布局就是页面内容的整体结构，通过在**layouts目录**下添加布局文件来实现。在layouts 根目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 layout 属性来引用。例如：

定义：layouts/test.vue布局文件（注意：布局文件中一定要加 `<nuxt/>` 组件用于显示页面内容。），如下：

```vue
<template>
<div>
    <div>头</div>
    <nuxt/>
    <div>尾</div>
    </div>
</template>
<script>
    export default {

    }
</script>
<style>

</style>
```

在pages目录创建user目录，并创建index.vue页面，指定页面组件使用 test 布局

```vue
<template>
<div>测试页面</div>
</template>

<script>
    export default {
        layout: "test"
    }
</script>

<style>

</style>
```

【不指定layout则默认是layouts/default.vue】

测试，右击package.json用npm运行dev（内部配置是"dev": "nuxt",）请求：http://localhost:10000/user，如果如下

```
头
测试页面
尾
```





### 3.3 路由

Nuxt.js **依据 `pages` 目录**结构自动生`vue-router`模块的路由配置。

要在**页面之间使用路由**，我们建议使用**`<nuxt-child/>`标签**。如下：

```vue
<template>
  <nuxt-link to="/">首页</nuxt-link>
</template>
```



#### 3.3.1 基础路由

假设 `pages` 的目录结构如下：

```
pages/
--| user/
-----| index.vue
-----| one.vue
--| index.vue
```

那么，Nuxt.js 自动生成的路由配置如下：

```js
router: {
  routes: [
    {
      name: 'index',
      path: '/',
      component: 'pages/index.vue'
    },
    {
      name: 'user',
      path: '/user',
      component: 'pages/user/index.vue'
    },
    {
      name: 'user-one',
      path: '/user/one',
      component: 'pages/user/one.vue'
    }
  ]
}
```

/user/index.vue代码如下（/index.vue代码也如下）：

```vue
<template>
	<div>
    用户管理首页
    </div>
</template>
<script>
    export default{
        layout:"test"
    }
</script>
<style>
</style>
```

/user/one.vue代码如下：

```vue
<template>
	<div>
    index2页面
    </div>
</template>
<script>
    export default{
        layout:"test"
    }
</script>
<style>
</style>
```

分别访问如下链接进行测试：http://localhost:10000/、http://localhost:10000/user 、http://localhost:10000/user/index2



#### 3.3.2 动态路由

在 Nuxt.js 里面定义**带参数的动态路由**，需要创建对应的**以下划线作为前缀**的 Vue 文件 或 目录

以下目录结构：

```
pages/
--| _slug/
-----| comments.vue
-----| index.vue
--| users/
-----| _id.vue
--| index.vue
```

Nuxt.js 生成对应的路由配置表为：

```js
router: {
  routes: [
    {
      name: 'index',
      path: '/',
      component: 'pages/index.vue'
    },
    {
      name: 'users-id',
      path: '/users/:id?',
      component: 'pages/users/_id.vue'
    },
    {
      name: 'slug',
      path: '/:slug',
      component: 'pages/_slug/index.vue'
    },
    {
      name: 'slug-comments',
      path: '/:slug/comments',
      component: 'pages/_slug/comments.vue'
    }
  ]
}
```

你会发现名称为 `users-id` 的路由路径带有 **`:id?`** 参数，表示该路由是**可选**的。如果你想将它设置为必选的路由，需要在 `users/_id` 目录内创建一个 `index.vue` 文件。

##### 路由参数校验

Nuxt.js 可以让你在动态路由组件中定义参数校验方法。

举个例子： `pages/users/_id.vue`

```js
export default {
  validate ({ params }) {
    // 必须是number类型
    return /^\d+$/.test(params.id)
  }
}
```

如果校验方法返回的值不为 `true`或`Promise`中resolve 解析为`false`或抛出Error ， Nuxt.js 将自动加载显示 404 错误页面或 500 错误页面。了解关于路由参数校验的信息，请参考 [页面校验API](https://zh.nuxtjs.org/api/pages-validate)。



#### 3.3.2 嵌套路由

可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。

创建内嵌子路由，需要添加一个 Vue 文件，同时添加一个**与该文件同名的目录**用来存放子视图组件。

别忘了在**父级 Vue 文件内增加 `<nuxt-child/>` 用于显示子视图内容**。

假设文件结构如下：

```
pages/
‐‐| user/
‐‐‐‐‐| _id.vue
‐‐‐‐‐| index.vue
‐‐| user.vue
```

Nuxt.js 自动生成的路由配置如下：

```js
router: {
    routes: [
        {
            path: '/user',
            component: 'pages/user.vue',
            children: [
                {
                    path: '',
                    component: 'pages/user/index.vue',
                    name: 'user'
                },
                {
                    path: ':id',
                    component: 'pages/user/_id.vue',
                    name: 'user‐id'
                }
            ]
        }
    ]
}
```

将user.vue文件创建到与user目录的父目录下，即和user目录保持平级。

```vue
<template>
	<div>
    用户管理导航，<nuxt‐link :to="'/user/101'">修改</nuxt‐link>
    <nuxt‐child/>
    </div>
</template>
<script>
    export default{
        layout:"test"
    }
</script>
<style>
</style>
```

_id.vue页面实现了向页面传入id参数，页面内容如下：

```vue
<template>
<div>
    修改用户信息{{id}}
    </div>
</template>
<script>
    export default{
        layout:"test",
        data(){
            return {
                id:''
            }
        },
        mounted(){
            this.id = this.$route.params.id;//是json中参数，不是?后的参数
            console.log(this.id)
        }
    }
</script>
<style>
</style>
```

index页面和3.3.1一致

测试：http://localhost:10000/user







### 3.4 获取数据

Nuxt.js 扩展了 Vue.js，增加了一个叫 asyncData 的方法， ==asyncData 方法会**在组件（限于页面组件）每次加载之前被调用**==。它可以在服务端或路由更新之前被调用。

#### 3.4.1 asyncData 方法

 在这个方法被调用的时候，第一个参数被设定为当前页面的上下文对象，你可以利用 asyncData 方法来获取数据，Nuxt.js 会将 asyncData 返回的数据融合组件 data 方法返回的数据一并返回给当前组件。

注意：由于asyncData 方法是在组件 初始化 前被调用的，所以在方法内是**没有办法通过 this 来引用组件的实例对象**。

在上边例子中的user/_id.vue中添加，页面代码如下：

```vue
<template>
<div>
    修改用户信息{{id}},名称：{{name}}
    </div>
</template>
<script>
    export default{
        layout:'test',
        //根据id查询用户信息
        asyncData(){
            console.log("async方法")
            return {
                name:'黑马程序员'
            }
        },
        data(){
            return {
                id:''
            }
        },
        mounted(){
            this.id = this.$route.params.id;
        }
    }
</script>
<style>
</style>
```

此方法在服务端被执行，观察服务端控制台打印输出“async方法”。

此方法返回data模型数据，在服务端被渲染，最后响应给前端，刷新此页面查看页面源代码可以看到name模型数据已在页面源代码中显示。



#### 3.4.2 async /await方法

使用async 和 await配合promise也可以实现同步调用，nuxt.js中使用async/await实现同步调用效果。

1、先测试异步调用，增加a、b两个方法，并在mounted中调用。

```js
methods:{
    a(){
        return new Promise(function(resolve,reject){
            setTimeout(function () {
                resolve(1)
            },2000)
        })
    },
        b(){
            return new Promise(function(resolve,reject){
                setTimeout(function () {
                    resolve(2)
                },1000)
            })
        }
},
    mounted(){
        this.a().then(res=>{
            alert(res)
            console.log(res)
        })
        this.b().then(res=>{
            alert(res)
            console.log(res)
        })
    }
```

观察客户端，并没有按照方法执行的顺序输出，因为使用Promise实现了异步调用。

2、使用**async/await**完成**同步调用**

```js
async asyncData({ store, route }) {
    console.log("async方法")
    var a = await new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log("1")
            resolve(1)
        },2000)
    });
    var a = await new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log("2")
            resolve(2)
        },1000)
    });
    return {
        name:'黑马程序员'
    }
}
```

观察服务端控制台发现是按照a、b方法的调用顺序输出1、2，实现了使用async/await完成同步调用。



## 4 搜索前端开发

具体查看讲义！！！

### 4.1 搜索页面

#### 4.1.1 需求分析

1、界面默认查询所有课程，并分页显示
2、通过一级分类和二分类搜索课程，选择一级分类后将显示下属的二级分类
3、通过关键字搜索课程
4、通过课程等级搜索课程



#### 4.1.2 页面布局

nuxt.js将/layout/default.vue作为所有页面的默认布局，通常布局包括：页头、内容区、页尾



#### 4.1.3 Nginx代理配置

用户请求/course/search时Nginx将请求转发到nuxt.js服务，nginx在转发时根据每台nuxt服务的负载情况进行转发，实现负载均衡。

本教程开发环境Nuxt.js服务和www.xuecheng.com虚拟机主在同一台计算机，使用同一个nginx，配置如下：

```nginx
#前端门户课程搜索
location ^~ /course/search {
	proxy_pass http://dynamic_portal_server_pool;
}
#后端搜索服务
location /openapi/search/ {
	proxy_pass http://search_server_pool/search/;
}
#分类信息
location /static/category/ {
	proxy_pass http://static_server_pool;
}
```

dynamic_portal_server_pool配置如下 ：

```nginx
#前端动态门户
upstream dynamic_portal_server_pool{
	server 127.0.0.1:10000 weight=10;
}
#后台搜索（公开api）
upstream search_server_pool{
	server 127.0.0.1:40100 weight=10;
}
```

其它配置：

```nginx
#开发环境webpack定时加载此文件
location ^~ /__webpack_hmr {
	proxy_pass http://dynamic_portal_server_pool/__webpack_hmr;
}

#开发环境nuxt访问_nuxt
location ^~ /_nuxt/ {
	proxy_pass http://dynamic_portal_server_pool/_nuxt/;
}
```

在静态虚拟主机中添加：

```nginx
#学成网静态资源
server {
	listen 91;
	server_name localhost;
	#分类信息
    location /static/category/ {
    	alias D:/Code-Workspace/_Project/xcEdu/xcEduUI/static/category/;
    }
	...
```

#### 4.1.4 搜索页面

页面文件参考：“资料”--》“search”--》index_1.vue。nuxt.js支持定义header，本页面我们在header中引入css样式并定义头部信息；其它数据模型及方法；

重启Nginx，请求：http://www.xuecheng.com/course/search。即可看到没有课程的页面（查看源代码，是服务端渲染！）



### 4.2 查询全部

#### 4.2.1 需求分析

初次进入页面，没有输入任何查询条件，默认查询全部课程，分页显示。

#### 4.2.2 API方法

在api目录创建本工程所用的api方法类，api方法类使用了public.js等一些抽取类：
/api/public.js-------------抽取axios 的基础方法
/api/util.js-----------------工具类
/config/sysConfig.js----系统配置类，配置了系统参数变量

创建course.js，作为课程相关业务模块的api方法类。



#### 4.2.3 搜索方法

实现思路如下：
1、用户请求本页面到达node.js
2、在asyncData方法中向服务端请求查询课程
3、asyncData方法执行完成开始服务端渲染



#### 4.2.4 页面

在页面中展示课程列表。



### 4.3 分页查询

后端已经写了；前端利用element-UI。详细查看教程



### 4.4 分类查询

1、通过一级分类搜索
2、选择一级分类后将显示下属的二级分类
3、选择二分类进行搜索
4、选择一级分类的全部则表示没有按照分类搜索
5、选择一级分类的全部时二级分类不显示

课程分类将通过页面静态化的方式写入静态资源下，通过/category/category.json可访问，通过www.xuecheng.com/static/category/category.json即可访问（但是教程中没有做CMS对分类JSON的静态化）

我们需要定义api方法获取所有的分类

在asyncData中查询分类。进入搜索页面将默认显示所有一级分类，当前如果已选择一级分类则要显示所有一级分类及该一级分类下属的二级分类。

在页面显示一级分类及二级分类，需要根据当前是否选择一级分类、是否选择二分类显示页面内容。



### 4.5 按难度等级搜索

同4.4 



### 4.6 高亮显示

后端已经写了，前端需要定义后端返回的高亮样式





## 5 集成测试

本次集成测试的目的如下：
1、测试课程发布与CMS接口是否正常。
2、测试课程发布与ES接口是否正常。
3、测试课程从创建到发布的整个过程。



1、启动MySQL、MongoDB
2、启动ElasticSearch、RabbitMQ
3、启动Eureka Server
4、启动CMS、课程管理服务、搜索服务。
5、启动Nginx、系统管理前端、教学管理前端、Nuxt.js。

[除了logstash这次有问题，启动不了，其他都正常]，后续解决了，还是配置文件问题，可能又是编码问题！



# 12 媒资管理—HLS—上传文件/处理

## 1 在线学习需求分析

### 1.1 需求分析

学成在线作为在线教育网站，提供多种学习形式，包括：录播、直播、图文、社群等，学生登录进入学习中心即可在线学习，本章节将开发录播课程的在线学习功能，需求如下：
1、学生可以在windows浏览器上在线观看视频。
2、播放器具有快进、快退、暂停等基本功能。
3、学生可以方便切换章节进行学习。

### 1.2 视频点播解决方案

#### 1.2.1 流媒体

流媒体：就是将视频文件分成许多小块，将这些小块儿作为数据包通过网络发送出去，实现一边传输视频数据包一边观看视频

在网络上传输音、视频信息有两个方式：下载和流式传输

* 下载：就是把音、视频文件完全下载到本机后开始播放，它的特点是必须等到视频文件下载完成方可播放，播放等待时间较长，无法去播放还未下载的部分视频。

* 流式传输：就是客户端通过链接视频服务器实时传输音、视频信息，实现“边下载边播放”。包括如下两种方式：

  * 顺序流式传输

    即顺序下载音、视频文件，可以实现边下载边播放，不过，用户只能观看已下载的视频内容，无法快进到未下载的视频部分，顺序流式传输可以使用Http服务器来实现，比如Nginx、Apache等。

  * 实时流式传输

    实时流式传输可以解决顺序流式传输无法快进的问题，它与Http流式传输不同，它必须使用流媒体服务器并且使用流媒体协议来传输视频，它比Http流式传输复杂。常见的实时流式传输协议有RTSP、RTMP、RSVP等

学习流媒体系统的基本业务流程：

![1551944425823](images/1551944425823.png)

1、将原始的视频文件通过**编码器转换**为适合网络传输的流格式，编码后的视频直接输送给媒体服务器。原始的视频文件通常是事先录制好的视频，比如通过摄像机、摄像头等录像、录音设备采集到的音视频文件，体积较大，要想在网络上传输需要经过压缩处理，即通过编码器进行编码 。

2、媒体服务获取到编码好的视频文件，对外提供流媒体数据传输接口，**接口协议**包括 ：HTTP、RTSP、RTMP等 。

3、**播放器通过流媒体协议与媒体服务器通信**，获取视频数据，播放视频。

#### 1.2.2 点播方案

本项目包括点播和直播两种方式，我们先调研点播的方案，如下：

1、 播放器通过 http协议从http服务器上下载视频文件进行播放。问题：必须等到视频下载完才可以播放，不支持快进到某个时间点进行播放

2、 播放器通过**rtmp协议**连接媒体服务器以实时流方式播放视频。使用rtmp协议需要架设媒体服务器，造价高，对于直播多采用此方案。
3、 播放器使用**HLS协议**连接http服务器（Nginx、Apache等）实现**近实时**流方式播放视频。HLS协议规定：基于Http协议，视频封装格式为ts，视频的编码格式为H264,音频编码格式为MP3、AAC或者AC-3。

**HLS的工作方式**是：将视频拆分成**若干ts格式的小文件**，通过**m3u8格式的索引文件**对这些ts小文件建立索引。一般10秒一个ts文件，播放器连接m3u8文件播放，当快进时通过m3u8即可找到对应的索引文件，并去下载对应的ts文件，从而实现快进、快退以近实时 的方式播放视频。IOS、Android设备、及各大浏览器都支持HLS协议。

![1551944598261](images/1551944598261.png)

采用HLS方案即可实现边下载边播放，并可不用使用rtmp等流媒体协议，不用构建专用的媒体服务器，节省成本。



## 2 视频编码

### 2.1 视频编码格式

首先我们要分清文件格式和编码格式：

* 文件格式：是指.mp4、.avi、.rmvb等 这些不同扩展名的视频文件的文件格式 ，视频文件的内容主要包括视频和音频，其文件格式是按照一 定的编码格式去编码，并且按照该文件所规定的封装格式将视频、音频、字幕等信息封装在一起，播放器会根据它们的封装格式去提取出编码，然后由播放器解码，最终播放音视频。
* 音视频编码格式：通过音视频的压缩技术，将视频格式转换成另一种视频格式，通过视频编码实现流媒体的传输。比如：一个.avi的视频文件原来的编码是a，通过编码后编码格式变为b，音频原来为c，通过编码后变为d。

音视频编码格式各类繁多，主要有几下几类：

* MPEG系列 （由ISO[国际标准组织机构]下属的MPEG[运动图象专家组]开发 ）视频编码方面主要是Mpeg1（vcd用的就是它）、Mpeg2（DVD使用）、Mpeg4（的DVDRIP使用的都是它的变种，如：divx，xvid等）、Mpeg4 AVC（正热门）；音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3（大名鼎鼎的mp3）、MPEG-2 AAC 、MPEG-4 AAC等等。注意：DVD音频没有采用Mpeg的。
* H.26X系列 （由ITU[国际电传视讯联盟]主导，侧重网络传输，注意：只是视频编码） 包括H.261、H.262、H.263、H.263+、H.263++、H.264（就是MPEG4 AVC-合作的结晶）

目前最常用的编码标准是视频H.264，音频AAC。



### 2.2 FFmpeg 的基本使用

FFmpeg被许多开源项目采用，QQ影音、暴风影音、VLC等。[下载FFmpeg](https://www.ffmpeg.org/download.html#build-windows)并解压，可以将bin目录配置到环境变量中。

`ffmpeg -version`查看版本

[官方文档（英文）](http://ffmpeg.org/ffmpeg.html)。测试将一个.avi文件转成mp4、mp3、gif等：

`ffmpeg -i lucene.avi lucene.mp4`

`ffmpeg -i lucene.avi lucene.mp3`

`ffmpeg -i lucene.avi lucene.gif`



### 2.3 生成m3u8/ts文件

第一步：先将avi视频转成mp4（下面参数只针对提供的文件，其他文件需要手动设置参数。只是mp4生成m3u8好用？？？）

`ffmpeg.exe ‐i lucene.avi ‐c:v libx264 ‐s 1280x720 ‐pix_fmt yuv420p ‐b:a 63k ‐b:v 753k ‐r 18 .\lucene.mp4`

* `-c:v` 视频编码为x264 ，x264编码是H264的一种开源编码格式。
* `-s` 设置分辨率
* `-pix_fmt yuv420p`：设置像素采样方式，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0，它的作用是根据采样方式来从码流中还原每个像素点的YUV（亮度信息与色彩信息）值。
* `-b` 设置码率，-b:a和-b:v分别表示音频的码率和视频的码率，-b表示音频加视频的总码率。码率对一个视频质量有很大的作用，后边会介绍。
* `-r`：帧率，表示每秒更新图像画面的次数，通常大于24肉眼就没有连贯与停顿的感觉了。

> 50m左右的avi变为20多m的mp4...

第二步：将mp4生成m3u8（下面参数只针对提供的文件，其他文件需要手动设置参数。需要先创建hls文件夹）

`ffmpeg ‐i lucene.mp4 ‐hls_time 10 ‐hls_list_size 0 ‐hls_segment_filename ./hls/lucene_%05d.ts ./hls/lucene.m3u8`

* `-hls_time` 设置每片的长度，单位为秒（虽然设置了10，但是那个文件并不是10秒！）
* `-hls_list_size n`: 保存的分片的数量，设置为0表示保存所有分片
* `-hls_segment_filename` ：段文件的名称，%05d表示5位数字

生成的效果是：将lucene.mp4文件每10秒（不一定）生成一个ts文件，最后生成一个m3u8文件，m3u8文件是ts的索引文件。



#### 码率的设置

码率又叫比特率即每秒传输的bit数，单位为bps(Bit Per Second)，码率越大传送数据的速度越快。

码率的计算公式是：`文件大小（转成bit）/ 时长（秒）/1024 = kbps 即每秒传输千位数`

例如一个1M的视频，它的时长是10s，它的码率等于`1*1024*1024*8/10/1024 = 819Kbps`

码率设置到多少才能达到最好，通过根据个人的经验或参考一些视频网台给出的参考，下图是优酷对码率的要求：

![1551945641634](images/1551945641634.png)

如果要将视频上传到优酷则必须按照上面的要求，如果是自己搭建视频服务器，码率设置不易过大，最终达到的视频清晰度满足业务需求即可。



## 3 播放器

### 3.1 技术选型

视频编码后要使用播放器对其进行解码、播放视频内容。在web应用中常用的播放器有flash播放器、H5播放器或浏览器插件播放器，其中以flash和H5播放器最常见。

* flash播放器：缺点是需要在客户机安装Adobe Flash Player播放器，优点是flash播放器已经很成熟了，并且浏览器对flash支持也很好。
* H5播放器：基于h5自带video标签进行构建，优点是大部分浏览器支持H5，不用再安装第三方的flash播放器，并且随着前端技术的发展，h5技术会越来越成熟。

本项目采用H5播放器，使用[Video.js开源播放器](http://videojs.com/)。Video.js是一款基于HTML5世界的网络视频播放器。它支持HTML5和Flash视频，它支持在台式机和移动设备上播放视频。这个项目于2010年中开始，目前已在40万网站使用。

### 3.2 下载video.js

下载[Video.js](https://github.com/videojs/video.js) 和 [videojs-contrib-hls](https://github.com/videojs/videojs-contrib-hls#installation)（是播放hls的一个插件） ，使用[文档地址](http://docs.videojs.com/tutorial-videojs_.html)

本教程使用 video.js 6.7.3 ，videojs-contrib-hls.js 5.14.1。下载上边两个文件，为了测试需求将其放在静态门户plugins目录。还需要css文件。

### 3.3 搭建媒体服务器

正常使用video.js播放视频是通过一个网页，用户通过浏览器打开网页去播放视频，网页和视频都从web服务器请求，通常视频的url地址使用单独的域名。

#### 3.3.1 Nginx媒体服务器

HLS协议基于Http协议，本项目使用Nginx作为视频服务器。下图是Nginx媒体服务器的配置流程图：

![1551946707774](images/1551946707774.png)

1、用户打开www.xuecheng.com上边的video.html网页，在此网页中引入视频链接，视频地址指向video.xuecheng.com

2、video.xuecheng.com进行负载均衡处理，将视频请求转发到媒体服务器



#### 3.3.2 媒体服务器代理

媒体服务器不止一台，通过代理实现负载均衡功能，使用Nginx作为媒体服务器的代理，此代理服务器作为video.xuecheng.com域名服务器。

注意：开发中代理服务器和媒体服务器在同一台服务器，使用同一个Nginx。

```nginx
#学成网媒体服务代理
map $http_origin $origin_list{
	default http://www.xuecheng.com;
	"~http://www.xuecheng.com" http://www.xuecheng.com;
	"~http://ucenter.xuecheng.com" http://ucenter.xuecheng.com;
}
#学成网媒体服务代理
server {
	listen 80;
	server_name video.xuecheng.com;

    location /video {
    	proxy_pass http://video_server_pool;
    	add_header Access-Control-Allow-Origin $origin_list;
        add_header Access-Control-Allow-Credentials true;
        add_header Access-Control-Allow-Methods GET;
        #add_header Access-Control-Allow-Origin *;
    }
}
```

```nginx
#媒体服务
upstream video_server_pool{
	server 127.0.0.1:90 weight=10;
}
```

```nginx
#学成网媒体服务
server {
	listen 90;
	server_name localhost;
	
	#视频目录
	location /video/ {
		alias D:/video/;
	}
}
```

配置hosts文件，本教程开发环境使用Window10，修改C:\Windows\System32\drivers\etc\hosts文件

```
127.0.0.1 video.xuecheng.com
```

重启Nginx

> cors跨域参数：
>
> Access-Control-Allow-Origin：允许跨域访问的外域地址。通常允许跨域访问的站点不是一个，所以这里用map定义了多个站点。如果允许任何站点跨域访问则设置为*，通常这是不建议的。
>
> Access-Control-Allow-Credentials： 允许客户端携带证书访问
>
> Access-Control-Allow-Methods：允许客户端跨域访问的方法

#### 3.3.3 编写测试页面

编写测试页面video.html，在静态工程xc-ui-pc-static-portal中

```html
<!--css之类的略了-->
<video id=example-video width=800 height=600 class="video-js vjs-default-skin vjs-big-play-centered" controls poster="http://127.0.0.1:90/video/add.jpg">
    <source
            src="http://video.xuecheng.com/video/hls/lucene.m3u8"
            type="application/x-mpegURL">
</video>

<script src="/plugins/videojs/video.js"></script>
<script src="/plugins/videojs/videojs-contrib-hls.js"></script>
<script>
    const player = videojs('example-video');
    //player.play();

    function switchvideo(){
        player.src({
            src: 'http://video.xuecheng.com/video/hls/lucene.m3u8',
            type: 'application/x-mpegURL',
            withCredentials: true
        });
        player.play();
    }
</script>
```

访问http://www.xuecheng.com/video.html，经过Nginx代理即可访问到，若出现跨域问题，绝对是复制时编码出错！！！



## 4 搭建学习中心前端

### 4.1 创建学习中心工程

学习中心的用户是学生，为了便于系统维护和扩展，单独创建学习中心工程：

1、从资料目录拷贝xc-ui-pc-leanring.zip 并解压到xc-ui-pc-leanring目录。
2、使用webstorm创建打开xc-ui-pc-leanring目录
3、进入xc-ui-pc-leanring目录，执行cnpm install，将根据package.json的依赖配置远程下载依赖的js包。



### 4.1 Nginx虚拟主机配置

学习中心的二级域名为ucenter.xuecheng.com，我们在nginx中配置ucenter虚拟主机。

```nginx
#学成网用户中心
server {
	listen 80;
	server_name ucenter.xuecheng.com;
    
    #个人中心
    location / {
    	proxy_pass http://ucenter_server_pool;
	}
}
```

```nginx
#前端ucenter
upstream ucenter_server_pool{
	#server 127.0.0.1:7081 weight=10;
	server 127.0.0.1:13000 weight=10;
}
```

重启Nginx（这里配置的端口13000是使用Node.js，在实际部署时直接用Nginx）

启动xc-ui-pc-leanring前端项目，报错！

```
16% building modules 55/71 modules 16 active ...4.0.6@vue-video-player\src\player.vue{ parser: "babylon" } is deprecated; we now treat it as { parser: "babel" }.
 94% asset optimization ERROR  Failed to compile with 14 errors22:26:51

These dependencies were not found:

* aes-decrypter in ./node_modules/_video.js@7.4.1@video.js/dist/video.es.js
* babel-runtime/core-js/json/stringify in ./src/common/utils.js
* babel-runtime/core-js/object/assign in ./node_modules/_babel-loader@7.1.5@babel-loader/lib!./node_modules/_vue-loader@13.7.3@vue-loader/lib/selector.js?type=script&index=0!./node_modules/_vue-video-player@4.0.6@vue-video-player/src/player.vue, ./node_modules/_babel-loader@7.1.5@babel-loader/lib!./node_modules/_vue-loader@13.7.3@vue-loader/lib/selector.js?type=script&index=0!./src/base/components/loginForm.vue
* babel-runtime/core-js/object/keys in ./src/main.js
* babel-runtime/core-js/promise in ./src/base/api/public.js
* es6-promise in ./src/base/api/public.js
* m3u8-parser in ./node_modules/_video.js@7.4.1@video.js/dist/video.es.js
* mpd-parser in ./node_modules/_video.js@7.4.1@video.js/dist/video.es.js
* mux.js/lib/mp4 in ./node_modules/_video.js@7.4.1@video.js/dist/video.es.js
* mux.js/lib/mp4/probe in ./node_modules/_video.js@7.4.1@video.js/dist/video.es.js
* mux.js/lib/tools/ts-inspector.js in ./node_modules/_video.js@7.4.1@video.js/dist/video.es.js
* url-toolkit in ./node_modules/_video.js@7.4.1@video.js/dist/video.es.js
* video.js/dist/video-js.css in ./src/main.js

To install them, you can run: npm install --save aes-decrypter babel-runtime/core-js/json/stringify babel-runtime/core-js/object/assign babel-runtime/core-js/object/keys babel-runtime/core-js/promise es6-promise m3u8-parser mpd-parser mux.js/lib/mp4 mux.js/lib/mp4/probe mux.js/lib/tools/ts-inspector.js url-toolkit video.js/dist/video-js.css

```

明天问老师

第二天，又删除了node_modules，重新`npm install`，并启动，好了！？？？？？？😱

前端利用了vue和video.js的组件

```html
<video-player class="vjs-custom-skin" ref="videoPlayer" :options="playerOptions"></video-player>
```

因为是测试，所以直接让这个组件播放刚才测试的视频

```js
this.playvideo("http://video.xuecheng.com/video/hls/lucene.m3u8")
```

路由，需要指定课程id，章节（上面写死了，随便传值）

```js
path: '/learning/:courseId/:chapter',
```

访问http://ucenter.xuecheng.com/#/learning/4028e581617f945f01617f9dabc40000/1或利用Node.js配置的本地13000端口都可以访问到，并能播放视频



## 5 媒资管理

### 5.1 需求分析

媒资管理系统是每个在线教育平台所必须具备的。每个教学机构都可以在媒资系统管理自己的教学资源，包括：视频、教案等文件。目前媒资管理的主要管理对象是课程录播视频，包括：媒资文件的查询、视频上传、视频删除、视频处理等。

媒资查询：教学机构查询自己所拥有的媒体文件。
视频上传：将用户线下录制的教学视频上传到媒资系统。
视频处理：视频上传成功，系统自动对视频进行编码处理。
视频删除 ：如果该视频已不再使用，可以从媒资系统删除。

下边是媒资系统与其它系统的交互情况：

![1552060239578](images/1552060239578.png)

1、上传媒资文件
前端/客户端请求媒资系统上传文件。
文件上传成功将文件存储到媒资服务器，将文件信息存储到数据库。
2、使用媒资
课程管理请求媒资系统查询媒资信息，将课程计划与媒资信息对应、存储。
3、视频播放
用户进入学习中心请求学习服务学习在线播放视频。
学习服务校验用户资格通过后请求媒资系统获取视频地址。

### 5.2 开发环境

#### 5.2.1 创建媒资数据库

1、媒资文件信息

```java
@Data
@Document(collection = "media_file")
public class MediaFile {
    /*
	文件id、名称、大小、文件类型、文件状态（未上传、上传完成、上传失败）、上传时间、视频处理方式、视频处
	理状态、hls_m3u8,hls_ts_list、课程视频信息（课程id、章节id）
	*/
    @Id
    //文件id
    private String fileId;
    //文件名称
    private String fileName;
    //文件原始名称
    private String fileOriginalName;
    //文件路径
    private String filePath;
    //文件url
    private String fileUrl;
    //文件类型
    private String fileType;
    //mimetype
    private String mimeType;
    //文件大小
    private Long fileSize;
    //文件状态
    private String fileStatus;
    //上传时间
    private Date uploadTime;
}
```

2、创建`xc_media`数据库。媒资系统使用mongodb数据库存储媒资信息，不用创建集合，Spring Data 会自动创建

#### 5.2.2 创建媒资服务工程

媒资管理的相关功能单独在媒资服务中开发，下边创建媒资服务工程（xc-service-manage-media），媒资服务的配置与cms类似，导入 “资料”--》xc-service-manage-media工程



### 5.3 上传文件（视频）

#### 5.3.1 断点续传解决方案

通常视频文件都比较大，所以对于媒资系统上传文件的需求要满足大文件的上传要求。http协议本身对上传文件大小没有限制...

断点续传指的是在下载或上传时，将**下载或上传任务**（一个文件或一个压缩包）人为的划**分为几个部分**，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载，断点续传可以提高节省操作时间，提高用户体验性。

![1552060937355](images/1552060937355.png)

上传流程如下（下载同理）：

1、上传前先把文件分成块

2、一块一块的上传，上传中断后重新上传，已上传的分块则不用再上传

3、各分块上传完成最后**合并**文件

#### 5.3.2 文件分块与合并

##### 1、文件分块

文件分块的流程如下：
1、获取源文件长度
2、根据设定的分块文件的大小计算出块数
3、从源文件读数据依次向每一个块文件写数据。

```java
//测试文件分块
@Test
public void testChunk() throws IOException {
    //源文件
    File sourceFile = new File("E:\\ffmpeg_test\\lucene.avi");
    //块文件目录
    String chunkFileFolder = "E:\\ffmpeg_test\\chunks\\";

    //先定义块文件大小
    long chunkFileSize = 1 * 1024 * 1024;

    //块数
    long chunkFileNum = (long) Math.ceil(sourceFile.length() * 1.0 /chunkFileSize);

    //创建读文件的对象
    RandomAccessFile raf_read = new RandomAccessFile(sourceFile,"r");

    //缓冲区
    byte[] b = new byte[1024];
    for(int i=0;i<chunkFileNum;i++){
        //块文件
        File chunkFile = new File(chunkFileFolder+i);
        //创建向块文件的写对象
        RandomAccessFile raf_write = new RandomAccessFile(chunkFile,"rw");
        int len = -1;

        while((len = raf_read.read(b))!=-1){

            raf_write.write(b,0,len);
            //如果块文件的大小达到 1M开始写下一块儿
            if(chunkFile.length()>=chunkFileSize){
                break;
            }
        }
        raf_write.close();


    }
    raf_read.close();
}
```

##### 2、文件合并

文件合并流程：
1、找到要合并的文件并按文件合并的先后进行排序。
2、创建合并文件
3、依次从合并的文件中读取数据向合并文件写入数

```java
//测试文件合并
@Test
public void testMergeFile() throws IOException {
    //块文件目录
    String chunkFileFolderPath = "E:\\ffmpeg_test\\chunks\\";
    //块文件目录对象
    File chunkFileFolder = new File(chunkFileFolderPath);
    //块文件列表
    File[] files = chunkFileFolder.listFiles();
    //将块文件排序，按名称升序
    List<File> fileList = Arrays.asList(files);
    Collections.sort(fileList, new Comparator<File>() {
        @Override
        public int compare(File o1, File o2) {
            if(Integer.parseInt(o1.getName())>Integer.parseInt(o2.getName())){
                return 1;
            }
            return -1;

        }
    });

    //合并文件
    File mergeFile = new File("E:\\ffmpeg_test\\lucene_merge.avi");
    //创建新文件
    boolean newFile = mergeFile.createNewFile();

    //创建写对象
    RandomAccessFile raf_write = new RandomAccessFile(mergeFile,"rw");

    byte[] b = new byte[1024];
    for(File chunkFile:fileList){
        //创建一个读块文件的对象
        RandomAccessFile raf_read = new RandomAccessFile(chunkFile,"r");
        int len = -1;
        while((len = raf_read.read(b))!=-1){
            raf_write.write(b,0,len);
        }
        raf_read.close();
    }
    raf_write.close();
}
```



#### 5.3.3 前端页面

上传文件的页面内容参考：“资料”--》upload.vue文件

##### 1、WebUploader介绍

如何在web页面实现断点续传？常见的方案有：

~~1、通过Flash上传，比如SWFupload、Uploadify。~~
~~2、安装浏览器插件，变相的pc客户端，用的比较少。~~
3、Html5

本项目使用WebUploader完成大文件上传功能的开发，[WebUploader官网地址](http://fexteam.gz01.bdysite.com/webuploader/)，有中文文档

使用WebUploader上传流程如下：

![1552061566683](images/1552061566683.png)

##### 2、钩子方法

![1552061602479](images/1552061602479.png)

本项目使用如下钩子方法：

1）before-send-file
在开始对文件分块儿之前调用，可以做一些上传文件前的准备工作，比如检查文件目录是否创建完成等。

2）before-send
在上传文件分块之前调用此方法，可以请求服务端检查分块是否存在，如果已存在则此分块儿不再上传。

3）after-send-file
在所有分块上传完成后触发，可以请求服务端合并分块文件。

注册钩子方法源代码：

```js
WebUploader.Uploader.register({
    "before‐send‐file":"beforeSendFile",
    "before‐send":"beforeSend",
    "after‐send‐file":"afterSendFile"
}
```

##### 3、构建WebUploader

使用webUploader前需要创建webUploader对象。指定上传分块的地址：/api/media/upload/uploadchunk

```js
// 创建uploader对象，配置参数
this.uploader = WebUploader.create(
    {
        swf:"/static/plugins/webuploader/dist/Uploader.swf",//上传文件的flash文件，浏览器不支持h5时启动
        flash
        server:"/api/media/upload/uploadchunk",//上传分块的服务端地址，注意跨域问题
        fileVal:"file",//文件上传域的name
        pick:"#picker",//指定选择文件的按钮容器
        auto:false,//手动触发上传
        disableGlobalDnd:true,//禁掉整个页面的拖拽功能
        chunked:true,// 是否分块上传
        chunkSize:1*1024*1024, // 分块大小（默认5M）
        threads:3, // 开启多个线程（默认3个）
        prepareNextFile:true// 允许在文件传输时提前把下一个文件准备好
    }
)
```

##### 4、before-send-file

文件开始上传前前端请求服务端准备上传工作。参考源代码如下：

```js
type:"POST",
url:"/api/media/upload/register",
data:{
	// 文件唯一表示
	fileMd5:this.fileMd5,
	fileName: file.name,
	fileSize:file.size,
	mimetype:file.type,
	fileExt:file.ext
}
```

##### 5、before-send

上传分块前前端请求服务端校验分块是否存在。参考源代码如下：

```js
type:"POST",
url:"/api/media/upload/checkchunk",
data:{
	// 文件唯一表示
	fileMd5:this.fileMd5,
	// 当前分块下标
	chunk:block.chunk,
	// 当前分块大小
	chunkSize:block.end‐block.start
}
```

##### 6、after-send-file

在所有分块上传完成后触发，可以请求服务端合并分块文件。参考代码如下：

```js
type:"POST",
url:"/api/media/upload/mergechunks",
data:{
	fileMd5:this.fileMd5,
	fileName: file.name,
	fileSize:file.size,
	mimetype:file.type,
	fileExt:file.ext
}
```



#### 5.3.4 服务端

```java
@Data
@NoArgsConstructor
public class CheckChunkResult extends ResponseResult{

    public CheckChunkResult(ResultCode resultCode, boolean fileExist) {
        super(resultCode);
        this.fileExist = fileExist;
    }
    @ApiModelProperty(value = "文件分块存在标记", example = "true", required = true)
    boolean fileExist;
}
```

```java
@Api(value = "媒资管理接口",description = "媒资管理接口，提供文件上传、处理等接口")
public interface MediaUploadControllerApi {

    //文件上传前的准备工作,校验文件是否存在
    @ApiOperation("文件上传注册")
    ResponseResult register(String fileMd5,
                                   String fileName,
                                   Long fileSize,
                                   String mimetype,
                                   String fileExt);

    @ApiOperation("校验分块文件是否存在")
    CheckChunkResult checkchunk(String fileMd5,
                                       Integer chunk,
                                       Integer chunkSize);

    @ApiOperation("上传分块")
    ResponseResult uploadchunk(MultipartFile file,
                                      String fileMd5,
                                      Integer chunk);

    @ApiOperation("合并分块")
    ResponseResult mergechunks(String fileMd5,
                                      String fileName,
                                      Long fileSize,
                                      String mimetype,
                                      String fileExt);

}
```

application.yml配置上传文件的路径：

```yaml
xc-service-manage-media:
  upload-location: D:/develop/video/
```

媒资文件管理Dao

```java
public interface MediaFileRepository extends MongoRepository<MediaFile,String> {
}
```

Controller

```java
@RestController
@RequestMapping("/media/upload")
public class MediaUploadController implements MediaUploadControllerApi {

    @Autowired
    MediaUploadService mediaUploadService;

    //文件上传前的注册
    @Override
    @PostMapping("/register")
    public ResponseResult register(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt) {
        return mediaUploadService.register(fileMd5,fileName,fileSize,mimetype,fileExt);
    }

    @Override
    @PostMapping("/checkchunk")
    public CheckChunkResult checkchunk(String fileMd5, Integer chunk, Integer chunkSize) {
        return mediaUploadService.checkchunk(fileMd5,chunk,chunkSize);
    }

    @Override
    @PostMapping("/uploadchunk")
    public ResponseResult uploadchunk(MultipartFile file, String fileMd5, Integer chunk) {
        return mediaUploadService.uploadchunk(file,fileMd5,chunk);
    }

    @Override
    @PostMapping("/mergechunks")
    public ResponseResult mergechunks(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt) {
        return mediaUploadService.mergechunks(fileMd5,fileName,fileSize, mimetype,fileExt);
    }
}
```

Service：根据WebUploader的钩子方法来创建

```java
@Service
public class MediaUploadService {
    @Autowired
    MediaFileRepository mediaFileRepository;

    @Value("${xc-service-manage-media.upload-location}")
    String upload_location;

    //得到文件所属目录路径
    private String getFileFolderPath(String fileMd5){
        return  upload_location + fileMd5.substring(0,1) + "/" + fileMd5.substring(1,2) + "/" + fileMd5 + "/";
    }
    //得到文件的路径
    private String getFilePath(String fileMd5,String fileExt){
        return upload_location + fileMd5.substring(0,1) + "/" + fileMd5.substring(1,2) + "/" + fileMd5 + "/" + fileMd5 + "." +fileExt;
    }

    //得到块文件所属目录路径
    private String getChunkFileFolderPath(String fileMd5){
        return  upload_location + fileMd5.substring(0,1) + "/" + fileMd5.substring(1,2) + "/" + fileMd5 + "/chunk/";
    }
    /**
     * 文件上传前的注册，检查文件是否存在
     * 根据文件md5得到文件路径
     * 规则：
     * 一级目录：md5的第一个字符
     * 二级目录：md5的第二个字符
     * 三级目录：md5
     * 文件名：md5+文件扩展名
     * @param fileMd5 文件md5值
     * @param fileExt 文件扩展名
     * @return 文件路径
     */
    public ResponseResult register(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt) {

        //1  检查文件在磁盘上是否存在
        //文件所属目录的路径
        String fileFolderPath = this.getFileFolderPath(fileMd5);
        //文件的路径
        String filePath =this.getFilePath(fileMd5,fileExt);
        File file = new File(filePath);
        //文件是否存在
        boolean exists = file.exists();

        //2 检查文件信息在mongodb中是否存在
        Optional<MediaFile> optional = mediaFileRepository.findById(fileMd5);
        if(exists && optional.isPresent()){
            //文件存在
            ExceptionCast.cast(MediaCode.UPLOAD_FILE_REGISTER_EXIST);
        }
        //文件不存在时作一些准备工作，检查文件所在目录是否存在，如果不存在则创建
        File fileFolder = new File(fileFolderPath);
        if(!fileFolder.exists()){
            fileFolder.mkdirs();
        }

        return new ResponseResult(CommonCode.SUCCESS);
    }

    //分块检查
    /**
     *
     * @param fileMd5 文件md5
     * @param chunk 块的下标
     * @param chunkSize 块的大小
     * @return
     */
    public CheckChunkResult checkchunk(String fileMd5, Integer chunk, Integer chunkSize) {
        //检查分块文件是否存在
        //得到分块文件的所在目录
        String chunkFileFolderPath = this.getChunkFileFolderPath(fileMd5);
        //块文件
        File chunkFile = new File(chunkFileFolderPath + chunk);
        if(chunkFile.exists()){
            //块文件存在
            return new CheckChunkResult(CommonCode.SUCCESS,true);
        }else{
            //块文件不存在
            return new CheckChunkResult(CommonCode.SUCCESS,false);
        }

    }
    //上传分块
    public ResponseResult uploadchunk(MultipartFile file, String fileMd5, Integer chunk) {
        //检查分块目录，如果不存在则要自动创建
        //得到分块目录
        String chunkFileFolderPath = this.getChunkFileFolderPath(fileMd5);
        //得到分块文件路径
        String chunkFilePath = chunkFileFolderPath + chunk;

        File chunkFileFolder = new File(chunkFileFolderPath);
        //如果不存在则要自动创建
        if(!chunkFileFolder.exists()){
            chunkFileFolder.mkdirs();
        }
        //得到上传文件的输入流
        InputStream inputStream = null;
        FileOutputStream outputStream  =null;
        try {
            inputStream = file.getInputStream();
            outputStream = new FileOutputStream(new File(chunkFilePath));
            IOUtils.copy(inputStream,outputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return new ResponseResult(CommonCode.SUCCESS);

    }

    //合并文件
  public ResponseResult mergechunks(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt) {

        //1、合并所有分块
        //得到分块文件的属目录
        String chunkFileFolderPath = this.getChunkFileFolderPath(fileMd5);
        File chunkFileFolder = new File(chunkFileFolderPath);
        //分块文件列表
        File[] files = chunkFileFolder.listFiles();
        List<File> fileList = Arrays.asList(files);

        //创建一个合并文件
        String filePath = this.getFilePath(fileMd5, fileExt);
        File mergeFile = new File(filePath);

        //执行合并
        mergeFile = this.mergeFile(fileList, mergeFile);
        if(mergeFile == null){
            //合并文件失败
            ExceptionCast.cast(MediaCode.MERGE_FILE_FAIL);
        }

        //2、校验文件的md5值是否和前端传入的md5一到
        boolean checkFileMd5 = this.checkFileMd5(mergeFile, fileMd5);
        if(!checkFileMd5){
            //校验文件失败
            ExceptionCast.cast(MediaCode.MERGE_FILE_CHECKFAIL);
        }
        //3、将文件的信息写入mongodb
        MediaFile mediaFile = new MediaFile();
        mediaFile.setFileId(fileMd5);
        mediaFile.setFileOriginalName(fileName);
        mediaFile.setFileName(fileMd5 + "." +fileExt);
        //文件路径保存相对路径
        String filePath1 = fileMd5.substring(0,1) + "/" + fileMd5.substring(1,2) + "/" + fileMd5 + "/" ;
        mediaFile.setFilePath(filePath1);
        mediaFile.setFileSize(fileSize);
        mediaFile.setUploadTime(new Date());
        mediaFile.setMimeType(mimetype);
        mediaFile.setFileType(fileExt);
        //状态为上传成功
        mediaFile.setFileStatus("301002");
        mediaFileRepository.save(mediaFile);

      	//还应该删除分块文件，此处没写
        return new ResponseResult(CommonCode.SUCCESS);
    }

    //校验文件
    private boolean checkFileMd5(File mergeFile,String md5){

        try {
            //创建文件输入流
            FileInputStream inputStream = new FileInputStream(mergeFile);
            //得到文件的md5
            String md5Hex = DigestUtils.md5Hex(inputStream);

            //和传入的md5比较
            if(md5.equalsIgnoreCase(md5Hex)){
                return true;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return false;

    }
    //合并文件
    private File mergeFile(List<File> chunkFileList, File mergeFile) {
        try {
            //如果合并文件已存在则删除，否则创建新文件
            if (mergeFile.exists()) {
                mergeFile.delete();
            } else {
                //创建一个新文件
                mergeFile.createNewFile();
            }

            //对块文件进行排序
            Collections.sort(chunkFileList, new Comparator<File>() {
                @Override
                public int compare(File o1, File o2) {
                    if(Integer.parseInt(o1.getName())>Integer.parseInt(o2.getName())){
                        return 1;
                    }
                    return -1;

                }
            });
            //创建一个写对象
            RandomAccessFile raf_write = new RandomAccessFile(mergeFile,"rw");
            byte[] b = new byte[1024];
            for(File chunkFile:chunkFileList){
                RandomAccessFile raf_read = new RandomAccessFile(chunkFile,"r");
                int len = -1;
                while ((len = raf_read.read(b))!=-1){
                    raf_write.write(b,0,len);
                }
                raf_read.close();
            }
            raf_write.close();
            return mergeFile;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```



### 5.4 视频处理

#### 5.4.1 需求分析

> 有可能还有文档处理，音频处理等，需要RabbitMQ的路由模式

原始视频通常需要经过**编码处理**，**生成m3u8和ts文件**方可基于**HLS**协议播放视频。通常用户上传原始视频，系统自动处理成标准格式，系统对用户上传的视频自动编码、转换，最终生成m3u8文件和ts文件，处理流程如下：
1、用户上传视频成功
2、系统对上传成功的视频自动开始编码处理
3、用户查看视频处理结果，没有处理成功的视频用户可在管理界面再次触发处理
4、视频处理完成将视频地址及处理结果保存到数据库

![1552118285578](../%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/images/1552118285578.png)

视频处理进程的任务是接收视频处理消息进行视频处理，业务流程如下：
1、监听MQ，接收视频处理消息。
2、进行视频处理。
3、向数据库写入视频处理结果。



#### 5.4.2 视频处理工程创建

1. 导入“资料”下的视频处理工程：xc-service-manage-media-processor

2. RabbitMQ配置，使用rabbitMQ的routing交换机模式，视频处理程序监听视频处理队列，如下图：

   ![1552118404039](../%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/images/1552118404039.png)

   RabbitMQ配置

   ```java
   @Configuration
   public class RabbitMQConfig {
   
       public static final String EX_MEDIA_PROCESSTASK = "ex_media_processor";
   
       //视频处理队列
       @Value("${xc-service-manage-media.mq.queue-media-video-processor}")
       public  String queue_media_video_processtask;
   
       //视频处理路由
       @Value("${xc-service-manage-media.mq.routingkey-media-video}")
       public  String routingkey_media_video;
   
       //消费者并发数量
       public static final int DEFAULT_CONCURRENT = 10;
   
   
       /**
        * 交换机配置
        * @return the exchange
        */
       @Bean(EX_MEDIA_PROCESSTASK)
       public Exchange EX_MEDIA_VIDEOTASK() {
           return ExchangeBuilder.directExchange(EX_MEDIA_PROCESSTASK).durable(true).build();
       }
       //声明队列
       @Bean("queue_media_video_processtask")
       public Queue QUEUE_PROCESSTASK() {
           Queue queue = new Queue(queue_media_video_processtask,true,false,true);
           return queue;
       }
       /**
        * 绑定队列到交换机 .
        * @param queue    the queue
        * @param exchange the exchange
        * @return the binding
        */
       @Bean
       public Binding binding_queue_media_processtask(@Qualifier("queue_media_video_processtask") Queue queue, @Qualifier(EX_MEDIA_PROCESSTASK) Exchange exchange) {
           return BindingBuilder.bind(queue).to(exchange).with(routingkey_media_video).noargs();
       }
   }
   ```

   application.yml

   ```yaml
   server:
     port: 31450
   spring:
     application:
       name: xc-service-manage-media-processor
     data:
       mongodb:
         uri:  mongodb://root:123@localhost:27017
         database: xc_media
   #rabbitmq配置
     rabbitmq:
       host: 127.0.0.1
       port: 5672
       username: guest
       password: guest
       virtual-host: /
   xc-service-manage-media:
     mq:
       queue-media-video-processor: queue_media_video_processor
       routingkey-media-video: routingkey_media_video
     video-location: D:/develop/video/
     ffmpeg-path: D:/Program Files/ffmpeg-20180227-fa0c9d6-win64-static/bin/ffmpeg.exe
   ```

   

#### 5.4.3 视频处理技术方案

ffmpeg是一个可行的视频处理程序，可以通过Java调用ffmpeg.exe完成视频处理。

==在java中可以使用**Runtime类**和**ProcessBuilder**类两种方式来**执行外部程序**==

```java
@Test
public void testProcessBuilder() throws IOException {

    //创建ProcessBuilder对象
    ProcessBuilder processBuilder =new ProcessBuilder();
    //设置执行的第三方程序(命令)
    //processBuilder.command("ipconfig");
    //processBuilder.command("java","-jar","f:/xc-service-manage-course.jar");
    //processBuilder.command("ping","127.0.0.1");
    List<String> commandList = new ArrayList<>();
    commandList.add("ping");
    commandList.add("127.0.0.1");
    processBuilder.command(commandList);
    //启动一个进程
    Process process = processBuilder.start();

    //将标准输入流和错误输入流合并，通过标准输入流读取信息就可以拿到第三方程序输出的错误信息、正常信息
    processBuilder.redirectErrorStream(true);
    //由于前边将错误和正常信息合并在输入流，只读取输入流
    InputStream inputStream = process.getInputStream();
    //将字节流转成字符流
    InputStreamReader reader = new InputStreamReader(inputStream,"gbk");
    //字符缓冲区
    char[] chars = new char[1024];
    int len;
    while((len = reader.read(chars))!=-1){
        String string = new String(chars,0,len);
        System.out.println(string);
    }

    inputStream.close();
    reader.close();
}
```

已封装为工具类：Mp4VideoUtil.java完成avi转mp4，HlsVideoUtil.java完成mp4转hls





#### 5.4.4 确定消息格式

MQ消息统一采用json格式，视频处理生产方会向MQ发送如下消息，视频处理消费方接收此消息后进行视频处理：

```json
{“mediaId”:XXX}
```

#### 5.4.5 处理流程

1）接收视频处理消息
2）判断媒体文件是否需要处理（本视频处理程序目前只接收avi视频的处理）当前只有avi文件需要处理，其它文件需要更新处理状态为“无需处理”。
3）处理前初始化处理状态为“未处理”
4）处理失败需要在数据库记录处理日志，及处理状态为“处理失败”
5）处理成功记录处理状态为“处理成功”

#### 5.4.6 数据模型

在MediaFile类中添加mediaFileProcess_m3u8属性记录ts文件列表（MongoDB的好处，随意扩展），代码如下：

```java
//处理状态
private String processStatus;
//hls处理
private MediaFileProcess_m3u8 mediaFileProcess_m3u8;
```

```java
@Data
public class MediaFileProcess_m3u8 extends MediaFileProcess {
    //ts列表
    private List<String> tslist;
}
```

#### 5.4.7 消费端—视频生成Mp4->m3u8

视频处理结果需要保存到媒资数据库，创建dao如下：

```java
public interface MediaFileRepository extends MongoRepository<MediaFile,String> {
}
```

在application.yml中配置ffmpeg的位置及视频目录的根目录：

```yaml
xc‐service‐manage‐media:
  video-location: D:/develop/video/
  ffmpeg-path: ffmpeg.exe
```

处理任务类

在mq包下创建MediaProcessTask类，此类负责监听视频处理队列，并进行视频处理。

```java
@Component
public class MediaProcessTask {

    @Value("${xc-service-manage-media.ffmpeg-path}")
    String ffmpeg_path;

    //上传文件根目录
    @Value("${xc-service-manage-media.video-location}")
    String serverPath;

    @Autowired
    MediaFileRepository mediaFileRepository;

    //接收视频处理消息进行视频处理
    @RabbitListener(queues = "${xc-service-manage-media.mq.queue-media-video-processor}")
    public void receiveMediaProcessTask(String msg) {
        //1、解析消息内容，得到mediaId
        Map map = JSON.parseObject(msg, Map.class);
        String mediaId = (String) map.get("mediaId");
        //2、拿mediaId从数据库查询文件信息
        Optional<MediaFile> optional = mediaFileRepository.findById(mediaId);
        if (!optional.isPresent()) {
            return;
        }
        MediaFile mediaFile = optional.get();
        //文件类型
        String fileType = mediaFile.getFileType();
        if (!fileType.equals("avi")) {
            mediaFile.setProcessStatus("303004");//无需处理
            mediaFileRepository.save(mediaFile);
            return;
        } else {
            //需要处理
            mediaFile.setProcessStatus("303001");//处理中
            mediaFileRepository.save(mediaFile);
        }
        //3、使用工具类将avi文件生成mp4
        //String ffmpeg_path, String video_path, String mp4_name, String mp4folder_path
        //要处理的视频文件的路径
        String video_path = serverPath + mediaFile.getFilePath() + mediaFile.getFileName();
        //生成的mp4所在的路径
        String mp4folder_path = serverPath + mediaFile.getFilePath();
        //生成的mp4的文件名称
        String mp4_name = mediaFile.getFileId() + ".mp4";
        //创建工具类对象
        Mp4VideoUtil mp4VideoUtil = new Mp4VideoUtil(ffmpeg_path, video_path, mp4_name, mp4folder_path);
        //进行处理
        String result = mp4VideoUtil.generateMp4();
        if (result == null || !result.equals("success")) {
            //处理失败
            mediaFile.setProcessStatus("303003");
            //定义mediaFileProcess_m3u8
            MediaFileProcess_m3u8 mediaFileProcess_m3u8 = new MediaFileProcess_m3u8();
            //记录失败原因
            mediaFileProcess_m3u8.setErrormsg(result);
            mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);
            mediaFileRepository.save(mediaFile);
            return;
        }

        //4、将mp4生成m3u8和ts文件
        //String ffmpeg_path, String video_path, String m3u8_name,String m3u8folder_path
        //mp4视频文件路径
        String mp4_video_path = serverPath + mediaFile.getFilePath() + mp4_name;
        //m3u8_name文件名称
        String m3u8_name = mediaFile.getFileId() + ".m3u8";
        //m3u8文件所在目录
        String m3u8folder_path = serverPath + mediaFile.getFilePath() + "hls/";
        HlsVideoUtil hlsVideoUtil = new HlsVideoUtil(ffmpeg_path, mp4_video_path, m3u8_name, m3u8folder_path);
        //生成m3u8和ts文件
        String tsResult = hlsVideoUtil.generateM3u8();
        if (tsResult == null || !tsResult.equals("success")) {
            //处理失败
            mediaFile.setProcessStatus("303003");
            //定义mediaFileProcess_m3u8
            MediaFileProcess_m3u8 mediaFileProcess_m3u8 = new MediaFileProcess_m3u8();
            //记录失败原因
            mediaFileProcess_m3u8.setErrormsg(result);
            mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);
            mediaFileRepository.save(mediaFile);
            return;
        }
        //处理成功
        //获取ts文件列表
        List<String> ts_list = hlsVideoUtil.get_ts_list();

        mediaFile.setProcessStatus("303002");
        //定义mediaFileProcess_m3u8
        MediaFileProcess_m3u8 mediaFileProcess_m3u8 = new MediaFileProcess_m3u8();
        mediaFileProcess_m3u8.setTslist(ts_list);
        mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);

        //保存fileUrl（此url就是视频播放的相对路径）
        String fileUrl = mediaFile.getFilePath() + "hls/" + m3u8_name;
        mediaFile.setFileUrl(fileUrl);
        mediaFileRepository.save(mediaFile);
    }
}   
```

#### 5.4.8 说明

1、原始视频转成mp4如何判断转换成功？

根据视频时长来判断，取原视频和转换成功视频的时长（时分秒），如果相等则相同。

2、mp4转成m3u8如何判断转换成功？

根据视频时长来判断，同mp4转换成功的判断方法。最后还要判断m3u8文件内容是否完整。



#### 5.4.9 发送视频处理消息

当视频上传成功后向MQ 发送视频 处理消息。
修改媒资管理服务的文件上传代码，当文件上传成功向MQ发送视频处理消息。

RabbitMQ配置

将media-processor工程下的RabbitmqConfig配置类拷贝到media工程下，只需保留交换机配置

```java
@Configuration
public class RabbitMQConfig {

    public static final String EX_MEDIA_PROCESSTASK = "ex_media_processor";

    //视频处理路由
    @Value("${xc-service-manage-media.mq.routingkey-media-video}")
    public String routingkey_media_video;

    /**
     * 交换机配置
     */
    @Bean(EX_MEDIA_PROCESSTASK)
    public Exchange EX_MEDIA_VIDEOTASK() {
        return ExchangeBuilder.directExchange(EX_MEDIA_PROCESSTASK).durable(true).build();
    }

}
```

在media工程下配置mq队列等信息，修改application.yml

```yaml
xc-service-manage-media:
  mq:
    queue-media-video-processor: queue_media_video_processor
    routingkey-media-video: routingkey_media_video
```

修改Service

在文件合并方法中添加向mq发送视频处理消息的代码：

```java
@Autowired
MediaFileRepository mediaFileRepository;

@Value("${xc-service-manage-media.upload-location}")
String upload_location;

@Value("${xc-service-manage-media.mq.routingkey-media-video}")
String routingkey_media_video;

@Autowired
RabbitTemplate rabbitTemplate;
/**
     * 发送视频处理消息
     * @param mediaId 文件id
     * @return
     */
public ResponseResult sendProcessVideoMsg(String mediaId){

    //查询数据库mediaFile
    Optional<MediaFile> optional = mediaFileRepository.findById(mediaId);
    if(!optional.isPresent()){
        ExceptionCast.cast(CommonCode.FAIL);
    }
    //构建消息内容
    Map<String,String> map = new HashMap<>();
    map.put("mediaId",mediaId);
    String jsonString = JSON.toJSONString(map);
    //向MQ发送视频处理消息
    try {
        rabbitTemplate.convertAndSend(RabbitMQConfig.EX_MEDIA_PROCESSTASK,routingkey_media_video,jsonString);
    } catch (AmqpException e) {
        e.printStackTrace();
        return new ResponseResult(CommonCode.FAIL);
    }

    return new ResponseResult(CommonCode.SUCCESS);
}
```

```java
//向MQ发送视频处理消息
sendProcessVideoMsg(mediaFile.getFileId());
```



#### 5.4.10 视频处理测试

测试流程：
1、上传avi文件
2、观察日志是否发送消息
3、观察视频处理进程是否接收到消息进行处理
4、观察mp4文件是否生成
5、观察m3u8及 ts文件是否生成

> OK，就是没有删除分块文件



#### 5.4.11 视频处理并发设置

代码中使用@RabbitListener注解指定消费方法，默认情况是单线程监听队列，可以观察当队列有多个任务时消费端每次只消费一个消息，单线程处理消息容易引起消息处理缓慢，消息堆积，不能最大利用硬件资源。

可以配置mq的容器工厂参数，增加并发处理数量即可实现多线程处理监听队列，实现多线程处理消息。

1、在RabbitmqConfig.java中添加容器工厂配置

```java
//消费者并发数量
public static final int DEFAULT_CONCURRENT = 10;

//ConnectionFactory为spring框架的类
@Bean("customContainerFactory")
public SimpleRabbitListenerContainerFactory containerFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConcurrentConsumers(DEFAULT_CONCURRENT);
    factory.setMaxConcurrentConsumers(DEFAULT_CONCURRENT);
    configurer.configure(factory, connectionFactory);
    return factory;
}
```

2、在@RabbitListener注解中指定容器工厂

```java
//视频处理方法
@RabbitListener(queues = {"${xc‐service‐manage‐media.mq.queue‐media‐video‐processor}"},
                containerFactory="customContainerFactory")
```





# 13 媒资管理—媒资CRUD&集成

## 1 我的媒资

### 1.1 需求分析

通过我的媒资可以查询本教育机构拥有的媒资文件，进行文件处理、删除文件、修改文件信息等操作，具体需求如下：
1、分页查询我的媒资文件（已做）
2、删除媒资文件（略）
3、处理媒资文件（略），调用14视频处理接口即可
4、修改媒资文件信息（略）

### 1、Api

```java
@Api(value = "媒体文件管理",description = "媒体文件管理接口",tags = {"媒体文件管理接口"})
public interface MediaFileControllerApi {

    @ApiOperation("我的媒资文件查询列表")
    QueryResponseResult<MediaFile> findList(int page, int size, QueryMediaFileRequest queryMediaFileRequest);

}
```

### 2、Controller

```java
@RestController
@RequestMapping("/media/file")
public class MediaFileController implements MediaFileControllerApi {
    @Autowired
    MediaFileService mediaFileService;

    @Override
    @GetMapping("/list/{page}/{size}")
    public QueryResponseResult<MediaFile> findList(@PathVariable int page, @PathVariable int size, QueryMediaFileRequest queryMediaFileRequest) {
        return mediaFileService.findList(page, size, queryMediaFileRequest);

    }
}
```

### 3、Service

```java
@Service
public class MediaFileService {

    @Autowired
    MediaFileRepository mediaFileRepository;

    //查询我的媒资列表
    public QueryResponseResult<MediaFile> findList(int page, int size, QueryMediaFileRequest queryMediaFileRequest) {
        if(queryMediaFileRequest == null){
            queryMediaFileRequest = new QueryMediaFileRequest();
        }
        //条件值对象
        MediaFile mediaFile = new MediaFile();
        if(StringUtils.isNotEmpty(queryMediaFileRequest.getTag())){
            mediaFile.setTag(queryMediaFileRequest.getTag());
        }
        if(StringUtils.isNotEmpty(queryMediaFileRequest.getFileOriginalName())){
            mediaFile.setFileOriginalName(queryMediaFileRequest.getFileOriginalName());
        }
        if(StringUtils.isNotEmpty(queryMediaFileRequest.getProcessStatus())){
            mediaFile.setProcessStatus(queryMediaFileRequest.getProcessStatus());
        }

        //条件匹配器
        ExampleMatcher exampleMatcher = ExampleMatcher.matching()
            .withMatcher("tag",ExampleMatcher.GenericPropertyMatchers.contains())
            .withMatcher("fileOriginalName",ExampleMatcher.GenericPropertyMatchers.contains());
        //.withMatcher("processStatus",ExampleMatcher.GenericPropertyMatchers.exact());//如果不设置匹配器默认精确匹配

        //定义example条件对象
        Example<MediaFile> example = Example.of(mediaFile,exampleMatcher);
        //分页查询对象
        if(page<=0){
            page = 1;
        }
        page = page-1;
        if(size<=0){
            size = 10;
        }
        Pageable pageable = PageRequest.of(page, size);
        //分页查询
        Page<MediaFile> all = mediaFileRepository.findAll(example,pageable);
        //总记录数
        long total = all.getTotalElements();
        //数据列表
        List<MediaFile> content = all.getContent();
        //返回的数据集
        QueryResult<MediaFile> queryResult = new QueryResult<>();
        queryResult.setList(content);
        queryResult.setTotal(total);

        //返回结果
        return new QueryResponseResult(CommonCode.SUCCESS,queryResult);
    }
}
```

### 4、Dao

```java
public interface MediaFileRepository extends MongoRepository<MediaFile,String> {
}
```



### 5、前端

可参考cms系统的page_list.vue来编写此页面，api等。详细参考教程文档



## 2 媒资与课程计划关联

### 2.1 需求分析

到目前为止，媒资管理已完成文件上传、视频处理、我的媒资功能等基本功能。其它模块已可以使用媒资管理功能，本节要讲解课程计划在编辑时如何选择媒资文件。

操作的业务流程如下：
1、进入课程计划修改页面
2、选择视频
打开媒资文件查询窗口，找到该课程章节的视频，选择此视频。

![1552150721040](images/1552150721040.png)

3、 选择成功后，将在**课程管理数据库保存课程计划对应在的课程视频地址**。
在课程管理数据库创建表 **teachplan_media** 存储课程计划与媒资关联信息，如下：

![1552150754594](images/1552150754594.png)

### 2.2 选择视频（Vue）

#### 2.2.1 Vue父子组件通信

上一章已实现了我的媒资页面，所以媒资查询窗口页面不需要再开发，将“我的媒资页面”作为一个组件在修改课程计划页面中引用，如下图：

![1552150795680](images/1552150795680.png)

修改课程计划页面为父组件，我的媒资查询页面为子组件。

问题1：
我的媒资页面在选择媒资文件时不允许显示，比如“视频处理”按钮，该如何控制？
这时就需要父组件（修改课程计划页面）向子组件（我的媒资页面）传入一个变量，使用此变量来控制当前是否进入选择媒资文件业务，从而控制哪些元素不显示，如下图：

![1552150832446](images/1552150832446.png)

问题2：
在我的媒资页面选择了媒资文件，如何将选择的媒资文件信息传到父组件？
这时就需要子组件调用父组件的方法来解决此问题，如下图：

![1552150848078](images/1552150848078.png)

#### 2.2.2 父组件（修改课程计划）

本节实现功能：在课程计划页面打开我的媒资页面。

1、引入子组件

```js
import mediaList from '@/module/media/page/media_list.vue';
export default {
    components:{
        mediaList
    },
    data() {
        ....
```

2、使用子组件
在父组件的视图中使用子组件，同时传入变量ischoose，并指定父组件的方法名为choosemedia这里使用el-dialog 实现弹出窗口

```html
<el‐dialog title="选择媒资文件" :visible.sync="mediaFormVisible">
    <media‐list v‐bind:ischoose="true" @choosemedia="choosemedia"></media‐list>
</el‐dialog>
```

3、choosemedia方法
在父组件中定义choosemedia方法，接收子组件调用，参数包括：媒资文件id、媒资文件的原始名称、媒资文件url

```js
choosemedia(mediaId,fileOriginalName,mediaUrl){
}
```

4、打开子组件窗口
1）打开子组件窗口按钮定义

```vue
添加“选择视频”按钮：
<el‐button style="font‐size: 12px;" type="text" on‐click={ () => this.querymedia(data.id) }>选择视频</el‐button>
```

2、打开子组件窗口方法
定义querymedia方法：

```js
methods: {
    //打开查询媒资文件窗口，传入课程计划id
    querymedia(teachplanId){
        this.activeTeachplanId = teachplanId;
        this.mediaFormVisible = true;
    },
```

#### 3.2.3 子组件（我的媒资查询）

1、定义ischoose变量，接收父组件传入的ischoose

```js
export default{
    props: ['ischoose'],
    data(){
```

2、父组件传的ischoose变量为 true时表示当前是选择媒资文件业务，需要控制页面元素是否显示

1）ischoose=true，选择按钮显示

```html
<el‐table‐column label="选择" width="80" v‐if="ischoose == true">
    <template slot‐scope="scope">
        <el‐button
                   size="small" type="primary" plain @click="choose(scope.row)">选择</el‐button>
    </template>
    </el‐table‐column>
```

2）ischoose=false，视频处理按钮显示

```html
<el‐table‐column label="开始处理" width="100" v‐if="ischoose != true">
    <template slot‐scope="scope">
        <el‐button
                   size="small" type="primary" plain @click="process(scope.row.fileId)">开始处理
            </el‐button>
    </template>
    </el‐table‐column>
```

3、选择媒资文件方法
用户点击“选择”按钮将向父组件传递媒资文件信息

```js
choose(mediaFile){
    if(mediaFile.processStatus !='303002' && mediaFile.processStatus !='303004'){
        this.$message.error('该文件未处理，不允许选择');
        return ;
    }
    if(!mediaFile.fileUrl){
        this.$message.error('该文件的访问url为空，不允许选择');
        return ;
    }
    //调用父组件的choosemedia方法
    this.$emit('choosemedia',mediaFile.fileId,mediaFile.fileOriginalName);
}
```



### 2.3 保存视频信息

#### 1、需求分析

用户进入课程计划页面，选择视频，将课程计划与视频信息保存在课程管理数据库中。用户操作流程：
1、进入课程计划，点击”选择视频“，打开我的媒资查询页面
2、为课程计划选择对应的视频，选择“选择”
3、前端请求课程管理服务保存课程计划与视频信息。

#### 2、数据模型

在课程管理数据库创建表 teachplan_media 存储课程计划与媒资关联信息，创建teachplanMedia 模型类：

```java
@Data
@Entity
@Table(name="teachplan_media")
@GenericGenerator(name = "jpa-assigned", strategy = "assigned")
public class TeachplanMedia implements Serializable {
    private static final long serialVersionUID = -916357110051689485L;
    @Id
    @GeneratedValue(generator = "jpa-assigned")
    @Column(name="teachplan_id")
    private String teachplanId;

    @Column(name="media_id")
    private String mediaId;

    @Column(name="media_fileoriginalname")
    private String mediaFileOriginalName;

    @Column(name="media_url")
    private String mediaUrl;
    
    @Column(name="courseid")
    private String courseId;

}
```

#### 3、Api

此接口作为前端请求课程管理服务保存课程计划与视频信息的接口，在**课程管理服务**增加接口：

```java
@ApiOperation("保存媒资信息")
ResponseResult savemedia(TeachplanMedia teachplanMedia);
```

#### 4、Controller

```java
@Override
@PostMapping("/savemedia")
public ResponseResult savemedia(@RequestBody TeachplanMedia teachplanMedia) {
    return courseService.savemedia(teachplanMedia);
}
```

#### 5、Service

```java
@Autowired
private TeachplanMediaRepository teachplanMediaRepository;

//保存课程计划与媒资文件的关联信息
public ResponseResult savemedia(TeachplanMedia teachplanMedia) {
    if(teachplanMedia == null || StringUtils.isEmpty(teachplanMedia.getTeachplanId())){
        ExceptionCast.cast(CommonCode.INVALID_PARAM);
    }
    //校验课程计划是否是3级
    //课程计划
    String teachplanId = teachplanMedia.getTeachplanId();
    //查询到课程计划
    Optional<Teachplan> optional = teachplanRepository.findById(teachplanId);
    if(!optional.isPresent()){
        ExceptionCast.cast(CommonCode.INVALID_PARAM);
    }
    //查询到教学计划
    Teachplan teachplan = optional.get();
    //取出等级
    String grade = teachplan.getGrade();
    if(StringUtils.isEmpty(grade) || !grade.equals("3")){
        //只允许选择第三级的课程计划关联视频
        ExceptionCast.cast(CourseCode.COURSE_MEDIA_TEACHPLAN_GRADEERROR);
    }
    //查询teachplanMedia
    Optional<TeachplanMedia> mediaOptional = teachplanMediaRepository.findById(teachplanId);
    TeachplanMedia one = mediaOptional.orElseGet(TeachplanMedia::new);

    //将one保存到数据库
    one.setCourseId(teachplan.getCourseid());//课程id
    one.setMediaId(teachplanMedia.getMediaId());//媒资文件的id
    one.setMediaFileOriginalName(teachplanMedia.getMediaFileOriginalName());//媒资文件的原始名称
    one.setMediaUrl(teachplanMedia.getMediaUrl());//媒资文件的url
    one.setTeachplanId(teachplanId);
    teachplanMediaRepository.save(one);

    return new ResponseResult(CommonCode.SUCCESS);
}
```

#### 6、Dao

```java
public interface TeachplanMediaRepository extends JpaRepository<TeachplanMedia,String> {
}
```

#### 7、前端

略，查看文档

#### 8、测试

1、向叶子结点课程计划保存媒资信息
操作结果：保存成功
2、向非叶子结点课程计划保存媒资信息
操作结果：保存失败



### 2.4 查询视频信息

#### 2.4.1 需求分析

课程计划的视频信息保存后在页面无法查看，本节解决课程计划页面显示相关联的媒资信息。

解决方案：在获取课程计划树结点信息时将关联的媒资信息一并查询，并在前端显示，下图说明了课程计划显示的区域。

#### 2.4.2 Dao

修改课程计划查询的Dao，关联课程计划媒资表！此处记得同步到Elasticsearch中

1、修改模型。在课程计划结果信息中添加媒资信息

```java
@Data
public class TeachplanNode extends Teachplan {

    List<TeachplanNode> children;

    //媒资信息
    private String mediaId;
    private String mediaFileOriginalName;
}
```

2、修改sql语句，添加关联查询媒资信息。添加mediaId、mediaFileOriginalName

```xml
<mapper namespace="com.xuecheng.manage_course.dao.TeachplanMapper">

    <select id="selectList" parameterType="java.lang.String" resultMap="teachplanMap">
        SELECT a.id    one_id,
               a.pname one_pname,
               b.id    two_id,
               b.pname two_pname,
               c.id    three_id,
               c.pname three_pname,
               media.media_id,
               media.media_fileoriginalname
        FROM teachplan a
                 LEFT JOIN teachplan b ON a.id = b.parentid
                 LEFT JOIN teachplan c ON b.id = c.parentid
                 LEFT JOIN teachplan_media media ON c.id = media.teachplan_id
        WHERE a.parentid = '0'
          <if test="_parameter!=null and _parameter !='' ">
              AND a.courseid = #{courseId}/*courseId变量名随便起*/
          </if>
        ORDER BY a.orderby,
                 b.orderby,
                 c.orderby
    </select>

    <resultMap id="teachplanMap" type="com.xuecheng.framework.domain.course.ext.TeachplanNode">
        <id property="id" column="one_id" />
        <result property="pname" column="one_pname" />
        <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
            <id property="id" column="two_id"/>
            <result property="pname" column="two_pname"/>
            <collection property="children" ofType="com.xuecheng.framework.domain.course.ext.TeachplanNode">
                <id property="id" column="three_id"/>
                <result property="pname" column="three_pname"/>
                <result column="media_id" property="mediaId"/>
                <result column="media_fileoriginalname" property="mediaFileOriginalName"/>
            </collection>
        </collection>
    </resultMap>
</mapper>
```



#### 2.4.3 页面查询视频

课程计划结点信息已包括媒资信息，可在页面获取信息后显示：

```vue
<el‐button style="font‐size: 12px;" type="text" on‐click={ () => this.querymedia(data.id) }>
{data.mediaFileOriginalName}&nbsp;&nbsp;&nbsp;&nbsp;选择视频</el‐button>
```

选择视频后立即刷新课程计划树，在提交成功后，添加查询课程计划代码：this.findTeachplan()，完整代码如下：

```js
choosemedia(mediaId,fileOriginalName,mediaUrl){
    this.mediaFormVisible = false;
    //保存课程计划与视频对应关系
    let teachplanMedia = {};
    teachplanMedia.teachplanId = this.activeTeachplanId;
    teachplanMedia.mediaId = mediaId;
    teachplanMedia.mediaFileOriginalName = fileOriginalName;
    teachplanMedia.mediaUrl = mediaUrl;
    teachplanMedia.courseId = this.courseid;
    //保存媒资信息到课程数据库
    courseApi.savemedia(teachplanMedia).then(res=>{
        if(res.success){
            this.$message.success("选择视频成功")
            //查询课程计划
            this.findTeachplan()
        }else{
            this.$message.error(res.message)
        }
    })
},
```





# 14 媒资管理—系统集成—在线学习

## 1 学习页面查询课程计划

### 1.1 需求分析

到目前为止，我们已可以编辑课程计划信息并上传课程视频，下一步我们要实现在线学习页面动态读取章节对应的视频并进行播放。在线学习页面所需要的信息有两类：一类是**课程计划信息**、一类是**课程学习信息**（视频地址、学习进度等）

在线学习集成媒资管理的需求如下：
1、在线学习页面显示课程计划
2、点击课程计划播放该课程计划对应的视频

本章节实现学习页面动态显示课程计划，进入不同课程的学习页面右侧动态显示当前课程的课程计划。

### 1.2 Api

课程计划信息从哪里获取？

目前课程计划信息在课程管理数据库和**ES索引库**中存在，考虑性能要求，课程发布后对课程的查询统一从ES索引库中查询。

前端通过**请求搜索服务**获取课程信息，需要单独在搜索服务中定义课程信息查询接口。本接口接收课程id，查询课程所有信息返回给前端。返回的课程信息为json结构：key为课程id，value为课程内容。

```java
@Api(value = "课程搜索",description = "课程搜索",tags = {"课程搜索"})
public interface EsCourseControllerApi {

    @ApiOperation("根据课程id查询课程信息")
    Map<String,CoursePub> getById(String id);
}
```

### 1.3 Controller 

```java
@RestController
@RequestMapping("/search/course")
public class EsCourseController implements EsCourseControllerApi {
    @Autowired
    private EsCourseService esCourseService;

    @Override
    @GetMapping("/getall/{id}")
    public Map<String, CoursePub> getall(@PathVariable String id) {
        return esCourseService.getall(id);
    }
}
```

### 1.4 Service

```java
@Service
public class EsCourseService {
    @Value("${xuecheng.course.index}")
    private String index;

    @Value("${xuecheng.course.type}")
    private String type;

    @Value("${xuecheng.course.source_field}")
    private String source_field;

    @Autowired
    private RestHighLevelClient client;
    //使用ES的客户端向ES请求查询索引信息
    public Map<String, CoursePub> getall(String id) {
        //定义一个搜索请求对象
        SearchRequest searchRequest = new SearchRequest(index);
        //指定type
        searchRequest.types(type);
        //定义SearchSourceBuilder
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
        //设置使用termQuery
        searchSourceBuilder.query(QueryBuilders.termQuery("id", id));
        //过虑源字段，不用设置源字段，取出所有字段
        //searchSourceBuilder.fetchSource()
        searchRequest.source(searchSourceBuilder);

        //最终要返回的课程信息
        Map<String, CoursePub> map = new HashMap<>();
        try {
            SearchResponse search = client.search(searchRequest);
            SearchHits hits = search.getHits();
            SearchHit[] searchHits = hits.getHits();
            for (SearchHit hit : searchHits) {
                CoursePub coursePub = new CoursePub();
                //获取源文档的内容
                Map<String, Object> sourceAsMap = hit.getSourceAsMap();
                //课程id
                String courseId = (String) sourceAsMap.get("id");
                String name = (String) sourceAsMap.get("name");
                String grade = (String) sourceAsMap.get("grade");
                String charge = (String) sourceAsMap.get("charge");
                String pic = (String) sourceAsMap.get("pic");
                String description = (String) sourceAsMap.get("description");
                String teachplan = (String) sourceAsMap.get("teachplan");
                coursePub.setId(courseId);
                coursePub.setName(name);
                coursePub.setPic(pic);
                coursePub.setGrade(grade);
                coursePub.setTeachplan(teachplan);
                coursePub.setDescription(description);
                map.put(courseId, coursePub);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        return map;
    }
}
```

没有Dao，直接Service层调用Elasticsearch

### 1.5 前端

配置虚拟主机Nginx解决跨域

学习中心的二级域名为ucenter.xuecheng.com，我们在nginx中配置ucenter虚拟主机。

在学习中心要调用搜索的API，使用Nginx解决代理，如下图：

![1552375416295](images/1552375416295.png)

```nginx
#学成网用户中心
server {
	listen 80;
	server_name ucenter.xuecheng.com;
		
	#个人中心
	location / {
		proxy_pass http://ucenter_server_pool;
	}
		
	#后端搜索服务
	location /openapi/search/ {
		proxy_pass http://search_server_pool/search/;
	}
}
```

```nginx
#后台搜索（公开api）
upstream search_server_pool{
	server 127.0.0.1:40100 weight=10;
}
```



调用该Api。teachplan中存储的是字符串，需要转为JSON对象

```js
export const course_view = id =>  http.requestGet('/openapi/search/course/getall/'+id);
```

```js
created(){
    //当前请求的url
    this.url = window.location;
    //课程id
    this.courseId = this.$route.params.courseId;
    //章节id
    this.chapter = this.$route.params.chapter;
    //取出课程Id
    systemApi.course_view(this.courseId).then((view_course)=>{
        if (!view_course || !view_course[this.courseId]){
            this.$message.error("获取课程信息失败，请重新进入此页面！");
            return;
        }
        console.log(view_course);

        let teachplanString = view_course[this.courseId];

        this.coursename = teachplanString.name;
		//由于teachplan中存储的是字符串，所以需要转为JSON
        if (teachplanString.teachplan){
            let teachplan = JSON.parse(teachplanString.teachplan);
            this.teachplanList = teachplan.children;
        }

    })
}
```

在浏览器请求：http://ucenter.xuecheng.com/#/learning/4028e581617f945f01617f9dabc40000/0。第一个参数为课程id，测试时从ES索引库找一个课程id；第二个参数为课程计划id，此参数用于点击课程计划播放视频。



## 2 学习页面获取视频播放地址

### 2.1 需求分析

用户进入在线学习页面，点击课程计划将播放该课程计划对应的教学视频。业务流程如下（由底层开始写，右边开始）：

![1552383361077](images/1552383361077.png)

业务流程说明：
1、用户进入在线学习页面，页面请求搜索服务获取课程信息（包括课程计划信息）并且在页面展示。
2、在线学习请求**学习服务**获取**视频播放地址**。
3、学习服务**校验当前用户是否有权限学习**，如果没有权限学习则提示用户。
4、学习服务校验通过，请求**搜索服务**获取媒资信息。
5、搜索服务请求ElasticSearch获取课程媒资信息。

为什么要请求ElasticSearch查询课程媒资信息？出于**性能**的考虑，公开查询课程信息从搜索服务查询。
什么时候将课程媒资信息存储到ElasticSearch中？课程媒资信息是在课程发布的时候存入ElasticSearch，因为课程发布后课程信息将基本不再修改。

### 2.2 课程发布存储课程计划媒资

#### 2.2.1 需求分析

课程媒资信息是在课程发布的时候存入ElasticSearch索引库，因为课程发布后课程信息将基本不再修改，具体的业务流程如下：

1、课程发布，向课程媒资信息表写入数据。
	1）根据课程id删除teachplanMediaPub中的数据
	2）根据课程id查询teachplanMedia数据
	3）将查询到的teachplanMedia数据插入到teachplanMediaPub中
2、Logstash定时扫描课程媒资信息表，并将课程媒资信息写入索引库。

#### 2.2.2 数据模型

在xc_course数据库创建课程计划媒资发布表`teachplan_media_pub`，就比`teachplan_media`多了个时间戳用于同步到ES中

```sql
CREATE TABLE `teachplan_media_pub` (
    `teachplan_id` varchar(32) NOT NULL COMMENT '课程计划id',
    `media_id` varchar(32) NOT NULL COMMENT '媒资文件id',
    `media_fileoriginalname` varchar(128) NOT NULL COMMENT '媒资文件的原始名称',
    `media_url` varchar(256) NOT NULL COMMENT '媒资文件访问地址',
    `courseid` varchar(32) NOT NULL COMMENT '课程Id',
    `timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT
    'logstash使用',
    PRIMARY KEY (`teachplan_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```

对应实体类：

```java
@Data
@Entity
@Table(name="teachplan_media_pub")
@GenericGenerator(name = "jpa-assigned", strategy = "assigned")
public class TeachplanMediaPub implements Serializable {
    private static final long serialVersionUID = 6674564843676926305L;
    @Id
    @GeneratedValue(generator = "jpa-assigned")
    @Column(name="teachplan_id")
    private String teachplanId;

    @Column(name="media_id")
    private String mediaId;

    @Column(name="media_fileoriginalname")
    private String mediaFileOriginalName;

    @Column(name="media_url")
    private String mediaUrl;

    @Column(name="courseid")
    private String courseId;

    @Column(name="timestamp")
    private Date timestamp;//时间戳
}
```

#### 2.2.3 Dao

创建TeachplanMediaPub表的Dao，向TeachplanMediaPub存储信息采用先删除该课程的媒资信息，再添加该课程的媒资信息，所以这里定义根据课程id删除课程计划媒资方法：

```java
public interface TeachplanMediaPubRepository extends JpaRepository<TeachplanMediaPub,String> {
    //根据课程id删除
    long deleteByCourseId(String courseId);
}
```

还有根据课程id查找TeachplanMedia的Dao

```java
public interface TeachplanMediaRepository extends JpaRepository<TeachplanMedia,String> {
    //根据课程id查询媒资列表
    List<TeachplanMedia> findByCourseId(String courseId);
}
```

#### 2.2.4 Service

编写保存课程计划媒资信息方法，并在课程发布时调用此方法。本方法采用先删除该课程的媒资信息，再添加该课程的媒资信息。

```java
@Service
public class CourseService {
    @Transactional
    public CoursePublishResult publish(String courseId) {
        CourseBase courseBase = this.findCourseBaseById(courseId);

        //发布课程预览页面
        CmsPage cmsPage = new CmsPage();
        cmsPage.setSiteId(publish_siteId);//课程预览站点
        cmsPage.setPageName(courseId + ".html");//页面名称
        cmsPage.setPageAliase(courseBase.getName());//页面别名
        cmsPage.setPageWebPath(publish_page_webpath);//页面访问路径
        cmsPage.setPagePhysicalPath(publish_page_physicalpath);//页面存储路径
        cmsPage.setDataUrl(publish_dataUrlPre + courseId);//数据url
        cmsPage.setTemplateId(publish_templateId);//模板

        //调用CMS一键发布接口，将课程详细页面发布到服务器
        CmsPostPageResult result = cmsPageClient.postPageQuick(cmsPage);
        if (!result.isSuccess()){
            return new CoursePublishResult(CommonCode.FAIL,null);
        }
        //保存课程发布状态为已发布
        CourseBase base = saveCoursePubState(courseId);
        if (Objects.isNull(base)){
            ExceptionCast.cast(CommonCode.FAIL);
        }

        //保存课程索引信息
        //先创建一个coursePub对象，组合分散的表中信息
        CoursePub coursePub = this.createCoursePut(courseId);
        //将coursePub对象保存到数据库
        this.saveCoursePub(courseId, coursePub);
        
		//=====================================================================================//
        //向TeachplanMediaPub中保存课程媒资信息
        saveTeachplanMediaPub(courseId);
        //=====================================================================================//
        
        //得到页面URL
        String pageUrl = result.getPageUrl();
        return new CoursePublishResult(CommonCode.SUCCESS,pageUrl);
    }

    //向teachplanMediaPub中保存课程媒资信息
    private void saveTeachplanMediaPub(String courseId){
        //先删除teachplanMediaPub中的数据
        teachplanMediaPubRepository.deleteByCourseId(courseId);
        //从teachplanMedia中查询
        List<TeachplanMedia> teachplanMediaList = teachplanMediaRepository.findByCourseId(courseId);
        List<TeachplanMediaPub> teachplanMediaPubs = new ArrayList<>();
        //将teachplanMediaList数据放到teachplanMediaPubs中
        for(TeachplanMedia teachplanMedia:teachplanMediaList){
            TeachplanMediaPub teachplanMediaPub = new TeachplanMediaPub();
            BeanUtils.copyProperties(teachplanMedia,teachplanMediaPub);
            //添加时间戳
            teachplanMediaPub.setTimestamp(new Date());
            teachplanMediaPubs.add(teachplanMediaPub);
        }
        //将teachplanMediaList插入到teachplanMediaPub
        teachplanMediaPubRepository.saveAll(teachplanMediaPubs);
    }
}
```

#### 2.2.5 测试

测试课程发布后是否成功将课程媒资信息存储到`teachplan_media_pub`中，测试流程如下：
1、指定一个课程
2、为课程计划添加课程媒资
3、执行课程发布
4、观察课程计划媒资信息是否存储至`teachplan_media_pub`中。可能会有多条数据（一个课程多个媒资）
注意：由于此测试仅用于测试发布课程计划媒资信息的功能，可暂时将cms页面发布的功能暂时屏蔽，提高测试效率。

### 2.3 Logstash扫描课程计划媒资

Logstash定时扫描课程媒资信息表，并将课程媒资信息写入索引库。

#### 2.3.1 创建索引

1、使用ES-head或其他方式创建`xc_course_media`索引
2、并向此索引创建如下映射`xc_course_media`索引：`Post http://localhost:9200/xc_course_media/doc/_mapping`

```json
{
    "properties": {
        "courseid": {
            "type": "keyword"
        },
        "teachplan_id": {
            "type": "keyword"
        },
        "media_id": {
            "type": "keyword"
        },
        "media_url": {
            "index": false,
            "type": "text"
        },
        "media_fileoriginalname": {
            "index": false,
            "type": "text"
        }
    }
}
```

#### 2.3.2 创建Logstash模板文件

在logstach的config目录创建`xc_course_media_template.json`，内容如下：

```json
{
   "mappings" : {
      "doc" : {
         "properties" : {
           "courseid" : {
               "type" : "keyword"
            },
            "teachplan_id" : {
               "type" : "keyword"
            },
            "media_id" : {
               "type" : "keyword"
            },
            "media_url" : {
               "index" : false,
               "type" : "text"
            },
            "media_fileoriginalname" : {
               "index" : false,
               "type" : "text"
            }
      }
   },
   "template" : "xc_course_media"
}
```

#### 2.3.3 配置mysql.conf

在logstash的config目录下配置`mysql_course_media.conf`文件供logstash使用，logstash会根据`mysql_course_media.conf`文件的配置的地址从MySQL中读取数据向ES中写入索引。参考https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html

```nginx
input {
  stdin {
  }
  jdbc {
  jdbc_connection_string => "jdbc:mysql://localhost:3306/xc_course?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC"
  # the user we wish to excute our statement as
  jdbc_user => "root"
  jdbc_password => w111151
  # the path to our downloaded jdbc driver  
  jdbc_driver_library => "D:/Maven_repository/mysql/mysql-connector-java/5.1.40/mysql-connector-java-5.1.40.jar"
  # the name of the driver class for mysql
  jdbc_driver_class => "com.mysql.jdbc.Driver"
  jdbc_paging_enabled => "true"
  jdbc_page_size => "50000"
  #要执行的sql文件
  #statement_filepath => "/conf/course.sql"
  statement => "select * from teachplan_media_pub where timestamp > date_add(:sql_last_value,INTERVAL 8 HOUR)"
  #定时配置
  schedule => "* * * * *"
  record_last_run => true
  last_run_metadata_path => "C:/Develop/Elasticsearch/logstash-6.2.1/config/xc_course_media_metadata"
  }
}


output {
  elasticsearch {
  #ES的ip地址和端口
  hosts => "localhost:9200"
  #hosts => ["localhost:9200","localhost:9202","localhost:9203"]
  #ES索引库名称
  index => "xc_course_media"
  document_id => "%{teachplan_id}"
  document_type => "doc"
  template =>"C:/Develop/Elasticsearch/logstash-6.2.1/config/xc_course_media_template.json"
  template_name =>"xc_course_media"
  template_overwrite =>"true"
  }
  stdout {
 #日志输出
  codec => json_lines
  }
}
```

#### 2.3.4 启动logstash.bat

启动logstash.bat采集teachplan_media_pub中的数据，向ES写入索引。`logstash.bat ‐f ../config/mysql_course_media.conf`



### 2.4 搜索服务查询课程媒资接口

#### 2.4.1 需求分析

搜索服务提供查询课程媒资接口，此接口供学习服务调用。

#### 2.4.2 Api

在课程搜索包下定义Api

```java
@Api(value = "课程搜索",description = "课程搜索",tags = {"课程搜索"})
public interface EsCourseControllerApi {

    @ApiOperation("根据课程计划id查询课程媒资信息")
    TeachplanMediaPub getmedia(String id);
}
```

#### 2.4.3 Controller

```java
@RestController
@RequestMapping("/search/course")
public class EsCourseController implements EsCourseControllerApi {
    @Autowired
    EsCourseService esCourseService;

    @Override
    @GetMapping(value="/getmedia/{teachplanId}")
    public TeachplanMediaPub getmedia(@PathVariable("teachplanId") String teachplanId) {
        //将一个id加入数组，传给service方法
        String[] teachplanIds = new String[]{teachplanId};
        QueryResponseResult<TeachplanMediaPub> queryResponseResult = esCourseService.getmedia(teachplanIds);
        QueryResult<TeachplanMediaPub> queryResult = queryResponseResult.getQueryResult();
        if(queryResult != null){
            List<TeachplanMediaPub> list = queryResult.getList();
            if(list !=null && list.size()>0){
                return list.get(0);
            }
        }
        return new TeachplanMediaPub();
    }
}
```

#### 2.4.4 Service

application.yml中添加

```yaml
xuecheng:
  media:
    index: xc_course_media
	type: doc
	source_field: courseid,media_id,media_url,teachplan_id,media_fileoriginalname
```



```java
@Service
public class EsCourseService {
    @Value("${xuecheng.media.index}")
    private String media_index;
    @Value("${xuecheng.media.type}")
    private String media_type;
    @Value("${xuecheng.media.source_field}")
    private String media_source_field;

    @Autowired
    RestHighLevelClient restHighLevelClient;
    //根据多个课程计划查询课程媒资信息
    public QueryResponseResult<TeachplanMediaPub> getmedia(String[] teachplanIds) {
        //定义一个搜索请求对象
        SearchRequest searchRequest = new SearchRequest(media_index);
        //指定type
        searchRequest.types(media_type);

        //定义SearchSourceBuilder
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
        //设置使用termsQuery根据多个id 查询
        searchSourceBuilder.query(QueryBuilders.termsQuery("teachplan_id",teachplanIds));
        //过虑源字段
        String[] includes = media_source_field.split(",");
        searchSourceBuilder.fetchSource(includes,new String[]{});
        searchRequest.source(searchSourceBuilder);
        //使用es客户端进行搜索请求Es
        List<TeachplanMediaPub> teachplanMediaPubList = new ArrayList<>();
        long total = 0;
        try {
            //执行搜索
            SearchResponse search = restHighLevelClient.search(searchRequest);
            SearchHits hits = search.getHits();
            total = hits.totalHits;
            SearchHit[] searchHits = hits.getHits();
            for(SearchHit hit:searchHits){
                TeachplanMediaPub teachplanMediaPub= new TeachplanMediaPub();
                Map<String, Object> sourceAsMap = hit.getSourceAsMap();
                //取出课程计划媒资信息
                String courseid = (String) sourceAsMap.get("courseid");
                String media_id = (String) sourceAsMap.get("media_id");
                String media_url = (String) sourceAsMap.get("media_url");
                String teachplan_id = (String) sourceAsMap.get("teachplan_id");
                String media_fileoriginalname = (String) sourceAsMap.get("media_fileoriginalname");

                teachplanMediaPub.setCourseId(courseid);
                teachplanMediaPub.setMediaUrl(media_url);
                teachplanMediaPub.setMediaFileOriginalName(media_fileoriginalname);
                teachplanMediaPub.setMediaId(media_id);
                teachplanMediaPub.setTeachplanId(teachplan_id);
                teachplanMediaPubList.add(teachplanMediaPub);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
        //数据集合
        QueryResult<TeachplanMediaPub> queryResult = new QueryResult<>();
        queryResult.setList(teachplanMediaPubList);
        queryResult.setTotal(total);
        QueryResponseResult<TeachplanMediaPub> queryResponseResult = new QueryResponseResult<>(CommonCode.SUCCESS,queryResult);
        return queryResponseResult;
    }
}
```

#### 2.4.5 测试

使用swagger-ui和postman测试课程媒资查询接口，传入课程计划id`teachplan_id`



## 3 在线学习接口

### 3.1 需求分析

根据下边的业务流程（与2中一致），本章节完成前端学习页面请求学习服务获取课程视频地址，并自动播放视频。

![1552399452911](images/1552399452911.png)

### 3.2 创建学习服务工程

创建xc_learning数据库，学习数据库将记录学生的选课信息、学习信息。导入：资料/xc_learning.sql

参考课程管理服务工程结构，创建学习服务工程。解压`xc-service-learning.zip`，依赖参考文档，application.yml如下：

```yaml
server:
  port: ${PORT:40600}
spring:
  application:
    name: xc-service-learning
  datasource:
    druid:
      url: ${MYSQL_URL:jdbc:mysql://localhost:3306/xc_learning?characterEncoding=utf-8}
      username: root
      password: w111151
      driverClassName: com.mysql.jdbc.Driver
      initialSize: 5  #初始建立连接数量
      minIdle: 5  #最小连接数量
      maxActive: 20 #最大连接数量
      maxWait: 10000  #获取连接最大等待时间，毫秒
      testOnBorrow: true #申请连接时检测连接是否有效
      testOnReturn: false #归还连接时检测连接是否有效
      timeBetweenEvictionRunsMillis: 60000 #配置间隔检测连接是否有效的时间（单位是毫秒）
      minEvictableIdleTimeMillis: 300000  #连接在连接池的最小生存时间（毫秒）
#rabbitmq配置
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
    publisher-confirms: true
    virtual-host: /
eureka:
  client:
    registerWithEureka: true #服务注册开关
    fetchRegistry: true #服务发现开关
    serviceUrl: #Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔
      defaultZone: ${EUREKA_SERVER:http://localhost:50101/eureka/,http://localhost:50102/eureka/}
  instance:
    prefer-ip-address:  true  #将自己的ip地址注册到Eureka服务中
    ip-address: ${IP_ADDRESS:127.0.0.1}
    instance-id: ${spring.application.name}:${server.port} #指定实例id
ribbon:
  MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试，如果eureka中找不到服务则直接走断路器
  MaxAutoRetriesNextServer: 3 #切换实例的重试次数
  OkToRetryOnAllOperations: false  #对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false
  ConnectTimeout: 5000  #请求连接的超时时间
  ReadTimeout: 6000 #请求处理的超时时间
```

ribbon不配置也能用，但是不好🙂。启动类如下：

```java
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
@EntityScan(value = {"com.xuecheng.framework.domain.learning","com.xuecheng.framework.domain.task"})//扫描实体类
@ComponentScan(basePackages={"com.xuecheng.api"})//扫描接口
@ComponentScan(basePackages={"com.xuecheng.learning"})//扫描接口
@ComponentScan(basePackages={"com.xuecheng.framework"})//扫描common下的所有类
public class LearningApplication {

    public static void main(String[] args) throws Exception {
        SpringApplication.run(LearningApplication.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    }
}
```



### 3.3 Api

此api接口是课程学习页面请求学习服务获取课程学习地址。

定义返回值类型：

```java
@Data
@NoArgsConstructor
public class GetMediaResult extends ResponseResult {
    //媒资文件播放地址
    private String fileUrl;

    public GetMediaResult(ResultCode resultCode, String fileUrl) {
        super(resultCode);
        this.fileUrl = fileUrl;
    }
}
```

定义接口，学习服务根据传入课程ID（用来校验）、章节Id（课程计划ID）来取学习地址。

```java
package com.xuecheng.api.learning;

@Api(value = "录播课程学习管理", description = "录播课程学习管理")
public interface CourseLearningControllerApi {
    
    @ApiOperation("获取课程学习地址")
    GetMediaResult getmedia(String courseId, String teachplanId);
}
```



### 3.4 服务端开发

学习服务根据传入课程ID（用来校验）、章节Id（课程计划ID）来取学习地址。

#### 3.4.1 搜索服务注册到Eureka

添加Eureka依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

配置Eureka

```yaml
server:
  port: ${port:40100}
spring:
  application:
    name: xc-service-search
    # 其他的省略
eureka:
  client:
    registerWithEureka: true #服务注册开关
    fetchRegistry: true #服务发现开关
    serviceUrl: #Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔。由于是高可用环境，写一个也行。
      defaultZone: ${EUREKA_SERVER:http://localhost:50101/eureka/}
  instance:
    prefer-ip-address:  true  #将自己的ip地址注册到Eureka服务中
    ip-address: ${IP_ADDRESS:127.0.0.1}
    instance-id: ${spring.application.name}:${server.port} #指定实例id
ribbon:
  MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试，如果eureka中找不到服务则直接走断路器
  MaxAutoRetriesNextServer: 3 #切换实例的重试次数
  OkToRetryOnAllOperations: false  #对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false
  ConnectTimeout: 5000  #请求连接的超时时间
  ReadTimeout: 6000 #请求处理的超时时间
```

启动类注解`@EnableDiscoveryClient`



#### 3.4.2 搜索服务Feign客户端

**根据接口文档编写**！在学习服务创建搜索服务的客户端接口，此接口会生成代理对象，调用搜索服务：

```java
@FeignClient("XC-SERVICE-SEARCH")
public interface CourseSearchClient {

    @GetMapping("/search/course/getmedia/{teachplanId}")
    TeachplanMediaPub getmedia(@PathVariable String teachplanId);
}
```



#### 3.4.3 Service

在学习服务中定义service方法，此方法远程请求课程管理服务、媒资管理服务获取课程学习地址。

```java
@Service
public class LearningService {
    @Autowired
    private CourseSearchClient courseSearchClient;

    //获取课程
    public GetMediaResult getMedia(String courseId, String teachplanId) {
        //根据courseId校验学生的学习权限，资费等......

        //远程调用搜索服务查询
        TeachplanMediaPub getmedia = courseSearchClient.getmedia(teachplanId);
        if (getmedia ==null || StringUtils.isEmpty(getmedia.getMediaUrl())){
            //获取视频播放地址出错
            ExceptionCast.cast(LearningCode.LEARNING_GETMEDIA_ERROR);
        }
        return new GetMediaResult(CommonCode.SUCCESS,getmedia.getMediaUrl());

    }
}
```



#### 3.4.4 Controller

调用service根据课程计划id查询视频播放地址：

```java
@RestController
@RequestMapping("/learning/course")
public class CourseLearningController implements CourseLearningControllerApi {
    @Autowired
    private LearningService learningService;

    @Override
    @GetMapping("/getmedia/{courseId}/{teachplanId}")
    public GetMediaResult getmedia(@PathVariable String courseId, @PathVariable String teachplanId) {

        //获取课程学习地址
        return learningService.getMedia(courseId, teachplanId);
    }
}
```



#### 3.4.5 测试

使用swagger-ui或postman测试学习服务查询课程视频地址接口。



### 3.5 前端开发

需要在学习中心前端页面需要完成如下功能：
1、进入课程学习页面需要带上课程Id参数及课程计划Id的参数，其中课程Id参数必带，课程计划Id可以为空。
2、进入页面根据课程Id取出该课程的课程计划显示在右侧。
3、进入页面后判断如果请求参数中有课程计划Id则播放该章节的视频。
4、进入页面后判断如果课程计划id为0则需要取出本课程第一个课程计划的Id，并播放第一个课程计划的视频。

#### 3.5.1 Api方法

```js
/*获取播放地址*/
export const get_media = (courseId,chapter) => http.requestGet(apiUrl+'/learning/course/getmedia/'+courseId+'/'+chapter);
```

配置代理。在Nginx中的ucenter.xuecheng.com虚拟主机中配置/api/learning/的路径转发，此url请转发到学习服务。

```nginx
#学成网用户中心
server {
	listen 80;
	server_name ucenter.xuecheng.com;
		
	#学习服务
	location ^~ /api/learning/ {
		proxy_pass http://learning_server_pool/learning/;
	}
}
```

```conf
#学习服务
upstream learning_server_pool{
	server 127.0.0.1:40600 weight=10;
}
```

> 可能后续播放不了视频，提示找不到视频，需要修改之前的配置
>
> ```nginx
> #学成网媒体服务
> server {
> 	listen 90;
> 	server_name localhost;
> 		
> 	#视频目录
> 	location /video/ {
> 		alias D:/develop/video/;
> 	}
> }
> ```



#### 3.5.2 视频播放页面

1、如果传入的课程计划id为0则取出第一个课程计划id，否则播放该课程计划id对应视频

```js
methods: {
    playvideo(video_src){
        console.log(video_src)
        this.playerOptions.sources[0].src = video_src
        this.playerOptions.autoplay = true
    },

        //开始学习，获取课程计划所对应的视频地址
        study (chapter) {
            console.log("study...")
            //get_media方法
            courseApi.get_media(this.courseId,chapter).then(res=>{
                if(res.success){
                    console.log(res);
                    //获取视频播放地址
                    let fileUrl = res.fileUrl;//相对路径
                    let videoUrl = sysConfig.videoUrl + fileUrl;//视频完整的播放路径
                    //播放视频
                    this.playvideo(videoUrl)
                }
            })
        },
},
    created() {
        //当前请求的url
        this.url = window.location;
        //课程id
        this.courseId = this.$route.params.courseId;
        //章节id
        this.chapter = this.$route.params.chapter;
        //取出课程Id
        systemApi.course_view(this.courseId).then((view_course) => {
            if (!view_course || !view_course[this.courseId]) {
                this.$message.error("获取课程信息失败，请重新进入此页面！");
                return;


                let teachplanString = view_course[this.courseId];
                this.coursename = teachplanString.name;
                if (teachplanString.teachplan) {
                    let teachplan = JSON.parse(teachplanString.teachplan);
                    this.teachplanList = teachplan.children;
                }

                //如果课程计划id不为0，则播放该id对应的课程视频
                if (this.chapter !== '0') {
                    this.study(this.chapter);
                } else {
                    //找到该课程“二级课程计划”中的第一个课程计划id，去除对应视频
                    for (let i = 0; i < this.teachplanList.length; i++) {
                        let firstTeachplan = this.teachplanList[i];
                        if (firstTeachplan.children && firstTeachplan.children.length > 0) {
                            //取出二级课程计划中的第一个
                            let secondTeachplan = firstTeachplan.children[0];
                            this.study(secondTeachplan.id);
                            return;
                        }
                    }
                }
            }
        })
    },
```

2、点击右侧课程章节切换播放

在原有代码基础上添加click事件，点击调用开始学习方法（study）。

```html
<li v‐if="teachplan_first.children!=null" v‐for="(teachplan_second, index) in teachplan_first.children">
    <i class="glyphicon glyphicon‐check"></i>
    <a :href="url" @click="study(teachplan_second.id)">
        {{teachplan_second.pname}}
    </a>
</li>
```

#### 3.5.3 测试

访问在线学习页面：http://ucenter.xuecheng.com/#/learning/课程id/课程计划id。通过url传入两个参数：课程id和课程计划id，如果没有课程计划则传入0

测试项目如下：
1、传入正确的课程id、课程计划id，自动播放本章节的视频
2、传入正确的课程id、课程计划id传入0，自动播放第一个视频
3、传入错误的课程id或课程计划id，提示错误信息。
4、通过右侧章节目录切换章节及播放视频。

都🆗了



总流程：门户—>课程，搜索—>课程详情页，开始学习—>课程播放页

若没有开始学习之类按钮，就是模板文件生成时问题，变量赋值（和动态包含中js代码有关）

> 总流程这里竟然播放不了了！
>
> VIDEOJS: ERROR: (CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED) No compatible source was found for this media.



# 15 Spring Security OAuth2 认证

网关上面是认证；网关下面，即访问资源就是授权

![1553502615047](images/1553502615047.png)

![1553502736024](images/1553502736024.png)

之后补。。。

```java
@Api(value = "用户认证", description = "用户认证接口")
public interface AuthControllerApi {
    @ApiOperation("登录")
    LoginResult login(LoginRequest loginRequest);

    @ApiOperation("退出")
    ResponseResult logout();

    @ApiOperation("查询用户jwt令牌")
    JwtResult userjwt();
}
```



```java
@RestController
@RequestMapping("/")
public class AuthController implements AuthControllerApi {

    @Value("${auth.clientId}")
    String clientId;
    @Value("${auth.clientSecret}")
    String clientSecret;
    @Value("${auth.cookieDomain}")
    String cookieDomain;
    @Value("${auth.cookieMaxAge}")
    int cookieMaxAge;

    @Autowired
    AuthService authService;

    @Override
    @PostMapping("/userlogin")
    public LoginResult login(LoginRequest loginRequest) {
        if(loginRequest == null || StringUtils.isEmpty(loginRequest.getUsername())){
            ExceptionCast.cast(AuthCode.AUTH_USERNAME_NONE);
        }
        if(loginRequest == null || StringUtils.isEmpty(loginRequest.getPassword())){
            ExceptionCast.cast(AuthCode.AUTH_PASSWORD_NONE);
        }
        //账号
        String username = loginRequest.getUsername();
        //密码
        String password = loginRequest.getPassword();

        //申请令牌
        AuthToken authToken =  authService.login(username,password,clientId,clientSecret);

        //用户身份令牌
        String access_token = authToken.getAccess_token();
        //将令牌存储到cookie
        this.saveCookie(access_token);

        return new LoginResult(CommonCode.SUCCESS,access_token);
    }

    //将令牌存储到cookie
    private void saveCookie(String token){

        HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();
        //HttpServletResponse response,String domain,String path, String name, String value, int maxAge,boolean httpOnly
        CookieUtil.addCookie(response,cookieDomain,"/","uid",token,cookieMaxAge,false);

    }
    //从cookie删除token
    private void clearCookie(String token){

        HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();
        //HttpServletResponse response,String domain,String path, String name, String value, int maxAge,boolean httpOnly
        CookieUtil.addCookie(response,cookieDomain,"/","uid",token,0,false);
        //注意cookieDomain应该是一级域名，否则不能被其他域名访问到！！如xuecheng.com
    }

    //退出
    @Override
    @PostMapping("/userlogout")
    public ResponseResult logout() {
        //取出cookie中的用户身份令牌
        String uid = getTokenFormCookie();
        //删除redis中的token
        boolean result = authService.delToken(uid);
        //清除cookie
        this.clearCookie(uid);
        return new ResponseResult(CommonCode.SUCCESS);
    }

    @Override
    @GetMapping("/userjwt")
    public JwtResult userjwt() {
        //取出cookie中的用户身份令牌
        String uid = getTokenFormCookie();
        if(uid == null){
            return new JwtResult(CommonCode.FAIL,null);
        }

        //拿身份令牌从redis中查询jwt令牌
        AuthToken userToken = authService.getUserToken(uid);
        if(userToken!=null){
            //将jwt令牌返回给用户
            String jwt_token = userToken.getJwt_token();
            return new JwtResult(CommonCode.SUCCESS,jwt_token);
        }
        return null;
    }

    //取出cookie中的身份令牌
    private String getTokenFormCookie(){
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        Map<String, String> map = CookieUtil.readCookie(request, "uid");
        if(map!=null && map.get("uid")!=null){
            String uid = map.get("uid");
            return uid;
        }
        return null;
    }
}
```

```java
@Service
public class AuthService {

    @Value("${auth.tokenValiditySeconds}")
    int tokenValiditySeconds;
    @Autowired
    LoadBalancerClient loadBalancerClient;

    @Autowired
    StringRedisTemplate stringRedisTemplate;

    @Autowired
    RestTemplate restTemplate;
    //用户认证申请令牌，将令牌存储到redis
    public AuthToken login(String username, String password, String clientId, String clientSecret) {

        //请求spring security申请令牌
        AuthToken authToken = this.applyToken(username, password, clientId, clientSecret);
        if(authToken == null){
            ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL);
        }
        //用户身份令牌
        String access_token = authToken.getAccess_token();
        //存储到redis中的内容
        String jsonString = JSON.toJSONString(authToken);
        //将令牌存储到redis
        boolean result = this.saveToken(access_token, jsonString, tokenValiditySeconds);
        if (!result) {
            ExceptionCast.cast(AuthCode.AUTH_LOGIN_TOKEN_SAVEFAIL);
        }
        return authToken;

    }

    /**
     * 存储到令牌到redis
     * @param access_token 用户身份令牌
     * @param content  内容就是AuthToken对象的内容
     * @param ttl 过期时间
     * @return
     */
    private boolean saveToken(String access_token,String content,long ttl){
        String key = "user_token:" + access_token;
        stringRedisTemplate.boundValueOps(key).set(content,ttl, TimeUnit.SECONDS);
        Long expire = stringRedisTemplate.getExpire(key, TimeUnit.SECONDS);
        return expire>0;
    }
    //删除token
    public boolean delToken(String access_token){
        String key = "user_token:" + access_token;
        stringRedisTemplate.delete(key);
        return true;//可能Redis中Cookie已经过期，总之绝对会删除成功！
    }
    //从redis查询令牌
    public AuthToken getUserToken(String token){
        String key = "user_token:" + token;
        //从redis中取到令牌信息
        String value = stringRedisTemplate.opsForValue().get(key);
        //转成对象
        try {
            AuthToken authToken = JSON.parseObject(value, AuthToken.class);
            return authToken;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

    }
    //申请令牌
    private AuthToken applyToken(String username, String password, String clientId, String clientSecret){
        //从eureka中获取认证服务的地址（因为spring security在认证服务中）
        //从eureka中获取认证服务的一个实例的地址
        ServiceInstance serviceInstance = loadBalancerClient.choose(XcServiceList.XC_SERVICE_UCENTER_AUTH);
        //此地址就是http://ip:port
        URI uri = serviceInstance.getUri();
        //令牌申请的地址 http://localhost:40400/auth/oauth/token
        String authUrl = uri+ "/auth/oauth/token";
        //定义header
        LinkedMultiValueMap<String, String> header = new LinkedMultiValueMap<>();
        String httpBasic = getHttpBasic(clientId, clientSecret);
        header.add("Authorization",httpBasic);

        //定义body
        LinkedMultiValueMap<String, String> body = new LinkedMultiValueMap<>();
        body.add("grant_type","password");
        body.add("username",username);
        body.add("password",password);

        HttpEntity<MultiValueMap<String, String>> httpEntity = new HttpEntity<>(body, header);
        //String url, HttpMethod method, @Nullable HttpEntity<?> requestEntity, Class<T> responseType, Object... uriVariables

        //设置restTemplate远程调用时候，对400和401不让报错，正确返回数据
        restTemplate.setErrorHandler(new DefaultResponseErrorHandler(){
            @Override
            public void handleError(ClientHttpResponse response) throws IOException {
                if(response.getRawStatusCode()!=400 && response.getRawStatusCode()!=401){
                    super.handleError(response);
                }
            }
        });

        //这里调用Spring Security中loadUserByUsername方法，用户名和密码正确才获取令牌
        ResponseEntity<Map> exchange = restTemplate.exchange(authUrl, HttpMethod.POST, httpEntity, Map.class);

        //申请令牌信息
        Map bodyMap = exchange.getBody();
        if(bodyMap == null ||
            bodyMap.get("access_token") == null ||
                bodyMap.get("refresh_token") == null ||
                bodyMap.get("jti") == null){

            //解析spring security返回的错误信息（其内部实现的，没有返回令牌）
            if(bodyMap!=null && bodyMap.get("error_description")!=null){
                String error_description = (String) bodyMap.get("error_description");
                if(error_description.contains("UserDetailsService returned null")){
                    ExceptionCast.cast(AuthCode.AUTH_ACCOUNT_NOTEXISTS);
                }else if(error_description.contains("坏的凭证")){
                    ExceptionCast.cast(AuthCode.AUTH_CREDENTIAL_ERROR);
                }
            }


            return null;
        }
        AuthToken authToken = new AuthToken();
        authToken.setAccess_token((String) bodyMap.get("jti"));//用户身份令牌
        authToken.setRefresh_token((String) bodyMap.get("refresh_token"));//刷新令牌
        authToken.setJwt_token((String) bodyMap.get("access_token"));//jwt令牌
        return authToken;
    }



    //获取httpbasic的串
    private String getHttpBasic(String clientId,String clientSecret){
        String string = clientId+":"+clientSecret;
        //将串进行base64编码
        byte[] encode = Base64Utils.encode(string.getBytes());
        return "Basic "+new String(encode);
    }
}
```

```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    UserClient userClient;

    @Autowired
    ClientDetailsService clientDetailsService;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //取出身份，如果身份为空说明没有认证
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        //没有认证统一采用httpbasic认证，httpbasic中存储了client_id和client_secret，开始认证client_id和client_secret
        if(authentication==null){
            ClientDetails clientDetails = clientDetailsService.loadClientByClientId(username);
            if(clientDetails!=null){
                //密码
                String clientSecret = clientDetails.getClientSecret();
                return new User(username,clientSecret,AuthorityUtils.commaSeparatedStringToAuthorityList(""));
            }
        }
        if (StringUtils.isEmpty(username)) {
            return null;
        }
        //远程调用用户中心根据账号查询用户信息，密码角色权限等信息
        XcUserExt userext = userClient.getUserext(username);
        if(userext == null){
            //返回空给spring security表示用户不存在
            return null;
        }
        //取出正确密码（hash值）
        String password = userext.getPassword();
        //从数据库获取权限
        List<XcMenu> permissions = userext.getPermissions();
        if(permissions == null){
            permissions = new ArrayList<>();
        }
        List<String> user_permission = new ArrayList<>();
        permissions.forEach(item-> user_permission.add(item.getCode()));
        
        //使用静态的权限表示用户所拥有的权限
        //user_permission.add("course_get_baseinfo");//查询课程信息
        // user_permission.add("course_find_list");//图片查询
        String user_permission_string  = StringUtils.join(user_permission.toArray(), ",");
        UserJwt userDetails = new UserJwt(username,
                password,
                AuthorityUtils.commaSeparatedStringToAuthorityList(user_permission_string));
        userDetails.setId(userext.getId());
        userDetails.setUtype(userext.getUtype());//用户类型
        userDetails.setCompanyId(userext.getCompanyId());//所属企业
        userDetails.setName(userext.getName());//用户名称
        userDetails.setUserpic(userext.getUserpic());//用户头像
        return userDetails;
    }
}
```



# 16 Zuul 认证

引入依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

除了zuul外，因为网关还需要和Eureka注册的服务交互，所以还需要配置netflix-eureka-client



Zuul网关配置

```yaml
server:
  port: 50201
  servlet:
    context-path: /api
spring:
  application:
    name: xc-govern-gateway
  redis:
    host: ${REDIS_HOST:127.0.0.1}
    port: ${REDIS_PORT:6379}
    timeout: 5000 #连接超时 毫秒
    jedis:
      pool:
        maxActive: 3
        maxIdle: 3
        minIdle: 1
        maxWait: -1 #连接池最大等行时间 -1没有限制
zuul:
  routes:
    manage-course:
      path: /course/**
      serviceId: xc-service-manage-course #微服务名称，网关会从eureka中获取该服务名称下的服务实例的地址
      # 例子：将请求转发到http://localhost:31200/course
      #url: http://www.baidu.com #也可指定url，此url也可以是外网地址\
      strip-prefix: false #true：代理转发时去掉前缀，false:代理转发时不去掉前缀
      sensitiveHeaders:  #默认zuul会屏蔽cookie，cookie不会传到下游服务，这里设置为空则取消默认的黑名单，如果设置了具体的头信息则不会传到下游服务
      #   ignoredHeaders: 默认为空表示不过虑任何头
    xc-service-learning:  #路由名称，名称任意，保持所有路由名称唯一
      path: /learning/**
      serviceId: xc-service-learning #指定服务id，从Eureka中找到服务的ip和端口
      strip-prefix: false
      sensitiveHeaders:
    manage-cms:
      path: /cms/**
      serviceId: xc-service-manage-cms
      strip-prefix: false
      sensitiveHeaders:
    manage-sys:
      path: /sys/**
      serviceId: xc-service-manage-cms
      strip-prefix: false
      sensitiveHeaders:
    service-ucenter:
      path: /ucenter/**
      serviceId: xc-service-ucenter
      sensitiveHeaders:
      strip-prefix: false
    xc-service-manage-order:
      path: /order/**
      serviceId: xc-service-manage-order
      sensitiveHeaders:
      strip-prefix: false
eureka:
  client:
    registerWithEureka: true #服务注册开关
    fetchRegistry: true #服务发现开关
    serviceUrl: #Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔
      defaultZone: ${EUREKA_SERVER:http://localhost:50101/eureka/}
  instance:
    prefer-ip-address:  true  #将自己的ip地址注册到Eureka服务中
    ip-address: 127.0.0.1
    instance-id: ${spring.application.name}:${server.port} #指定实例id
ribbon:
  MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试，如果eureka中找不到服务则直接走断路器
  MaxAutoRetriesNextServer: 3 #切换实例的重试次数
  OkToRetryOnAllOperations: false  #对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false
  ConnectTimeout: 5000  #请求连接的超时时间
  ReadTimeout: 6000 #请求处理的超时时间
```



Zuul过滤器身份校验

```java
@Component
public class LoginFilter extends ZuulFilter {

    @Autowired
    AuthService authService;

    //过虑器的类型
    @Override
    public String filterType() {
        /**
         pre：请求在被路由之前执行
         routing：在路由请求时调用
         post：在routing和errror过滤器之后调用
         error：处理请求时发生错误调用
         */
        return "pre";
    }

    //过虑器序号，越小越被优先执行
    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        //返回true表示要执行此过虑器
        return true;
    }

    //过虑器的内容
    //测试的需求：过虑所有请求，判断头部信息是否有Authorization，如果没有则拒绝访问，否则转发到微服务。
    @Override
    public Object run() throws ZuulException {
        RequestContext requestContext = RequestContext.getCurrentContext();
        //得到request
        HttpServletRequest request = requestContext.getRequest();
        //得到response
        HttpServletResponse response = requestContext.getResponse();
        //取cookie中的身份令牌
        String tokenFromCookie = authService.getTokenFromCookie(request);
        if(StringUtils.isEmpty(tokenFromCookie)){
            //拒绝访问
            access_denied();
            return null;
        }
        //从header中取jwt
        String jwtFromHeader = authService.getJwtFromHeader(request);
        if(StringUtils.isEmpty(jwtFromHeader)){
            //拒绝访问
            access_denied();
            return null;
        }
        //从redis取出jwt的过期时间
        long expire = authService.getExpire(tokenFromCookie);
        if(expire<0){
            //拒绝访问
            access_denied();
            return null;
        }

        return null;
    }


    //拒绝访问
    private void access_denied(){
        RequestContext requestContext = RequestContext.getCurrentContext();
        //得到response
        HttpServletResponse response = requestContext.getResponse();
        //拒绝访问
        requestContext.setSendZuulResponse(false);
        //设置响应代码
        requestContext.setResponseStatusCode(200);
        //构建响应的信息
        ResponseResult responseResult = new ResponseResult(CommonCode.UNAUTHENTICATED);
        //转成json
        String jsonString = JSON.toJSONString(responseResult);
        requestContext.setResponseBody(jsonString);
        //转成json，设置contentType
        response.setContentType("application/json;charset=utf-8");
    }
}
```

```java
@Service
public class AuthService {

    @Autowired
    StringRedisTemplate stringRedisTemplate;

    //从头取出jwt令牌
    public String getJwtFromHeader(HttpServletRequest request){
        //取出头信息
        String authorization = request.getHeader("Authorization");
        if(StringUtils.isEmpty(authorization)){
            return null;
        }
        if(!authorization.startsWith("Bearer ")){
            return null;
        }
        //取到jwt令牌
        String jwt = authorization.substring(7);
        return jwt;


    }
    //从cookie取出token
    //查询身份令牌
    public String getTokenFromCookie(HttpServletRequest request){
        Map<String, String> cookieMap = CookieUtil.readCookie(request, "uid");
        String access_token = cookieMap.get("uid");
        if(StringUtils.isEmpty(access_token)){
            return null;
        }
        return access_token;
    }

    //查询令牌的有效期
     public long getExpire(String access_token){
        //key
         String key = "user_token:"+access_token;
         Long expire = stringRedisTemplate.getExpire(key, TimeUnit.SECONDS);
         return expire;
     }
}
```



# 17 授权

![1553562098002](images/1553562098002.png)

## 1 方法授权

有权限注解的方法必须有此权限

```java
@PreAuthorize("hasAuthority('course_find_list')")
@Override
@GetMapping("/coursebase/list/{page}/{size}")
public QueryResponseResult findCourseList(@PathVariable int page, @PathVariable int size, CourseListRequest courseListRequest) {
    return courseService.findCourseList(page,size,courseListRequest);
}

@Override
@PostMapping("/coursebase/add")
public AddCourseResult addCourse(@RequestBody CourseBase courseBase) {
    return courseService.addCourse(courseBase);
}

@PreAuthorize("hasAuthority('course_get_baseinfo666')")
@Override
@GetMapping("/coursebase/get/{courseId}")
public CourseBase getCourseBaseById(@PathVariable String courseId) {
    return courseService.getCourseBaseById(courseId);
}
```





## 2 细粒度授权

比如在课程服务中，其实就是根据登陆的用户所属的公司来展示课程列表！不能依赖框架，手动实现。在生成令牌时保存了此信息，并且在登陆成功后，前端请求后端不仅拿到身份令牌存入Cookie（短的令牌）还有JWT令牌并存储到SessionStorage中！请求后端时会从请求头传入令牌信息，解析其中的公司信息，并传入Service、Dao来条件查询即可

```java
@Override
public QueryResult<CourseInfo> findCourseList(@PathVariable("page") int page,
                                              @PathVariable("size") int size,
                                              CourseListRequest courseListRequest) {
    //调用工具类取出用户信息
    XcOauth2Util xcOauth2Util = new XcOauth2Util();
    XcOauth2Util.UserJwt userJwt = xcOauth2Util.getUserJwtFromHeader(request);
    if(userJwt == null){
        ExceptionCast.cast(CommonCode.UNAUTHENTICATED);
    }
    String companyId = userJwt.getCompanyId();
    return courseService.findCourseList(companyId,page,size,courseListRequest);
}
```





## 3 微服务之间认证

当微服务访问微服务，此时如果没有携带JWT则微服务会在授权时报错。

测试课程预览：
1、将课程管理服务和CMS全部添加授权配置
2、用户登录教学管理前端，进入课程发布界面，点击课程发布，观察课程管理服务端报错如下：

```
feign.FeignException: status 401 reading CmsPageClient#save(CmsPage); content:
{"error":"unauthorized","error_description":"Full authentication is required to access this
resource"}
```

由于课程管理访问CMS时没有携带JWT令牌导致。

### 3.1 Feign 拦截器

* 微服务之间**使用feign进行远程调用**，采用feign拦截器实现远程调用携带JWT。

  在common工程添加依赖：

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring‐cloud‐starter‐openfeign</artifactId>
  </dependency>
  ```

  在Common工程定义拦截器如下：

  ```java
  package com.xuecheng.framework.interceptor;
  public class FeignClientInterceptor implements RequestInterceptor {
      @Override
      public void apply(RequestTemplate requestTemplate) {
          try {
              //使用RequestContextHolder工具获取request相关变量
              ServletRequestAttributes attributes = (ServletRequestAttributes)
                  RequestContextHolder.getRequestAttributes();
              if(attributes!=null){
                  //取出request
                  HttpServletRequest request = attributes.getRequest();
                  Enumeration<String> headerNames = request.getHeaderNames();
                  if (headerNames != null) {
                      while (headerNames.hasMoreElements()) {
                          String name = headerNames.nextElement();
                          String values = request.getHeader(name);
                          if(name.equals("authorization")){
                              //System.out.println("name="+name+"values="+values);
                              requestTemplate.header(name, values);
                          }
                      }
                  }
              }
          }catch (Exception e) {
              e.printStackTrace();
          }
      }
  }
  ```

  使用Feign拦截器

  本例子中课程管理调用cms需要携带jwt，所以需要在课程管理中定义Feign拦截器bean，在启动类中定义bean如下：

  ```java
  @Bean
  public FeignClientInterceptor feignClientInterceptor(){
      return new FeignClientInterceptor();
  }
  ```

* 若是RestTemplate远程调用，则需要手动添加请求头（参考文档中测试代码）

